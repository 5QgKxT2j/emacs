;;; Automatically generated on Tue Apr  8 11:54:27 2014
;;; Invoked by k-ohsugi@VAIO using 24.3.1
(setq-default kill-ring '(#("PIT と CS を排他的に割り当てするためには， NPHT ( FIB ・
     PIT) と CS をパーティショニングする必要がある
" 0 38 (fontified t) 38 39 (fontified t) 39 71 (fontified t) 71 72 (fontified t)) #("   - フォワーディングエンジンの動作は，基本的に CCNx に従う
     - Cisco の NDN ルータのソフトウェアではオプションの処理ができず，
       現実的に利用するのは難しいと判断したため
" 0 35 (fontified t) 35 36 (fontified t) 36 80 (fontified t) 80 81 (fontified t) 81 108 (fontified t) 108 109 (fontified t)) #("   - フォワーディングエンジンの動作は，基本的に CCNx に従う
     - Cisco の NDN ルータのソフトウェアではオプションの処理ができず，
       現実的に利用するのは難しいと判断したため
   - CCNx では， FIB と PIT を NPHT (Name Prefix Hash Table) で管理して
     いるため， PIT と CS を排他的に割り当てするためには， NPHT ( FIB ・
     PIT) と CS をパーティショニングする必要がある
" 0 81 (fontified t) 81 254 (fontified t)) #(";;(set-face-attribute 'default nil :family \"Consolas\" :height 130)
;;(set-fontset-font nil 'japanese-jisx0208 (font-spec :family \"MeiryoKe_Console\"))
;;(setq face-font-rescale-alist '((\"MeiryoKe_Console\" . 0.50)))
" 0 2 (fontified t face font-lock-comment-delimiter-face) 2 66 (fontified t face font-lock-comment-face) 66 67 (fontified t) 67 69 (face font-lock-comment-delimiter-face fontified t) 69 149 (face font-lock-comment-face fontified t) 149 150 (fontified t) 150 152 (face font-lock-comment-delimiter-face fontified t) 152 213 (face font-lock-comment-face fontified t) 213 214 (fontified t)) #("    awful.key ({ modkey,\"Control\" }, \"v\", function () awful.util.spawn (\"vmplayer\") end)," 0 24 (fontified t) 24 33 (face font-lock-string-face fontified t) 33 37 (fontified t) 37 40 (face font-lock-string-face fontified t) 40 42 (fontified t) 42 50 (face font-lock-keyword-face fontified t) 50 72 (fontified t) 72 82 (face font-lock-string-face fontified t) 82 84 (fontified t) 84 87 (face font-lock-keyword-face fontified t) 87 89 (fontified t)) #("     { rule = { class = \"V2C\" },
       properties = { tag = tags[1][6] } },
" 0 24 (fontified t) 24 29 (fontified t face font-lock-string-face) 29 32 (fontified t) 32 33 (fontified t) 33 76 (fontified t) 76 77 (fontified t)) #("     { rule = { class = \"Skype\" },
       properties = { tag = tags[1][8] } }," 0 24 (fontified t) 24 31 (face font-lock-string-face fontified t) 31 78 (fontified t)) #("run_once(\"xfce4-terminal\", \"--hide-menubar --hide-borders --hide-toolbar\")" 0 9 (fontified t) 9 25 (fontified t face font-lock-string-face) 25 27 (fontified t) 27 73 (fontified t face font-lock-string-face) 73 74 (fontified t)) #("run_once(\"ibus-daemon -drx\", nil, 1)
" 0 9 (fontified t) 9 27 (face font-lock-string-face fontified t) 27 29 (fontified t) 29 32 (face font-lock-constant-face fontified t) 32 36 (fontified t) 36 37 (fontified t)) #("function run_once(prg,arg_string) -- NOTE: screen and tag are different.
    if not prg then
        do return nil end
    end
    if not arg_string then 
        awful.util.spawn_with_shell(\"pgrep -u $USER -x \" .. prg .. \" || (\" .. prg .. \")\")
    else
        awful.util.spawn_with_shell(\"pgrep -u $USER -x \" .. prg .. \" || (\" .. prg .. \" \" .. arg_string .. \")\")
    end
end
" 0 8 (fontified t face font-lock-keyword-face) 8 9 (fontified t) 9 17 (fontified t face font-lock-function-name-face) 17 34 (fontified t) 34 37 (fontified t face font-lock-comment-delimiter-face) 37 73 (fontified t face font-lock-comment-face) 73 77 (fontified t) 77 79 (fontified t face font-lock-keyword-face) 79 80 (fontified t) 80 83 (fontified t face font-lock-keyword-face) 83 88 (fontified t) 88 92 (fontified t face font-lock-keyword-face) 92 101 (fontified t) 101 103 (fontified t face font-lock-keyword-face) 103 104 (fontified t) 104 110 (fontified t face font-lock-keyword-face) 110 111 (fontified t) 111 114 (fontified t face font-lock-constant-face) 114 115 (fontified t) 115 118 (fontified t face font-lock-keyword-face) 118 123 (fontified t) 123 126 (fontified t face font-lock-keyword-face) 126 131 (fontified t) 131 133 (fontified t face font-lock-keyword-face) 133 134 (fontified t) 134 137 (fontified t face font-lock-keyword-face) 137 149 (fontified t) 149 153 (fontified t face font-lock-keyword-face) 153 191 (fontified t) 191 211 (fontified t face font-lock-string-face) 211 222 (fontified t) 222 229 (fontified t face font-lock-string-face) 229 240 (fontified t) 240 243 (fontified t face font-lock-string-face) 243 249 (fontified t) 249 253 (fontified t face font-lock-keyword-face) 253 290 (fontified t) 290 310 (fontified t face font-lock-string-face) 310 321 (fontified t) 321 328 (fontified t face font-lock-string-face) 328 339 (fontified t) 339 342 (fontified t face font-lock-string-face) 342 360 (fontified t) 360 363 (fontified t face font-lock-string-face) 363 369 (fontified t) 369 372 (fontified t face font-lock-keyword-face) 372 373 (fontified t) 373 376 (fontified t face font-lock-keyword-face) 376 377 (fontified t)) #("function run_once(prg,arg_string,screen) -- NOTE: screen and tag are different.
    if not prg then
        do return nil end
    end
    if not arg_string then 
        awful.util.spawn_with_shell(\"pgrep -f -u $USER -x \" .. prg .. \" || (\" .. prg .. \")\",screen)
    else
        awful.util.spawn_with_shell(\"pgrep -f -u $USER -x \" .. prg .. \" || (\" .. prg .. \" \" .. arg_string .. \")\",screen)
    end
end
" 0 8 (fontified t face font-lock-keyword-face) 8 9 (fontified t) 9 17 (fontified t face font-lock-function-name-face) 17 41 (fontified t) 41 44 (fontified t face font-lock-comment-delimiter-face) 44 80 (fontified t face font-lock-comment-face) 80 84 (fontified t) 84 86 (fontified t face font-lock-keyword-face) 86 87 (fontified t) 87 90 (fontified t face font-lock-keyword-face) 90 95 (fontified t) 95 99 (fontified t face font-lock-keyword-face) 99 100 (fontified t) 100 108 (fontified t) 108 110 (fontified t face font-lock-keyword-face) 110 111 (fontified t) 111 117 (fontified t face font-lock-keyword-face) 117 118 (fontified t) 118 121 (fontified t face font-lock-constant-face) 121 122 (fontified t) 122 125 (fontified t face font-lock-keyword-face) 125 130 (fontified t) 130 133 (fontified t face font-lock-keyword-face) 133 138 (fontified t) 138 140 (fontified t face font-lock-keyword-face) 140 141 (fontified t) 141 144 (fontified t face font-lock-keyword-face) 144 156 (fontified t) 156 160 (fontified t face font-lock-keyword-face) 160 198 (fontified t) 198 221 (fontified t face font-lock-string-face) 221 232 (fontified t) 232 239 (fontified t face font-lock-string-face) 239 250 (fontified t) 250 253 (fontified t face font-lock-string-face) 253 266 (fontified t) 266 270 (fontified t face font-lock-keyword-face) 270 307 (fontified t) 307 330 (fontified t face font-lock-string-face) 330 341 (fontified t) 341 348 (fontified t face font-lock-string-face) 348 359 (fontified t) 359 362 (fontified t face font-lock-string-face) 362 380 (fontified t) 380 383 (fontified t face font-lock-string-face) 383 396 (fontified t) 396 399 (fontified t face font-lock-keyword-face) 399 400 (fontified t) 400 403 (fontified t face font-lock-keyword-face) 403 404 (fontified t)) #("run_once(\"udiskie\", \"--tray\")" 0 9 (fontified t) 9 18 (fontified t face font-lock-string-face) 18 20 (fontified t) 20 28 (fontified t face font-lock-string-face) 28 29 (fontified t)) #("
" 0 1 (fontified t)) #("\\alpha{}" 0 1 (face #1=(font-latex-sedate-face) fontified t) 1 6 (face #1# fontified t) 6 7 (fontified t) 7 8 (fontified t)) #("hoge
" 0 4 (fontified t) 4 5 (fontified t)) "\\bibliographystyle{junsrt}" #("bibliographystyle" 0 17 (fontified t)) #("bibliography" 0 12 (fontified t)) #("\\bibliosytle" 0 12 (fontified t face (font-latex-sedate-face))) "@inproceedings{in2013-162,
	author    = {中井悠人 and 塚本圭一郎 and 小泉佑揮 and 長谷川亨},
	title     = {CCNxルータの電力消費モデルの提案},
	booktitle = {信学技報},
	volume    = {113},
	number    = {473},
	series    = {IN2013-162},
	pages     = {111-116},
	address   = {},
	month     = {3月},
	year      = {2014},
	note      = {2014年3月6日(木)－3月7日(金)　宮崎シーガイア (NS, IN)}
}" "末筆ながら、" "益々のご発展とご活躍を心よりお祈り申し上げます" "
" "貴社の益々のご発展とご活躍を心よりお祈り申し上げます．" "今後，白物家電等を購入することがありましたら，貴社のグループの製品を購
入したいと思います．
" "今後とも貴社の益々のご発展とご活躍を心よりお祈り申し上げます。 " "



" "> ４／７の一次マッチングの後、
> お茶とか一緒にいかがですか？" "% Created 2014-04-01 Tue 15:57
\\documentclass[dvipdfmx,11pt]{beamer}
\\usepackage{url}
\\usepackage{pxjahyper}
\\usetheme{Berlin}
\\setbeamertemplate{navigation symbols}{}
\\beamertemplatetextbibitems
\\setbeamertemplate{footline}[frame number]
\\setbeamertemplate{headline}{}


\\institute[]{大阪大学大学院情報科学研究科\\\\
            情報ネットワーク学専攻\\\\
            情報流通プラットフォーム講座 長谷川研究室 M2}
\\usetheme{default}
\\author{大杉 海斗}
\\date{\\today}
\\title{M2 Meeting}
\\hypersetup{
  pdfkeywords={},
  pdfsubject={},
  pdfcreator={Emacs 24.3.1 (Org mode 8.2.5h)}}
\\begin{document}

\\maketitle
\\section{2014 年 4 月 9 日}
\\label{sec-1}
\\begin{frame}[label=sec-1-1]{研究目標}
\\begin{block}{短期的な目標 (5 月)}%x
\\begin{itemize}
\\item 中井さんが提案した NDN ルータの電力消費モデルをマルチコア CPU に対応させる
\\end{itemize}
\\end{block}

\\begin{block}{それ以降の目標}%x
\\begin{itemize}
\\item CCNx の最新 ver に対応させる
\\item FIB ・ PIT ・ CS のテーブルサイズの大きさが，電力消費にどのような
影響を与えるかを調査する
\\begin{itemize}
\\item 該当エントリの lookup に要する時間が長くなるため，テーブルサイ
ズが大きいほうが電力消費は大きくなると思われる
\\end{itemize}
\\end{itemize}
\\end{block}
\\end{frame}

\\begin{frame}[label=sec-1-2]{前回ミーティングのまとめ}
\\begin{itemize}
\\item フォワーディングエンジンの動作は，基本的に CCNx に従う
\\begin{itemize}
\\item Cisco の NDN ルータのソフトウェアではオプションの処理ができず，
現実的に利用するのは難しいと判断したため
\\end{itemize}
\\item CCNx では， FIB と PIT を NPHT (Name Prefix Hash Table) で管理して
いるため， PIT と CS を排他的に割り当てするためには， NPHT ( FIB ・
PIT) と CS をパーティショニングする必要がある
\\end{itemize}
\\end{frame}

\\section{2014 年 4 月 1 日}
\\label{sec-2}
\\begin{frame}[label=sec-2-1]{研究目標}
\\begin{block}{短期的な目標 (5 月)}%x
\\begin{itemize}
\\item 中井さんが提案した NDN ルータの電力消費モデルをマルチコア CPU に対応させる
\\end{itemize}
\\end{block}

\\begin{block}{それ以降の目標}%x
\\begin{itemize}
\\item CCNx の最新 ver に対応させる
\\item FIB ・ PIT ・ CS のテーブルサイズの大きさが，電力消費にどのような
影響を与えるかを調査する
\\begin{itemize}
\\item 該当エントリの lookup に要する時間が長くなるため，テーブルサイ
ズが大きいほうが電力消費は大きくなると思われる
\\end{itemize}
\\end{itemize}
\\end{block}
\\end{frame}
\\begin{frame}[label=sec-2-2]{前回ミーティングのまとめ (1)}
\\begin{itemize}
\\item 下図の D (ディスパッチャ) と A0 〜 A2 (NDN パケットを処理するプロ
セス) がパケットを処理するのに要するクロック数を測定する
\\begin{itemize}
\\item 下図の A0 〜 A2 がパケットを処理するのに要するクロック数は，中井さんの測定し
た結果から分かる
\\item D が処理するのに要するクロック数は，新たに計測する
\\begin{itemize}
\\item そのために，まずはディスパッチャの設計を考える必要がある
\\end{itemize}
\\end{itemize}
\\end{itemize}

\\includegraphics[width=.9\\linewidth]{./figure/hardware-crop.pdf}
\\end{frame}
\\begin{frame}[label=sec-2-3]{前回ミーティングのまとめ (2)}
\\begin{itemize}
\\item フォワーディングエンジンの動作は，基本的に CCNx に従う
\\begin{itemize}
\\item Cisco の NDN ルータのソフトウェアではオプションの処理ができず，
現実的に利用するのは難しいと判断したため
\\end{itemize}
\\item CCNx では， FIB と PIT を NPHT (Name Prefix Hash Table) で管理して
いるため， PIT と CS を排他的に割り当てするためには， NPHT ( FIB ・
PIT) と CS をパーティショニングする必要がある
\\end{itemize}

\\begin{block}{参考: Cisco の設計}%x
\\begin{itemize}
\\item Cisco は， PIT と CS を同一テーブルで管理し，それぞれの CPU コアへ
排他的に割り当て， FIB は CPU コア間で共有している
\\end{itemize}
\\end{block}
\\end{frame}
\\begin{frame}[label=sec-2-4]{進捗状況}
\\begin{itemize}
\\item 各 CPU コアにパケット処理を割り当てするディスパッチャを設計した
\\item ポスターの原稿を修正した
\\begin{itemize}
\\item CCN の説明を追加した
\\item 武政君の研究内容 (CCN ルータのキャッシュヒット率の導出) を追加した
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-2-5]{ディスパッチャの要件}
\\begin{itemize}
\\item できるだけ各 CPU の使用率を均等にする
\\item パケット処理は，そのパケットの親の処理が割り当てられたのと同じ
CPU に割り当てされなければならない
\\begin{itemize}
\\item FIB エントリの最長一致検索によるパケットフォワーディングのため，
各エントリは親エントリへのリンクを張っているから
\\item パケット /a/b/0 ・/a/b ・/a は，必ず同じ CPU に割り当てされる必要がある
\\end{itemize}
\\end{itemize}

\\begin{block}{参考: Cisco の設計}%x
\\begin{itemize}
\\item CPU コア間で FIB を共有しているため，パケットの full-name をハッ
シュ化し，そのハッシュ値で CPU コアへと振り分けしている
\\item full-name の偏りによっては，特定 CPU コアに処理が集中する可能性が
ある
\\end{itemize}
\\end{block}
\\end{frame}
\\begin{frame}[label=sec-2-6]{ディスパッチャの設計}
\\begin{itemize}
\\item 2 種類の設計を考えた
\\begin{itemize}
\\item 方式 1: 現在の各 CPU コアの負荷に関係なく，入力パケットの Root
Prefix\\footnote{Root Prefix: パケットの名前を tree に見立てた時の根に当たる Prefix (例: /a/b/0 ならば/a ，/b/c/d ならば/b)} のハッシュ値によってパケット処理を割り当てする CPU コアを
決定する
\\begin{itemize}
\\item (ハッシュ値 mod n) = 1 ならばコア 1 ， = 2 ならばコア 2\\ldots{}\\ldots{}の
ようなイメージ
\\item 処理が簡単
\\item 特定の CPU コアに負荷が集中する可能性がある
\\end{itemize}
\\item 方式 2: 現在の各 CPU コアの負荷に応じて，パケット処理を割り当て
する CPU コアを変更する
\\begin{itemize}
\\item 詳細は後述
\\item 処理が複雑
\\item 特定の CPU コアへの負荷の集中を防ぐことができる
\\end{itemize}
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-2-7]{方式 2 の詳細 (1)}
\\begin{itemize}
\\item パケットの処理をどの CPU コアへ割り当てするかの選択が，パケットの
Root Prefix にのみ依存することに着目
\\begin{itemize}
\\item Root Prefix と割り当てする CPU コアの対応をテーブルで管理する
\\begin{itemize}
\\item Root Prefix ならば，それほど数がなさそう
\\end{itemize}
\\end{itemize}
\\item Key は Root Prefix のハッシュ値
\\item テーブルにない Root Prefix を持つパケットが到着した時は， CPU 負荷
の低いコアへ割り当てし，その対応をテーブルに追加
\\end{itemize}

\\includegraphics[width=.9\\linewidth]{./figure/dispatcher_table-crop.pdf}
\\end{frame}
\\begin{frame}[label=sec-2-8]{方式 2 の詳細 (2)}
\\begin{itemize}
\\item いつまでも同じコアへとパケットを割り当てをしていては，この方式の意
味がないため，一定時間 (Time to Live で指定) 経過後にテーブル
からエントリを削除
\\begin{itemize}
\\item Time to Live はその Root Prefix を持つすべてのパケットが対応する
FIB ・ PIT ・ CS の エントリが expire するまでの時間の最大値と同
じにする必要がある
\\begin{itemize}
\\item 該当するエントリがある FIB ・ PIT ・ CS を持つ App Process へとパ
ケットの処理を割り当てするため
\\end{itemize}
\\end{itemize}
\\item App Process はパケット処理後に Time to Live にセットする値を返す
\\end{itemize}

\\includegraphics[width=.9\\linewidth]{./figure/dispatcher_table-crop.pdf}
\\end{frame}
\\begin{frame}[label=sec-2-9]{2 つの方式に対する考え}
\\begin{itemize}
\\item 方式 2 の方が現実的であると思われる
\\begin{itemize}
\\item 方式 1 では， 各 CPU コアの負荷がコンテンツの名前空間に依存する
\\begin{itemize}
\\item コンテンツの名前は，ルータのベンダが決められるものではないため，特定の CPU コアに処理が集中すると予想される
\\end{itemize}
\\end{itemize}
\\item 方式 2 の別案として，全 CPU コアに毎回 Root Prefix で lookup を行う方法もある
\\begin{itemize}
\\item テーブルを保持する必要はないが，オーバーヘッドが大きい
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-2-10]{パケット (Interest/Data の両方) 到着時のプロセス}
\\begin{enumerate}
\\item パケットの Root Prefix より Hash 値を計算し，その値によりディス
パッチャの持つテーブルを参照
\\item HIT 時: ディスパッチャは， App Process へとパケット処理を割り当て
し， App Process から Time to Live にセットする値 (エントリの残り
時間) を受け取る
\\item MISS 時: CPU 使用率の低いコアへとパケット処理を割り当てし，テーブ
ルにエントリを作成 (Time to Live は App Process がパケット処理時
に返却)
\\end{enumerate}
\\end{frame}

\\begin{frame}[label=sec-2-11]{}
\\end{frame}
\\section{2014 年 3 月 25 日}
\\label{sec-3}
\\begin{frame}[label=sec-3-1]{前回ミーティングのまとめ}
\\begin{itemize}
\\item マルチコア CPU を搭載した NDN ルータ (ソフトウェアベース) の電
力消費を測定するために必要なハードウェア・ソフトウェア構成を考え
る
\\begin{itemize}
\\item ハードウェアは，専用のルータではなく，一般的な PC を想定している
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-3-2]{研究目標}
\\begin{block}{短期的な目標 (5 月)}%x
\\begin{itemize}
\\item 中井さんが提案した NDN ルータの電力消費モデルをマルチコア CPU に対応させる
\\end{itemize}
\\end{block}

\\begin{block}{それ以降の目標}%x
\\begin{itemize}
\\item CCNx の最新 ver に対応させる
\\item FIB ・ PIT ・ CS のテーブルサイズの大きさが，電力消費にどのような
影響を与えるかを調査する
\\begin{itemize}
\\item 該当エントリの lookup に要する時間が長くなるため，テーブルサイ
ズが大きいほうが電力消費は大きくなると思われる
\\end{itemize}
\\end{itemize}
\\end{block}
\\end{frame}
\\begin{frame}[label=sec-3-3]{進捗状況}
\\begin{itemize}
\\item マルチコア CPU を搭載した NDN ルータ (ソフトウェアベース) の電力消
費を測定するために必要なハードウェア・ソフトウェア構成を考えた
\\item マルチコア CPU 環境におけるクロック数の測定方法を検討した
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-3-4]{現在考えられる課題一覧}
\\begin{itemize}
\\item マルチスレッドに対応した NDN ソフトウェアの作成
\\begin{itemize}
\\item 特定 CPU コアへのスレッドの割り当て (おそらく下の API を用いることで可能)
\\begin{itemize}
\\item sched\\_get\\_affinity ()
\\item sched\\_set\\_affinity ()
\\item \\url{http://linuxjm.sourceforge.jp/html/LDP_man-pages/man2/sched_setaffinity.2.html}
\\end{itemize}
\\end{itemize}
\\item CPU がマルチコアの時に電力消費量を推定できるモデルの提案
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-3-5]{本日のミーティングで議論したいこと}
\\begin{itemize}
\\item NDN ルータのソフトウェア構成およびハードウェア構成に問題がないか
\\item 今後行っていく作業の優先順位付け
\\item 研究室紹介に使うポスターの内容
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-3-6]{NDN ルータのハードウェア構成}
\\begin{itemize}
\\item CPU: Intel Xeon E3-1220 (3.1GHz x 4 コア)
\\begin{itemize}
\\item ハイパースレッディングとターボブーストはとりあえず無効化する
\\end{itemize}
\\item Memory: DDR3 16GB,1600MHz
\\begin{itemize}
\\item FIB ・ PIT ・ CS のテーブルサイズについて今は考慮しないため，
Memory サイズはそれほど考慮しない
\\end{itemize}
\\item HDD: Western Digital 2TB SATA 3.5 inch \"WD2000FYYX\"
\\begin{itemize}
\\item Memory と同様であまり考慮しない
\\end{itemize}
\\item NIC: Intel 10-Gigabit Ethernet x 2
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-3-7]{NDN パケットフロー}
\\begin{itemize}
\\item 4 コアなので D と A0 〜 3 にそれぞれ 1 コアずつ割り当てる
\\end{itemize}
\\includegraphics[width=.9\\linewidth]{./figure/hardware-crop.pdf}
\\end{frame}

\\begin{frame}[label=sec-3-8]{NDN ルータのソフトウェア構成の概要}
\\begin{itemize}
\\item ソフトウェアの動作は，基本的に CCNx に従う
\\begin{itemize}
\\item Cisco の NDN ルータのソフトウェアではオプションの処理ができず，
現実的に利用するのは難しいと判断したため
\\end{itemize}
\\item 一方で， PIT と CS に関しては，複数の CPU が同一エントリへアクセス
した時の排他制御によるパフォーマンスの低下が大きいと予想されるため，
PIT と CS はパーティショニングを行う
\\begin{itemize}
\\item マルチコアへのスレッドの割り当てなどは Cisco のデモを参考にする
\\end{itemize}
\\item ソフトウェアでは次のことを行う
\\begin{itemize}
\\item NDN パケットのフォワーディング処理
\\item CPU コアへのスレッドの割り当て (ディスパッチ処理)
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-3-9]{NDN ルータのソフトウェア}
\\begin{itemize}
\\item パケットの full-name のハッシュ値によって，パケットの処理を各 CPU コ
アに振り分ける
\\begin{itemize}
\\item NPHT (FIB ・ PIT) と CS を 3 つにパーティショニングする
\\begin{itemize}
\\item NPHT は， bucket が 6 つだとすると， 0 ・ 1 はテーブル 1 とし
てコア 1 ， 2 ・ 3 はテーブル 2 としてコア 2 ， 4 ・ 5 はテー
ブル 3 としてコア 3 というように割り当てする
\\item FIB までパーティショニングされてしまい， parent にリンクを貼
ることによる fast lookup が使えないという問題がある
\\end{itemize}
\\end{itemize}
\\item PIT (CS) の lookup 処理および insert 処理の前に，処理対象のパケッ
トの full-name をハッシュ化
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-3-10]{}
\\includegraphics[width=.9\\linewidth]{./figure/CCN_Algorithm_detail-crop.pdf}
\\end{frame}
\\begin{frame}[label=sec-3-11]{Interest パケットがデーモンに到着した時のシーケンス}
\\begin{enumerate}
\\item パケットを name 部とオプション部に parse
\\item duplication check (重複検知)
\\item パケットの name 部からハッシュ値を計算， Prefix Seek の処理以降を
スレッドにし， ハッシュ値に応じた CPU コアに割り当て
\\end{enumerate}
\\end{frame}
\\begin{frame}[label=sec-3-12]{マルチコア CPU 環境におけるクロック数の測定方法}
\\begin{itemize}
\\item おそらく中井さんが用いた RDTSC 命令を用いることで，マルチコア CPU で
もクロック数の測定が可能である
\\begin{itemize}
\\item タイムスタンプカウンタ (TSC) が， Invariant TSC ならばマルチコ
ア環境でも正確にクロック数を測定可能である
\\begin{itemize}
\\item \\url{http://www.02.246.ne.jp/~torutk/cxx/clock/cpucounter.html}
\\end{itemize}
\\item 本実験で使う予定の Intel Xeon E3-1220 は Invariant TSC であることを確認した
\\end{itemize}
\\item さらに， Turbo boost でクロック数が変化した場合でも正確にクロック
を測定できる
\\item 一方で，マルチ CPU 環境ではクロック測定が困難であると予想される
\\begin{itemize}
\\item クロック数をリセットする信号がプロセッサ単位でしか送信できない
ため
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-3-13]{}
\\end{frame}
\\section{2014 年 3 月 17 日}
\\label{sec-4}
\\begin{frame}[label=sec-4-1]{前回ミーティングのまとめ}
\\begin{itemize}
\\item 中井さんがクロック数を測定した PC (CPU:Intel Xeon) で，
10Gigabit-Ethernet カードが使えるかどうかを確認する
\\item 「 named data networking on a router forwarding at 20 gbps and
beyond 」を参考に， 20Gb や 40Gb の転送速度を出せるソフトウェアルー
タを作る時に，必要となるハードウェアの構成を考える
\\item CCNx のデータ構造とオペレーショナルフローについてまとめた資料の誤
りを修正する
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-4-2]{研究目標}
\\begin{block}{短期的な目標}%x
\\begin{itemize}
\\item CCNx の ver8.1 で機能ごとのブロックを作り，ブロックの処理に必要な
クロック数を測定する
\\end{itemize}
\\end{block}

\\begin{block}{中期的な目標 (5 月)}%x
\\begin{itemize}
\\item 現在，ルータのモデル化は， CPU がシングルコアの時のみできているた
め，モデルをマルチコア or マルチ CPU に対応させる
\\end{itemize}
\\end{block}
\\end{frame}

\\begin{frame}[label=sec-4-3]{目標達成に向けてのアプローチ}
\\begin{enumerate}
\\item 中井さんの資料および CCNx のソースコードを読み， CCNx ver8.1 の処理をブロッ
クに分割し，それぞれのブロックの処理に必要なクロック数を測定する
(最新 ver に拘らないならば，中井さんが実験を行った ver7.2 を使えばよ
 いため，このプロセスは飛ばすことができる)
\\item 1.で計測されたクロック数を基に， CCNx の挙動を模倣するプログラムを
作成する
\\begin{itemize}
\\item CCNx はマルチスレッドに対応していない (?) ため
\\item CCNx における各ブロックの処理にかかるクロック数だけ， dummy の処
理を行わせる
\\item NDN パケットの送受信するタイミングで， UDP パケットを送受信す
る
\\end{itemize}
\\item 2.で作成したプログラムを動作させた PC の電力消費を測定する
\\end{enumerate}
\\end{frame}
\\begin{frame}[label=sec-4-4]{進捗状況}
\\begin{itemize}
\\item 中井さんがクロック数を測定した PC (CPU:Intel Xeon) で，
10Gigabit-Ethernet カードが使えることを確認した
\\begin{itemize}
\\item 他の PC とケーブルで繋ぎ， ping が通ることを確認
\\item 当該 PC の 10Gigabit-Ethernet カードを接続するスロット数 (PCI-Express x8)
は 1 つで，カードのインターフェース数は 2 つのため，最大で
20Gbps までしか測定できない
\\end{itemize}
\\item 「 named data networking on a router forwarding at
20 Gbps and beyond 」を読み必要なハードウェア構成について考えた
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-4-5]{議論したいこと}
\\begin{itemize}
\\item 今回ハードウェアの構成を考えたが， CCNx の動作で 20Gbps を達成するのは困難である
と予想された
\\item したがって，何にフォーカスを当て (コントリビューションは何か) ，
何を優先すべきかを議論したいと考えている
\\begin{itemize}
\\item 中井さんの提案したモデルを， CCNx の最新版に対応させること
\\item 中井さんの提案したモデルを，マルチコア or マルチ CPU に対応させること
\\item 現実的なアクセスルータを考慮して， 20Gbps や 40Gbps のスループットを達成できるハードウェアと，ソフ
トウェアを調査し，その電力消費量を測定すること
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-4-6]{}
\\begin{itemize}
\\item 次ページより，「 named data networking on a router forwarding at
20 Gbps and beyond 」の内容をまとめる
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-4-7]{概要}
\\begin{itemize}
\\item Cisco ASR9000 上の Linux で NDN フォワーディングエンジンを動作さ
せ，そのパフォーマンスを測定している
\\item NDN フォワーディングエンジンは CCNx ではなく， CS ・ FIB ・ PIT のデータ構造も異なっ
ている
\\item シミュレーションの結果， Interest および Data のフォワーディング
スループットが， 20Gbps を超えることを示している
\\begin{itemize}
\\item シミュレーションでは，実際には NIC を通したパケットの送受信を行っておらず，
ファイルからパケットを読み込むことで擬似的なフォワーディング処理
を行っている
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-4-8]{Cisco の NDN ソフトウェアルータのハードウェア構成}
\\begin{itemize}
\\item モデル名: Cisco ASR9000
\\item CPU: Intel Xeon (Westmeie-EP) 2.0GHz 6 コア (Hyper-threading 有) * 2
\\item LAN: Intel Niantic 10Gigabit Ethernet  * 4
\\item Storage: 3.2TB SSD (NDN の Cache Storage として使用)
\\item 64bit Linux 上のソフトウェアでパケットフォワーディングを行ってい
る
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-4-9]{NDN フォワーディングエンジン}
\\begin{itemize}
\\item CCNx とはデータ構造や look up の方法が大きく異なる
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-4-10]{FIB}
\\begin{itemize}
\\item FIB look up の方法が CCNx と異なる (あまり関係なさそうなので割愛)
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-4-11]{CS ・ PIT}
\\begin{itemize}
\\item CS と PIT の管理は 1 つのハッシュテーブルで行い， look up は同時に
行う
\\begin{itemize}
\\item どちらも full-name を key とするため
\\item エントリが CS のものか PIT のものかは 1bit の flag で判断する
\\end{itemize}
\\item PIT (CS/PIT) を CPU の各コア (thread) に分割する
\\begin{itemize}
\\item 複数のコアで PIT を共有するとパフォーマンスが落ちるため
\\item Interest および Data の full-name のハッシュで PIT を CPU コア
(thread) に振り分け
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-4-12]{NDN パケットのフロー}
\\begin{itemize}
\\item App process (A0 〜 A7) で， NDN フォワーディング処理をすべて行う
(CS/PIT look up ， FIB look up)
\\end{itemize}

\\includegraphics[width=0.8\\linewidth,height=0.6\\textheight]{./figure/NDN_packet_flow.pdf}
\\end{frame}
\\begin{frame}[label=sec-4-13]{シミュレーション結果}
\\begin{itemize}
\\item 16 個の IRCache URL のトレースから 1300 万 Interest を作成し，シミュレー
ションを行っている
\\item 異なる CPU コア上で動作させるスレッド数の増加に伴いパフォーマンスは向上している
\\item FIB と PIT のサイズはパフォーマンスにほとんど影響を与えていない
\\begin{itemize}
\\item PIT/CS サイズが向上するとパフォーマンスが低下していることから，
PIT/CS look up でほとんどヒットせず，エントリの探索に時間がかかっ
ただけになっているからではないかと思われる
\\end{itemize}
\\end{itemize}
\\includegraphics[width=0.8\\linewidth,height=0.4\\textheight]{./figure/performance_of_NDN.pdf}
\\end{frame}
\\begin{frame}[label=sec-4-14]{20Gbps を達成する時に必要な CPU}
\\begin{itemize}
\\item 29.78G (clocks/s) を達成できるもの
\\begin{itemize}
\\item 1 秒間に処理するパケット数を算出 (パケットサイズ 2KB は， Interest と Data が同
数であると仮定し，標準チャンクサイズ 4KB を 2 で割って算出
(Interest のサイズは小さいので無視))
\\begin{itemize}
\\item 20Gbps / (2K*8) = 1.25M (packet/s)
\\end{itemize}
\\item Interest と Data のペアの処理にかかる合計クロック数 48787 をかけ
て 2 で割る (こちらも Interest と Data が同数であると仮定． CS
HIT0\\%のとき．中井さんの論文から算出)
\\begin{itemize}
\\item 1.25M * 48784 / 2  = 30491.88 M (clocks/s)
= 29.78 G (clocks/s)
\\end{itemize}
\\end{itemize}
\\item 上の計算仮定には， XML の処理が入っていない．また，パケットサイズ
を 2KB としているが， Cisco は 500B としている．したがって，上記の
結果は甘く見積もっており， CCNx の挙動をそのまま模倣すると CPU の処
理が間に合わないと予想される．
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-4-15]{20Gbps を達成する時に必要な主記憶}
\\begin{itemize}
\\item Cisco のデモから， FIB および PIT のサイズはあまりスループットに影響し
ていないため， 1Gbyte もあれば十分ではないかと思われる
\\item 一方で， FIB ・ PIT の fast look up は時間のかかる処理であるため，
主記憶の速度は重要である
\\begin{itemize}
\\item 十分考えられていない
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-4-16]{20Gbps を達成する時に必要なネットワークインターフェース}
\\begin{itemize}
\\item 10Gigabit-Ethernet * 4
\\begin{itemize}
\\item Cisco と同様
\\item 十分考えられていない
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-4-17]{}
\\end{frame}
\\section{2014 年 3 月 12 日}
\\label{sec-5}
\\begin{frame}[label=sec-5-1]{前回ミーティングのまとめ}
\\begin{itemize}
\\item 「 Scalable NDN Forwarding:Concepts, Issues and Principles 」を読
み， CCNx のデータ構造についてまとめたが，説明不足な部分があったた
め，コメントに基づいて更新を行なう
\\item 今後どのように研究を進めていくかを本日のミーティングで検討する
\\end{itemize}
\\begin{block}{短期的な目標}%x
\\begin{itemize}
\\item CCNx の ver8.1 で機能ごとのブロックを作り，ブロックの処理に必要な
クロック数を測定する
\\end{itemize}
\\end{block}

\\begin{block}{中期的な目標}%x
\\begin{itemize}
\\item 現在はルータの CPU がシングルコアの時のみモデル化できているため，
マルチコアに対応させる
\\end{itemize}
\\end{block}
\\end{frame}
\\begin{frame}[label=sec-5-2]{進捗状況}
\\begin{itemize}
\\item 中井さんから，以下のことを引き継ぎしてもらった
\\begin{itemize}
\\item CCNx のソースコード中に RDTSC を埋め込んでクロック数を測定する方法
\\item 実験のネットワークへのアクセス方法と実験用スクリプトの使い方
\\end{itemize}
\\item 3/24 (月) に，実機を使って電力消費の測定を行なう (CCNx は，中井
さんが使っていたのと同じ ver7.1 を使用する)
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-5-3]{今後の予定 (仮)}
\\begin{itemize}
\\item 「 Scalable NDN Forwarding:Concepts, Issues and Principles 」と実
際のソースコードを読んだことで， CCNx の概要が分かってきたと思うた
め，ソースコードを読み進めつつ，ソースコード中のどこでクロックを
測定するべきか考えて行きたいと思っている
\\item 並行して， CCNx の理解を深めるため， CCNx1.0 へのロードマップを読み
進めていきたいと考えている (100 ページ程度あるため 2 〜 3 週間を目安に
考えている)
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-5-4]{Scalable NDN Forwarding:Concepts, Issues and Principles}
\\begin{itemize}
\\item 本論文は， CCNx のデータ構造とオペレーショナルフローについてまとめている
\\item ただし， CCNx の ver4.0 を対象としているため，現在の最新である
ver8.1 とは一部異なる可能性がある
\\begin{itemize}
\\item 次スライドから述べる CCNx のデータ構造は ver4.0 のものであること
に留意する
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-5-5]{CCNx のデータ構造}
\\begin{itemize}
\\item CCNx のデータ構造は NDN と異なっている
\\begin{itemize}
\\item NDN
\\begin{itemize}
\\item CS ・ FIB ・ PIT の 3 つのテーブルを持つ
\\end{itemize}
\\item CCNx
\\begin{itemize}
\\item CS に相当する Content Hash Table (CHT) と Content Skip List
(CSL) を持つ
\\item FIB と PIT に相当する Name Prefix Hash Table (NPHT) を持つ
\\item PIT に存在するすべての Interest (PEs の形) の nonce を保持す
る Propagating Hash Table (PHT) を持つ
\\end{itemize}
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-5-6]{CCNx のデータ構造図}
\\includegraphics[width=.9\\linewidth]{./figure/ccnx_data_structure.pdf}
\\end{frame}
\\begin{frame}[label=sec-5-7]{CCNx における CS の概要}
\\begin{itemize}
\\item Data の格納場所と， Data を指すポインタをエントリに持つテーブルに分けられる
\\begin{itemize}
\\item Data の格納場所
\\begin{itemize}
\\item Content Array (CA)
\\item Straggler Hash Table (SHT)
\\end{itemize}
\\item テーブル
\\begin{itemize}
\\item Content Hash Table (CHT)
\\item Content Skip List (CSL)
\\end{itemize}
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-5-8]{CS における Data の格納}
\\begin{itemize}
\\item Data に番号をつけて， CA か SHT に保存する
\\begin{itemize}
\\item daemon に到着した Data には，ユニークな accession number が割り
当てられる
\\begin{itemize}
\\item accession number は， 1 ずつ増加する
\\end{itemize}
\\item キャッシュされた Data は， Content Array (CA) に保存さ
れ， accession number によってインデックスされる
\\item Data がキャッシュされるごとに CA がサポートする accession
number の範囲が移動する
\\begin{itemize}
\\item サポートするスロット数は固定であるため，スライディングウィン
ドウのようにサポートする場所が移動していく
\\end{itemize}
\\item 古くなり CA のサポートから外れたが，人気のある Data は， SHT に
保存される
\\begin{itemize}
\\item ver8.1 では， SHT らしきものが見つけられなかった (重要ならばもう少し時間
をかけてソースコードを読みたいと思います)
\\end{itemize}
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-5-9]{Content Store のテーブル}
\\begin{itemize}
\\item Content Hash Table (CHT)
\\begin{itemize}
\\item key は Data のフルネーム
\\end{itemize}
\\item Content Skip List (CSL)
\\begin{itemize}
\\item 標準的な skip list
\\item コンテンツ名順の lookup をサポートするために必要
\\begin{itemize}
\\item 詳細は次ページ
\\end{itemize}
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-5-10]{CSL におけるコンテンツ名順の lookup}
\\begin{itemize}
\\item CSL では， Data がコンテンツの名前順に整列されている
\\item CSL での lookup のアルゴリズム挙動は次の通り
\\begin{enumerate}
\\item 右にポインタを辿り検索対象コンテンツ名とノードを比較する．
\\begin{itemize}
\\item コンテンツ名 $<$ ノード 再び 1 へ
\\item コンテツ名 $>$ ノード 元のノードへ戻り，階層を 1 つ下げて再び
1 へ，最下層なら 2 へ
\\item コンテンツ名 = ノード マッチしたので探索終了
\\end{itemize}
\\item 探索するコンテンツが存在しないので探索終了
\\end{enumerate}
\\end{itemize}
\\includegraphics[width=0.9\\linewidth,height=0.5\\textheight]{./figure/cs_skiplist.pdf}
\\end{frame}
\\begin{frame}[label=sec-5-11]{CCNx における FIB と PIT の概要}
\\begin{itemize}
\\item FIB と PIT はともに， Name Prefix Hash Table (NPHT) のエントリ
Name Prefix Entry (NPE) によって管理される
\\begin{itemize}
\\item NPE は Propagating Entries (PEs) と Forwarding Info Entries
(FIEs) にインデックスしている
\\end{itemize}
\\end{itemize}
\\begin{block}{PEs}%x
\\begin{itemize}
\\item エントリ同士は，双方向でリンクされている
\\item メンバ変数
\\begin{itemize}
\\item 元の interest (unsigned int 型なので，おそらくバイナリのまま．
コメントによるとマッチングに使用する)
\\item 転送した interest のメッセージとそのサイズ
\\end{itemize}
\\end{itemize}
\\end{block}

\\begin{block}{FIEs}%x
\\begin{itemize}
\\item NPE 中に存在
\\item メンバ変数
\\begin{itemize}
\\item face の id
\\item expire までの残り時間
\\end{itemize}
\\end{itemize}
\\end{block}
\\end{frame}

\\begin{frame}[label=sec-5-12]{CCNx のオペレーショナルフロー}
\\begin{itemize}
\\item CCNx では， Interest と Data は，異なる関数で処理される
\\begin{itemize}
\\item Interest: process\\_incoming\\_interest
\\item Data: process\\_incoming\\_content
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-5-13]{Interest 処理のオペレーショナルフロー図}
\\includegraphics[width=.9\\linewidth]{./figure/ccnx_interest_flow.pdf}
\\end{frame}
\\begin{frame}[label=sec-5-14]{Interest 処理のオペレーショナルフロー (1)}
\\begin{itemize}
\\item Interest が CCNx daemon に到着した時の処理を順に述べる
\\begin{enumerate}
\\item CCNx daemon は，バイナリをデコードし， name 部とオプション部に
parse
\\item Interest の nonce を key として， PHT で正確な一致検索を行う
\\begin{itemize}
\\item loop している Interest の破棄
\\end{itemize}
\\item Prefix Seek を行う
\\begin{enumerate}
\\item Interest の nameprefix が\\alert{すべて}存在するかを NPHT で
チェックする (Interest が/a/b/0/1 ならば，/a ・/a/b ・/a/b/0 ・
/a/b/0/1 をすべて)
\\item 存在しなければ， NPHT に新たなエントリを作成
\\item 2 の時， fast lookup のため挿入されたエントリは親 (1 コンポ
ネント短いエントリ) へのポインタを張る (Data が daemon に到
着した際に，できるだけ多くの Interest を消費するため． (3)
で詳細を述べる)
\\end{enumerate}
\\end{enumerate}
\\end{itemize}
\\includegraphics[width=0.8\\linewidth,height=0.15\\paperheight]{./figure/npht.pdf}
\\end{frame}
\\begin{frame}[label=sec-5-15]{Interest 処理のオペレーショナルフロー (2)}
\\begin{itemize}
\\item Interest に対応する Data がキャッシュされているか CS をチェック
\\begin{enumerate}
\\item CSL で潜在的にマッチし得るコンテンツを探索
\\begin{itemize}
\\item コンポーネント数の比較
\\item Name 全体の長さの比較
\\item memcmp における Binary の Name 自体の比較
\\end{itemize}
\\item マッチした場合，そのコンテンツを CS から取ってきて，本当に
Interest を満たすものかどうかチェック
\\begin{itemize}
\\item Interest には，特定コンテンツを排除する Exclude や
るため name だけでは不十分であるため
\\end{itemize}
\\end{enumerate}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-5-16]{Interest 処理のオペレーショナルフロー (3)}
\\begin{enumerate}
\\item コンテンツ有: Interest を消費した (Interest Comsuming の処理) 後，
Data を返送し， NPHT と PHT から Interest を除去
\\begin{itemize}
\\item Data が/a/b/0/1 なら，/a/b/0/1 ・/a/b/0 ・/a/b ・/a を探索する
\\begin{itemize}
\\item オプションによっては， Interest の fullname と NPHT のエント
リが完全一致しなくても良い場合があるため
\\item Interest には， MinSuffixComponents と MaxSuffixComponents というオプ
ションが存在し，マッチしてほしいコンポーネントの範囲を指定することができる
\\item 例えば， Interest の fullname が/a/b/0/1 ， MaxSuffixComponents が
3 の時， Data /a/b/0/1 でも Interest の要件を満たしている
きる
\\end{itemize}
\\end{itemize}

\\item コンテンツ無: NPHT で最長一致検索を行う (FIB の処理)
\\begin{enumerate}
\\item Interest の fullname で探索→ 1 つコンポネント長を短くしたもの
で探索．．．．．．をマッチするか， root prefix に到達するまで繰り返す
\\item Interest を転送した後， NPHT に Interest message を含んだエントリ
を追加， PHT に Interest の nonce を追加
\\end{enumerate}
\\end{enumerate}
\\end{frame}
\\begin{frame}[label=sec-5-17]{Data 処理のオペレーショナルフロー図}
\\includegraphics[width=.9\\linewidth]{./figure/ccnx_data_flow.pdf}
\\end{frame}
\\begin{frame}[label=sec-5-18]{Data 処理のオペレーショナルフロー}
\\begin{itemize}
\\item Interest が CCNx daemon に到着した時の処理を順に述べる
\\begin{enumerate}
\\item CCNx daemon は，バイナリをデコードし， parse
\\item CS seek, saving
\\begin{itemize}
\\item CHT での正確なマッチングを行い，キャシュされているかを確認
(key は Data の full name)
\\item Data は， CHT と CSL に挿入され， CS に格納される
\\end{itemize}
\\item Interest の処理と同様の Interest Consuming の処理
\\end{enumerate}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-5-19]{よく分からなかった点}
\\begin{itemize}
\\item CCNx のデータ構造の中に「 ccn\\_forwarding 」と「 ccn\\_forwarding\\_entry 」
の 2 つのデータ構造があった
\\item この 2 つのデータ構造は，互いに関係がない
\\item NPE からリンクが貼られていたのは前者
\\end{itemize}
\\end{frame}
\\section{2014 年 3 月 5 日}
\\label{sec-6}
\\begin{frame}[label=sec-6-1]{}
\\end{frame}
\\begin{frame}[label=sec-6-2]{前回ミーティングのまとめ}
\\begin{itemize}
\\item 「 Scalable NDN Forwarding:Concepts, Issues and Principles 」を読
み， CCNx のデータ構造についてまとめ， CCNx のデータ構造について
の理解を深める
\\end{itemize}
\\begin{block}{短期的な目標}%x
\\begin{itemize}
\\item CCNx の ver8.1 で機能ごとのブロックを作り，ブロックの処理に必要な
クロック数を測定する
\\end{itemize}
\\end{block}

\\begin{block}{長期的な目標}%x
\\begin{itemize}
\\item 現在はルータの CPU がシングルコアの時のみモデル化できているため，
マルチコアに対応させる
\\end{itemize}
\\end{block}
\\end{frame}

\\begin{frame}[label=sec-6-3]{Scalable NDN Forwarding:Concepts, Issues and Principles}
\\begin{itemize}
\\item 本論文は， CCNx のデータ構造とオペレーショナルフローについてまとめている
\\item ただし， CCNx の ver4.0 を対象としているため，現在の最新である
ver8.1 とは一部異なる可能性がある
\\begin{itemize}
\\item 次スライドから述べる CCNx のデータ構造は ver4.0 のものであること
に留意する
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-6-4]{CCNx のデータ構造}
\\begin{itemize}
\\item CCNx のデータ構造は NDN と異なっている
\\begin{itemize}
\\item NDN
\\begin{itemize}
\\item CS ・ FIB ・ PIT の 3 つのテーブルを持つ
\\end{itemize}
\\item CCNx
\\begin{itemize}
\\item CS に相当する Content Hash Table (CHT) と Content Skip List
(CSL) を持つ
\\item FIB と PIT に相当する Name Prefix Hash Table (NPHT) を持つ
\\item PIT に存在するすべての Interest (PEs の形) の nonce を保持す
る Propagating Hash Table (PHT) を持つ
\\end{itemize}
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-6-5]{CCNx のデータ構造図}
\\includegraphics[width=.9\\linewidth]{./figure/ccnx_data_structure.pdf}
\\end{frame}
\\begin{frame}[label=sec-6-6]{CCNx における CS の概要}
\\begin{itemize}
\\item Data の格納場所と， Data を指すポインタをエントリに持つテーブルに分けられる
\\begin{itemize}
\\item Data の格納場所
\\begin{itemize}
\\item Content Array (CA)
\\item Straggler Hash Table (SHT)
\\end{itemize}
\\item テーブル
\\begin{itemize}
\\item Content Hash Table (CHT)
\\item Content Skip List (CSL)
\\end{itemize}
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-6-7]{CS における Data の格納}
\\begin{itemize}
\\item Data に番号をつけて， CA か SHT に保存する
\\begin{itemize}
\\item daemon に到着した Data には，ユニークな accession number が割り
当てられる
\\begin{itemize}
\\item accession number は， 1 ずつ増加する
\\end{itemize}
\\item キャッシュされた Data は， Content Array (CA) に保存さ
れ， accession number によってインデックスされる
\\item Data がキャッシュされるごとに CA がサポートする accession
number の範囲が移動する
\\begin{itemize}
\\item サポートするスロット数は固定であるため，スライディングウィン
ドウのようにサポートする場所が移動していく
\\end{itemize}
\\item 古くなり CA のサポートから外れたが，人気のある Data は， SHT に
保存される
\\begin{itemize}
\\item どうやって Data が人気か判断するのか， CA と同じように accession
number でアクセスするのか分からないため，ソースを読む必要があ
る
\\end{itemize}
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-6-8]{Content Store のテーブル}
\\begin{itemize}
\\item Content Hash Table (CHT)
\\begin{itemize}
\\item key は Data のフルネーム
\\end{itemize}
\\item Content Skip List (CSL)
\\begin{itemize}
\\item 標準的な skip list
\\item コンテンツ名順の lookup をサポートするために必要
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-6-9]{CCNx における FIB と PIT の概要}
\\begin{itemize}
\\item FIB と PIT はともに， Name Prefix Hash Table (NPHT) によって管理
される
\\begin{itemize}
\\item NPHT は Propagating Entries (PEs) と Forwarding Info Entries
(FIEs) にインデックスしている
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-6-10]{CCNx のオペレーショナルフロー}
\\begin{itemize}
\\item CCNx では， Interest と Data は，異なる関数で処理される
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-6-11]{Interest 処理のオペレーショナルフロー図}
\\includegraphics[width=.9\\linewidth]{./figure/ccnx_interest_flow.pdf}
\\end{frame}
\\begin{frame}[label=sec-6-12]{Interest 処理のオペレーショナルフロー (1)}
\\begin{itemize}
\\item Interest が CCNx daemon に到着した時の処理を順に述べる
\\begin{enumerate}
\\item CCNx daemon は，バイナリをデコードし， name 部とオプション部に
parse
\\item Interest の nonce を key として， PHT で正確な一致検索を行う
\\begin{itemize}
\\item loop している Interest の破棄
\\end{itemize}
\\item Prefix Seek を行う
\\begin{enumerate}
\\item Interest の prefix が\\alert{すべて}存在するかを NPHT でチェックする
\\item 存在しなければ， NPHT に新たなエントリを作成
\\item 2 の時， fast lookup のため prefix は親へのポインタを張る
\\end{enumerate}
\\end{enumerate}
\\end{itemize}

\\includegraphics[width=0.8\\linewidth,height=0.15\\paperheight]{./figure/npht.pdf}
\\end{frame}
\\begin{frame}[label=sec-6-13]{Interest 処理のオペレーショナルフロー (2)}
\\begin{enumerate}
\\item Interest に対応する Data がキャッシュされているか CS をチェック
\\begin{enumerate}
\\item CSL で潜在的にマッチし得るコンテンツを探索
\\item マッチした場合，そのコンテンツを CS から取ってきて，本当に
Interest を満たすものかどうかチェック
\\begin{itemize}
\\item Interest には，特定コンテンツを排除する除外フィルタなどがあ
るため name だけでは不十分であるため
\\end{itemize}
\\end{enumerate}
\\end{enumerate}
\\end{frame}

\\begin{frame}[label=sec-6-14]{Interest 処理のオペレーショナルフロー (3)}
\\begin{enumerate}
\\item コンテンツ有: Interest を消費した (Interest Comsuming の処理) 後， Data パケットを返送し， NPHT
と PHT から Interest の name を除去
\\begin{itemize}
\\item Data が/a/b/0/1 なら，\\alert{/a/b/0 ・/a/b ・/a をすべて}探索
する
\\begin{itemize}
\\item できるだけ多くの Interest を消費するため
\\item 例えば， Interest /a/b/0 が，最初の 3 コンポネントでのみのマッチを
必要としている場合，コンテンツ/a/b/0/1 が Interest/a/b/0 を満たす
\\end{itemize}
\\end{itemize}

\\item コンテンツ無: NPHT で最長一致検索を行う (FIB の処理)
\\begin{enumerate}
\\item Interest の fullname で探索→ 1 つコンポネント長を短くしたもの
で探索．．．．．．をマッチするか， root prefix に到達するまで繰り返す
\\item Interest を転送した後， NPHT に Interest message を含んだエントリ
を追加， PHT に Interest の nonce を追加
\\end{enumerate}
\\end{enumerate}
\\end{frame}
\\begin{frame}[label=sec-6-15]{Data 処理のオペレーショナルフロー図}
\\includegraphics[width=.9\\linewidth]{./figure/ccnx_data_flow.pdf}
\\end{frame}
\\begin{frame}[label=sec-6-16]{Data 処理のオペレーショナルフロー}
\\begin{itemize}
\\item Interest が CCNx daemon に到着した時の処理を順に述べる
\\begin{enumerate}
\\item CCNx daemon は，バイナリをデコードし， parse
\\item CS seek, saving
\\begin{itemize}
\\item CHT での正確なマッチングを行い，キャシュされているかを確認
(key は Data の full name)
\\item Data は， CHT と CSL に挿入され， CS に格納される
\\end{itemize}
\\item Interest の処理と同様の Interest Consuming の処理
\\end{enumerate}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-6-17]{所感}
\\begin{itemize}
\\item CCNx のデータ構造について大まかな理解はできたと思われる
\\item 一方で，各テーブルのエントリの構造などの細かい所については触れられ
ていなかったため，ソースコードを読んでいく必要があると感じた
\\end{itemize}
\\end{frame}
% Emacs 24.3.1 (Org mode 8.2.5h)
\\end{document}" #(" (2)" 0 4 (face org-level-2 fontified t)) #("** 前回ミーティングのまとめ (1)
   - 下図の D (ディスパッチャ) と A0 〜 A2 (NDN パケットを処理するプロ
     セス) がパケットを処理するのに要するクロック数を測定する
     - 下図の A0 〜 A2 がパケットを処理するのに要するクロック数は，中井さんの測定し
       た結果から分かる
     - D が処理するのに要するクロック数は，新たに計測する
       - そのために，まずはディスパッチャの設計を考える必要がある

[[./figure/hardware-crop.pdf]]
" 0 1 (face org-level-2 fontified t) 1 3 (face org-level-2 fontified t) 3 19 (face org-level-2 fontified t) 19 20 (fontified t) 20 68 (fontified t) 68 241 (fontified t) 241 242 (fontified t) 242 243 (face org-link font-lock-multiline t mouse-face highlight keymap #3=(keymap (follow-link . mouse-face) (mouse-3 . org-find-file-at-mouse) (mouse-2 . org-open-at-mouse)) invisible org-link org-no-flyspell t htmlize-link #4=(:uri #2="./figure/hardware-crop.pdf") help-echo #1="LINK: ./figure/hardware-crop.pdf" fontified t) 243 244 (face org-link font-lock-multiline t mouse-face highlight keymap #3# invisible org-link org-no-flyspell t rear-nonsticky #6=(mouse-face highlight keymap invisible intangible help-echo org-linked-text htmlize-link) htmlize-link #4# help-echo #1# fontified t) 244 269 (face org-link font-lock-multiline t mouse-face highlight keymap #3# org-no-flyspell t htmlize-link #5=(:uri #2#) help-echo #1# fontified t) 269 270 (face org-link font-lock-multiline t mouse-face highlight keymap #3# org-no-flyspell t rear-nonsticky #6# htmlize-link #5# help-echo #1# fontified t) 270 271 (face org-link font-lock-multiline t mouse-face highlight keymap #3# invisible org-link org-no-flyspell t htmlize-link #4# help-echo #1# fontified t) 271 272 (face org-link font-lock-multiline t mouse-face highlight keymap #3# invisible org-link org-no-flyspell t rear-nonsticky #6# htmlize-link #4# help-echo #1# fontified t) 272 273 (rear-nonsticky t fontified t)) "% Created 2014-04-01 Tue 15:57
\\documentclass[dvipdfmx,11pt]{beamer}
\\usepackage{url}
\\usepackage{pxjahyper}
\\usetheme{Berlin}
\\setbeamertemplate{navigation symbols}{}
\\beamertemplatetextbibitems
\\setbeamertemplate{footline}[frame number]
\\setbeamertemplate{headline}{}


\\institute[]{大阪大学大学院情報科学研究科\\\\
            情報ネットワーク学専攻\\\\
            情報流通プラットフォーム講座 長谷川研究室 M2}
\\usetheme{default}
\\author{大杉 海斗}
\\date{\\today}
\\title{M2 Meeting}
\\hypersetup{
  pdfkeywords={},
  pdfsubject={},
  pdfcreator={Emacs 24.3.1 (Org mode 8.2.5h)}}
\\begin{document}

\\maketitle
\\section{2014 年 4 月 9 日}
\\label{sec-1}
\\begin{frame}[label=sec-1-1]{研究目標}
\\begin{block}{短期的な目標 (5 月)}%x
\\begin{itemize}
\\item 中井さんが提案した NDN ルータの電力消費モデルをマルチコア CPU に対応させる
\\end{itemize}
\\end{block}

\\begin{block}{それ以降の目標}%x
\\begin{itemize}
\\item CCNx の最新 ver に対応させる
\\item FIB ・ PIT ・ CS のテーブルサイズの大きさが，電力消費にどのような
影響を与えるかを調査する
\\begin{itemize}
\\item 該当エントリの lookup に要する時間が長くなるため，テーブルサイ
ズが大きいほうが電力消費は大きくなると思われる
\\end{itemize}
\\end{itemize}
\\end{block}
\\end{frame}

\\begin{frame}[label=sec-1-2]{前回ミーティングのまとめ (1)}
\\begin{itemize}
\\item 下図の D (ディスパッチャ) と A0 〜 A2 (NDN パケットを処理するプロ
セス) がパケットを処理するのに要するクロック数を測定する
\\begin{itemize}
\\item 下図の A0 〜 A2 がパケットを処理するのに要するクロック数は，中井さんの測定し
た結果から分かる
\\item D が処理するのに要するクロック数は，新たに計測する
\\begin{itemize}
\\item そのために，まずはディスパッチャの設計を考える必要がある
\\end{itemize}
\\end{itemize}
\\end{itemize}

\\includegraphics[width=.9\\linewidth]{./figure/hardware-crop.pdf}
\\end{frame}
\\begin{frame}[label=sec-1-3]{前回ミーティングのまとめ (2)}
\\begin{itemize}
\\item フォワーディングエンジンの動作は，基本的に CCNx に従う
\\begin{itemize}
\\item Cisco の NDN ルータのソフトウェアではオプションの処理ができず，
現実的に利用するのは難しいと判断したため
\\end{itemize}
\\item CCNx では， FIB と PIT を NPHT (Name Prefix Hash Table) で管理して
いるため， PIT と CS を排他的に割り当てするためには， NPHT ( FIB ・
PIT) と CS をパーティショニングする必要がある
\\end{itemize}
\\end{frame}

\\section{2014 年 4 月 1 日}
\\label{sec-2}
\\begin{frame}[label=sec-2-1]{研究目標}
\\begin{block}{短期的な目標 (5 月)}%x
\\begin{itemize}
\\item 中井さんが提案した NDN ルータの電力消費モデルをマルチコア CPU に対応させる
\\end{itemize}
\\end{block}

\\begin{block}{それ以降の目標}%x
\\begin{itemize}
\\item CCNx の最新 ver に対応させる
\\item FIB ・ PIT ・ CS のテーブルサイズの大きさが，電力消費にどのような
影響を与えるかを調査する
\\begin{itemize}
\\item 該当エントリの lookup に要する時間が長くなるため，テーブルサイ
ズが大きいほうが電力消費は大きくなると思われる
\\end{itemize}
\\end{itemize}
\\end{block}
\\end{frame}
\\begin{frame}[label=sec-2-2]{前回ミーティングのまとめ (1)}
\\begin{itemize}
\\item 下図の D (ディスパッチャ) と A0 〜 A2 (NDN パケットを処理するプロ
セス) がパケットを処理するのに要するクロック数を測定する
\\begin{itemize}
\\item 下図の A0 〜 A2 がパケットを処理するのに要するクロック数は，中井さんの測定し
た結果から分かる
\\item D が処理するのに要するクロック数は，新たに計測する
\\begin{itemize}
\\item そのために，まずはディスパッチャの設計を考える必要がある
\\end{itemize}
\\end{itemize}
\\end{itemize}

\\includegraphics[width=.9\\linewidth]{./figure/hardware-crop.pdf}
\\end{frame}
\\begin{frame}[label=sec-2-3]{前回ミーティングのまとめ (2)}
\\begin{itemize}
\\item フォワーディングエンジンの動作は，基本的に CCNx に従う
\\begin{itemize}
\\item Cisco の NDN ルータのソフトウェアではオプションの処理ができず，
現実的に利用するのは難しいと判断したため
\\end{itemize}
\\item CCNx では， FIB と PIT を NPHT (Name Prefix Hash Table) で管理して
いるため， PIT と CS を排他的に割り当てするためには， NPHT ( FIB ・
PIT) と CS をパーティショニングする必要がある
\\end{itemize}

\\begin{block}{参考: Cisco の設計}%x
\\begin{itemize}
\\item Cisco は， PIT と CS を同一テーブルで管理し，それぞれの CPU コアへ
排他的に割り当て， FIB は CPU コア間で共有している
\\end{itemize}
\\end{block}
\\end{frame}
\\begin{frame}[label=sec-2-4]{進捗状況}
\\begin{itemize}
\\item 各 CPU コアにパケット処理を割り当てするディスパッチャを設計した
\\item ポスターの原稿を修正した
\\begin{itemize}
\\item CCN の説明を追加した
\\item 武政君の研究内容 (CCN ルータのキャッシュヒット率の導出) を追加した
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-2-5]{ディスパッチャの要件}
\\begin{itemize}
\\item できるだけ各 CPU の使用率を均等にする
\\item パケット処理は，そのパケットの親の処理が割り当てられたのと同じ
CPU に割り当てされなければならない
\\begin{itemize}
\\item FIB エントリの最長一致検索によるパケットフォワーディングのため，
各エントリは親エントリへのリンクを張っているから
\\item パケット /a/b/0 ・/a/b ・/a は，必ず同じ CPU に割り当てされる必要がある
\\end{itemize}
\\end{itemize}

\\begin{block}{参考: Cisco の設計}%x
\\begin{itemize}
\\item CPU コア間で FIB を共有しているため，パケットの full-name をハッ
シュ化し，そのハッシュ値で CPU コアへと振り分けしている
\\item full-name の偏りによっては，特定 CPU コアに処理が集中する可能性が
ある
\\end{itemize}
\\end{block}
\\end{frame}
\\begin{frame}[label=sec-2-6]{ディスパッチャの設計}
\\begin{itemize}
\\item 2 種類の設計を考えた
\\begin{itemize}
\\item 方式 1: 現在の各 CPU コアの負荷に関係なく，入力パケットの Root
Prefix\\footnote{Root Prefix: パケットの名前を tree に見立てた時の根に当たる Prefix (例: /a/b/0 ならば/a ，/b/c/d ならば/b)} のハッシュ値によってパケット処理を割り当てする CPU コアを
決定する
\\begin{itemize}
\\item (ハッシュ値 mod n) = 1 ならばコア 1 ， = 2 ならばコア 2\\ldots{}\\ldots{}の
ようなイメージ
\\item 処理が簡単
\\item 特定の CPU コアに負荷が集中する可能性がある
\\end{itemize}
\\item 方式 2: 現在の各 CPU コアの負荷に応じて，パケット処理を割り当て
する CPU コアを変更する
\\begin{itemize}
\\item 詳細は後述
\\item 処理が複雑
\\item 特定の CPU コアへの負荷の集中を防ぐことができる
\\end{itemize}
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-2-7]{方式 2 の詳細 (1)}
\\begin{itemize}
\\item パケットの処理をどの CPU コアへ割り当てするかの選択が，パケットの
Root Prefix にのみ依存することに着目
\\begin{itemize}
\\item Root Prefix と割り当てする CPU コアの対応をテーブルで管理する
\\begin{itemize}
\\item Root Prefix ならば，それほど数がなさそう
\\end{itemize}
\\end{itemize}
\\item Key は Root Prefix のハッシュ値
\\item テーブルにない Root Prefix を持つパケットが到着した時は， CPU 負荷
の低いコアへ割り当てし，その対応をテーブルに追加
\\end{itemize}

\\includegraphics[width=.9\\linewidth]{./figure/dispatcher_table-crop.pdf}
\\end{frame}
\\begin{frame}[label=sec-2-8]{方式 2 の詳細 (2)}
\\begin{itemize}
\\item いつまでも同じコアへとパケットを割り当てをしていては，この方式の意
味がないため，一定時間 (Time to Live で指定) 経過後にテーブル
からエントリを削除
\\begin{itemize}
\\item Time to Live はその Root Prefix を持つすべてのパケットが対応する
FIB ・ PIT ・ CS の エントリが expire するまでの時間の最大値と同
じにする必要がある
\\begin{itemize}
\\item 該当するエントリがある FIB ・ PIT ・ CS を持つ App Process へとパ
ケットの処理を割り当てするため
\\end{itemize}
\\end{itemize}
\\item App Process はパケット処理後に Time to Live にセットする値を返す
\\end{itemize}

\\includegraphics[width=.9\\linewidth]{./figure/dispatcher_table-crop.pdf}
\\end{frame}
\\begin{frame}[label=sec-2-9]{2 つの方式に対する考え}
\\begin{itemize}
\\item 方式 2 の方が現実的であると思われる
\\begin{itemize}
\\item 方式 1 では， 各 CPU コアの負荷がコンテンツの名前空間に依存する
\\begin{itemize}
\\item コンテンツの名前は，ルータのベンダが決められるものではないため，特定の CPU コアに処理が集中すると予想される
\\end{itemize}
\\end{itemize}
\\item 方式 2 の別案として，全 CPU コアに毎回 Root Prefix で lookup を行う方法もある
\\begin{itemize}
\\item テーブルを保持する必要はないが，オーバーヘッドが大きい
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-2-10]{パケット (Interest/Data の両方) 到着時のプロセス}
\\begin{enumerate}
\\item パケットの Root Prefix より Hash 値を計算し，その値によりディス
パッチャの持つテーブルを参照
\\item HIT 時: ディスパッチャは， App Process へとパケット処理を割り当て
し， App Process から Time to Live にセットする値 (エントリの残り
時間) を受け取る
\\item MISS 時: CPU 使用率の低いコアへとパケット処理を割り当てし，テーブ
ルにエントリを作成 (Time to Live は App Process がパケット処理時
に返却)
\\end{enumerate}
\\end{frame}

\\begin{frame}[label=sec-2-11]{}
\\end{frame}
\\section{2014 年 3 月 25 日}
\\label{sec-3}
\\begin{frame}[label=sec-3-1]{前回ミーティングのまとめ}
\\begin{itemize}
\\item マルチコア CPU を搭載した NDN ルータ (ソフトウェアベース) の電
力消費を測定するために必要なハードウェア・ソフトウェア構成を考え
る
\\begin{itemize}
\\item ハードウェアは，専用のルータではなく，一般的な PC を想定している
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-3-2]{研究目標}
\\begin{block}{短期的な目標 (5 月)}%x
\\begin{itemize}
\\item 中井さんが提案した NDN ルータの電力消費モデルをマルチコア CPU に対応させる
\\end{itemize}
\\end{block}

\\begin{block}{それ以降の目標}%x
\\begin{itemize}
\\item CCNx の最新 ver に対応させる
\\item FIB ・ PIT ・ CS のテーブルサイズの大きさが，電力消費にどのような
影響を与えるかを調査する
\\begin{itemize}
\\item 該当エントリの lookup に要する時間が長くなるため，テーブルサイ
ズが大きいほうが電力消費は大きくなると思われる
\\end{itemize}
\\end{itemize}
\\end{block}
\\end{frame}
\\begin{frame}[label=sec-3-3]{進捗状況}
\\begin{itemize}
\\item マルチコア CPU を搭載した NDN ルータ (ソフトウェアベース) の電力消
費を測定するために必要なハードウェア・ソフトウェア構成を考えた
\\item マルチコア CPU 環境におけるクロック数の測定方法を検討した
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-3-4]{現在考えられる課題一覧}
\\begin{itemize}
\\item マルチスレッドに対応した NDN ソフトウェアの作成
\\begin{itemize}
\\item 特定 CPU コアへのスレッドの割り当て (おそらく下の API を用いることで可能)
\\begin{itemize}
\\item sched\\_get\\_affinity ()
\\item sched\\_set\\_affinity ()
\\item \\url{http://linuxjm.sourceforge.jp/html/LDP_man-pages/man2/sched_setaffinity.2.html}
\\end{itemize}
\\end{itemize}
\\item CPU がマルチコアの時に電力消費量を推定できるモデルの提案
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-3-5]{本日のミーティングで議論したいこと}
\\begin{itemize}
\\item NDN ルータのソフトウェア構成およびハードウェア構成に問題がないか
\\item 今後行っていく作業の優先順位付け
\\item 研究室紹介に使うポスターの内容
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-3-6]{NDN ルータのハードウェア構成}
\\begin{itemize}
\\item CPU: Intel Xeon E3-1220 (3.1GHz x 4 コア)
\\begin{itemize}
\\item ハイパースレッディングとターボブーストはとりあえず無効化する
\\end{itemize}
\\item Memory: DDR3 16GB,1600MHz
\\begin{itemize}
\\item FIB ・ PIT ・ CS のテーブルサイズについて今は考慮しないため，
Memory サイズはそれほど考慮しない
\\end{itemize}
\\item HDD: Western Digital 2TB SATA 3.5 inch \"WD2000FYYX\"
\\begin{itemize}
\\item Memory と同様であまり考慮しない
\\end{itemize}
\\item NIC: Intel 10-Gigabit Ethernet x 2
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-3-7]{NDN パケットフロー}
\\begin{itemize}
\\item 4 コアなので D と A0 〜 3 にそれぞれ 1 コアずつ割り当てる
\\end{itemize}
\\includegraphics[width=.9\\linewidth]{./figure/hardware-crop.pdf}
\\end{frame}

\\begin{frame}[label=sec-3-8]{NDN ルータのソフトウェア構成の概要}
\\begin{itemize}
\\item ソフトウェアの動作は，基本的に CCNx に従う
\\begin{itemize}
\\item Cisco の NDN ルータのソフトウェアではオプションの処理ができず，
現実的に利用するのは難しいと判断したため
\\end{itemize}
\\item 一方で， PIT と CS に関しては，複数の CPU が同一エントリへアクセス
した時の排他制御によるパフォーマンスの低下が大きいと予想されるため，
PIT と CS はパーティショニングを行う
\\begin{itemize}
\\item マルチコアへのスレッドの割り当てなどは Cisco のデモを参考にする
\\end{itemize}
\\item ソフトウェアでは次のことを行う
\\begin{itemize}
\\item NDN パケットのフォワーディング処理
\\item CPU コアへのスレッドの割り当て (ディスパッチ処理)
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-3-9]{NDN ルータのソフトウェア}
\\begin{itemize}
\\item パケットの full-name のハッシュ値によって，パケットの処理を各 CPU コ
アに振り分ける
\\begin{itemize}
\\item NPHT (FIB ・ PIT) と CS を 3 つにパーティショニングする
\\begin{itemize}
\\item NPHT は， bucket が 6 つだとすると， 0 ・ 1 はテーブル 1 とし
てコア 1 ， 2 ・ 3 はテーブル 2 としてコア 2 ， 4 ・ 5 はテー
ブル 3 としてコア 3 というように割り当てする
\\item FIB までパーティショニングされてしまい， parent にリンクを貼
ることによる fast lookup が使えないという問題がある
\\end{itemize}
\\end{itemize}
\\item PIT (CS) の lookup 処理および insert 処理の前に，処理対象のパケッ
トの full-name をハッシュ化
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-3-10]{}
\\includegraphics[width=.9\\linewidth]{./figure/CCN_Algorithm_detail-crop.pdf}
\\end{frame}
\\begin{frame}[label=sec-3-11]{Interest パケットがデーモンに到着した時のシーケンス}
\\begin{enumerate}
\\item パケットを name 部とオプション部に parse
\\item duplication check (重複検知)
\\item パケットの name 部からハッシュ値を計算， Prefix Seek の処理以降を
スレッドにし， ハッシュ値に応じた CPU コアに割り当て
\\end{enumerate}
\\end{frame}
\\begin{frame}[label=sec-3-12]{マルチコア CPU 環境におけるクロック数の測定方法}
\\begin{itemize}
\\item おそらく中井さんが用いた RDTSC 命令を用いることで，マルチコア CPU で
もクロック数の測定が可能である
\\begin{itemize}
\\item タイムスタンプカウンタ (TSC) が， Invariant TSC ならばマルチコ
ア環境でも正確にクロック数を測定可能である
\\begin{itemize}
\\item \\url{http://www.02.246.ne.jp/~torutk/cxx/clock/cpucounter.html}
\\end{itemize}
\\item 本実験で使う予定の Intel Xeon E3-1220 は Invariant TSC であることを確認した
\\end{itemize}
\\item さらに， Turbo boost でクロック数が変化した場合でも正確にクロック
を測定できる
\\item 一方で，マルチ CPU 環境ではクロック測定が困難であると予想される
\\begin{itemize}
\\item クロック数をリセットする信号がプロセッサ単位でしか送信できない
ため
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-3-13]{}
\\end{frame}
\\section{2014 年 3 月 17 日}
\\label{sec-4}
\\begin{frame}[label=sec-4-1]{前回ミーティングのまとめ}
\\begin{itemize}
\\item 中井さんがクロック数を測定した PC (CPU:Intel Xeon) で，
10Gigabit-Ethernet カードが使えるかどうかを確認する
\\item 「 named data networking on a router forwarding at 20 gbps and
beyond 」を参考に， 20Gb や 40Gb の転送速度を出せるソフトウェアルー
タを作る時に，必要となるハードウェアの構成を考える
\\item CCNx のデータ構造とオペレーショナルフローについてまとめた資料の誤
りを修正する
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-4-2]{研究目標}
\\begin{block}{短期的な目標}%x
\\begin{itemize}
\\item CCNx の ver8.1 で機能ごとのブロックを作り，ブロックの処理に必要な
クロック数を測定する
\\end{itemize}
\\end{block}

\\begin{block}{中期的な目標 (5 月)}%x
\\begin{itemize}
\\item 現在，ルータのモデル化は， CPU がシングルコアの時のみできているた
め，モデルをマルチコア or マルチ CPU に対応させる
\\end{itemize}
\\end{block}
\\end{frame}

\\begin{frame}[label=sec-4-3]{目標達成に向けてのアプローチ}
\\begin{enumerate}
\\item 中井さんの資料および CCNx のソースコードを読み， CCNx ver8.1 の処理をブロッ
クに分割し，それぞれのブロックの処理に必要なクロック数を測定する
(最新 ver に拘らないならば，中井さんが実験を行った ver7.2 を使えばよ
 いため，このプロセスは飛ばすことができる)
\\item 1.で計測されたクロック数を基に， CCNx の挙動を模倣するプログラムを
作成する
\\begin{itemize}
\\item CCNx はマルチスレッドに対応していない (?) ため
\\item CCNx における各ブロックの処理にかかるクロック数だけ， dummy の処
理を行わせる
\\item NDN パケットの送受信するタイミングで， UDP パケットを送受信す
る
\\end{itemize}
\\item 2.で作成したプログラムを動作させた PC の電力消費を測定する
\\end{enumerate}
\\end{frame}
\\begin{frame}[label=sec-4-4]{進捗状況}
\\begin{itemize}
\\item 中井さんがクロック数を測定した PC (CPU:Intel Xeon) で，
10Gigabit-Ethernet カードが使えることを確認した
\\begin{itemize}
\\item 他の PC とケーブルで繋ぎ， ping が通ることを確認
\\item 当該 PC の 10Gigabit-Ethernet カードを接続するスロット数 (PCI-Express x8)
は 1 つで，カードのインターフェース数は 2 つのため，最大で
20Gbps までしか測定できない
\\end{itemize}
\\item 「 named data networking on a router forwarding at
20 Gbps and beyond 」を読み必要なハードウェア構成について考えた
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-4-5]{議論したいこと}
\\begin{itemize}
\\item 今回ハードウェアの構成を考えたが， CCNx の動作で 20Gbps を達成するのは困難である
と予想された
\\item したがって，何にフォーカスを当て (コントリビューションは何か) ，
何を優先すべきかを議論したいと考えている
\\begin{itemize}
\\item 中井さんの提案したモデルを， CCNx の最新版に対応させること
\\item 中井さんの提案したモデルを，マルチコア or マルチ CPU に対応させること
\\item 現実的なアクセスルータを考慮して， 20Gbps や 40Gbps のスループットを達成できるハードウェアと，ソフ
トウェアを調査し，その電力消費量を測定すること
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-4-6]{}
\\begin{itemize}
\\item 次ページより，「 named data networking on a router forwarding at
20 Gbps and beyond 」の内容をまとめる
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-4-7]{概要}
\\begin{itemize}
\\item Cisco ASR9000 上の Linux で NDN フォワーディングエンジンを動作さ
せ，そのパフォーマンスを測定している
\\item NDN フォワーディングエンジンは CCNx ではなく， CS ・ FIB ・ PIT のデータ構造も異なっ
ている
\\item シミュレーションの結果， Interest および Data のフォワーディング
スループットが， 20Gbps を超えることを示している
\\begin{itemize}
\\item シミュレーションでは，実際には NIC を通したパケットの送受信を行っておらず，
ファイルからパケットを読み込むことで擬似的なフォワーディング処理
を行っている
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-4-8]{Cisco の NDN ソフトウェアルータのハードウェア構成}
\\begin{itemize}
\\item モデル名: Cisco ASR9000
\\item CPU: Intel Xeon (Westmeie-EP) 2.0GHz 6 コア (Hyper-threading 有) * 2
\\item LAN: Intel Niantic 10Gigabit Ethernet  * 4
\\item Storage: 3.2TB SSD (NDN の Cache Storage として使用)
\\item 64bit Linux 上のソフトウェアでパケットフォワーディングを行ってい
る
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-4-9]{NDN フォワーディングエンジン}
\\begin{itemize}
\\item CCNx とはデータ構造や look up の方法が大きく異なる
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-4-10]{FIB}
\\begin{itemize}
\\item FIB look up の方法が CCNx と異なる (あまり関係なさそうなので割愛)
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-4-11]{CS ・ PIT}
\\begin{itemize}
\\item CS と PIT の管理は 1 つのハッシュテーブルで行い， look up は同時に
行う
\\begin{itemize}
\\item どちらも full-name を key とするため
\\item エントリが CS のものか PIT のものかは 1bit の flag で判断する
\\end{itemize}
\\item PIT (CS/PIT) を CPU の各コア (thread) に分割する
\\begin{itemize}
\\item 複数のコアで PIT を共有するとパフォーマンスが落ちるため
\\item Interest および Data の full-name のハッシュで PIT を CPU コア
(thread) に振り分け
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-4-12]{NDN パケットのフロー}
\\begin{itemize}
\\item App process (A0 〜 A7) で， NDN フォワーディング処理をすべて行う
(CS/PIT look up ， FIB look up)
\\end{itemize}

\\includegraphics[width=0.8\\linewidth,height=0.6\\textheight]{./figure/NDN_packet_flow.pdf}
\\end{frame}
\\begin{frame}[label=sec-4-13]{シミュレーション結果}
\\begin{itemize}
\\item 16 個の IRCache URL のトレースから 1300 万 Interest を作成し，シミュレー
ションを行っている
\\item 異なる CPU コア上で動作させるスレッド数の増加に伴いパフォーマンスは向上している
\\item FIB と PIT のサイズはパフォーマンスにほとんど影響を与えていない
\\begin{itemize}
\\item PIT/CS サイズが向上するとパフォーマンスが低下していることから，
PIT/CS look up でほとんどヒットせず，エントリの探索に時間がかかっ
ただけになっているからではないかと思われる
\\end{itemize}
\\end{itemize}
\\includegraphics[width=0.8\\linewidth,height=0.4\\textheight]{./figure/performance_of_NDN.pdf}
\\end{frame}
\\begin{frame}[label=sec-4-14]{20Gbps を達成する時に必要な CPU}
\\begin{itemize}
\\item 29.78G (clocks/s) を達成できるもの
\\begin{itemize}
\\item 1 秒間に処理するパケット数を算出 (パケットサイズ 2KB は， Interest と Data が同
数であると仮定し，標準チャンクサイズ 4KB を 2 で割って算出
(Interest のサイズは小さいので無視))
\\begin{itemize}
\\item 20Gbps / (2K*8) = 1.25M (packet/s)
\\end{itemize}
\\item Interest と Data のペアの処理にかかる合計クロック数 48787 をかけ
て 2 で割る (こちらも Interest と Data が同数であると仮定． CS
HIT0\\%のとき．中井さんの論文から算出)
\\begin{itemize}
\\item 1.25M * 48784 / 2  = 30491.88 M (clocks/s)
= 29.78 G (clocks/s)
\\end{itemize}
\\end{itemize}
\\item 上の計算仮定には， XML の処理が入っていない．また，パケットサイズ
を 2KB としているが， Cisco は 500B としている．したがって，上記の
結果は甘く見積もっており， CCNx の挙動をそのまま模倣すると CPU の処
理が間に合わないと予想される．
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-4-15]{20Gbps を達成する時に必要な主記憶}
\\begin{itemize}
\\item Cisco のデモから， FIB および PIT のサイズはあまりスループットに影響し
ていないため， 1Gbyte もあれば十分ではないかと思われる
\\item 一方で， FIB ・ PIT の fast look up は時間のかかる処理であるため，
主記憶の速度は重要である
\\begin{itemize}
\\item 十分考えられていない
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-4-16]{20Gbps を達成する時に必要なネットワークインターフェース}
\\begin{itemize}
\\item 10Gigabit-Ethernet * 4
\\begin{itemize}
\\item Cisco と同様
\\item 十分考えられていない
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-4-17]{}
\\end{frame}
\\section{2014 年 3 月 12 日}
\\label{sec-5}
\\begin{frame}[label=sec-5-1]{前回ミーティングのまとめ}
\\begin{itemize}
\\item 「 Scalable NDN Forwarding:Concepts, Issues and Principles 」を読
み， CCNx のデータ構造についてまとめたが，説明不足な部分があったた
め，コメントに基づいて更新を行なう
\\item 今後どのように研究を進めていくかを本日のミーティングで検討する
\\end{itemize}
\\begin{block}{短期的な目標}%x
\\begin{itemize}
\\item CCNx の ver8.1 で機能ごとのブロックを作り，ブロックの処理に必要な
クロック数を測定する
\\end{itemize}
\\end{block}

\\begin{block}{中期的な目標}%x
\\begin{itemize}
\\item 現在はルータの CPU がシングルコアの時のみモデル化できているため，
マルチコアに対応させる
\\end{itemize}
\\end{block}
\\end{frame}
\\begin{frame}[label=sec-5-2]{進捗状況}
\\begin{itemize}
\\item 中井さんから，以下のことを引き継ぎしてもらった
\\begin{itemize}
\\item CCNx のソースコード中に RDTSC を埋め込んでクロック数を測定する方法
\\item 実験のネットワークへのアクセス方法と実験用スクリプトの使い方
\\end{itemize}
\\item 3/24 (月) に，実機を使って電力消費の測定を行なう (CCNx は，中井
さんが使っていたのと同じ ver7.1 を使用する)
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-5-3]{今後の予定 (仮)}
\\begin{itemize}
\\item 「 Scalable NDN Forwarding:Concepts, Issues and Principles 」と実
際のソースコードを読んだことで， CCNx の概要が分かってきたと思うた
め，ソースコードを読み進めつつ，ソースコード中のどこでクロックを
測定するべきか考えて行きたいと思っている
\\item 並行して， CCNx の理解を深めるため， CCNx1.0 へのロードマップを読み
進めていきたいと考えている (100 ページ程度あるため 2 〜 3 週間を目安に
考えている)
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-5-4]{Scalable NDN Forwarding:Concepts, Issues and Principles}
\\begin{itemize}
\\item 本論文は， CCNx のデータ構造とオペレーショナルフローについてまとめている
\\item ただし， CCNx の ver4.0 を対象としているため，現在の最新である
ver8.1 とは一部異なる可能性がある
\\begin{itemize}
\\item 次スライドから述べる CCNx のデータ構造は ver4.0 のものであること
に留意する
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-5-5]{CCNx のデータ構造}
\\begin{itemize}
\\item CCNx のデータ構造は NDN と異なっている
\\begin{itemize}
\\item NDN
\\begin{itemize}
\\item CS ・ FIB ・ PIT の 3 つのテーブルを持つ
\\end{itemize}
\\item CCNx
\\begin{itemize}
\\item CS に相当する Content Hash Table (CHT) と Content Skip List
(CSL) を持つ
\\item FIB と PIT に相当する Name Prefix Hash Table (NPHT) を持つ
\\item PIT に存在するすべての Interest (PEs の形) の nonce を保持す
る Propagating Hash Table (PHT) を持つ
\\end{itemize}
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-5-6]{CCNx のデータ構造図}
\\includegraphics[width=.9\\linewidth]{./figure/ccnx_data_structure.pdf}
\\end{frame}
\\begin{frame}[label=sec-5-7]{CCNx における CS の概要}
\\begin{itemize}
\\item Data の格納場所と， Data を指すポインタをエントリに持つテーブルに分けられる
\\begin{itemize}
\\item Data の格納場所
\\begin{itemize}
\\item Content Array (CA)
\\item Straggler Hash Table (SHT)
\\end{itemize}
\\item テーブル
\\begin{itemize}
\\item Content Hash Table (CHT)
\\item Content Skip List (CSL)
\\end{itemize}
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-5-8]{CS における Data の格納}
\\begin{itemize}
\\item Data に番号をつけて， CA か SHT に保存する
\\begin{itemize}
\\item daemon に到着した Data には，ユニークな accession number が割り
当てられる
\\begin{itemize}
\\item accession number は， 1 ずつ増加する
\\end{itemize}
\\item キャッシュされた Data は， Content Array (CA) に保存さ
れ， accession number によってインデックスされる
\\item Data がキャッシュされるごとに CA がサポートする accession
number の範囲が移動する
\\begin{itemize}
\\item サポートするスロット数は固定であるため，スライディングウィン
ドウのようにサポートする場所が移動していく
\\end{itemize}
\\item 古くなり CA のサポートから外れたが，人気のある Data は， SHT に
保存される
\\begin{itemize}
\\item ver8.1 では， SHT らしきものが見つけられなかった (重要ならばもう少し時間
をかけてソースコードを読みたいと思います)
\\end{itemize}
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-5-9]{Content Store のテーブル}
\\begin{itemize}
\\item Content Hash Table (CHT)
\\begin{itemize}
\\item key は Data のフルネーム
\\end{itemize}
\\item Content Skip List (CSL)
\\begin{itemize}
\\item 標準的な skip list
\\item コンテンツ名順の lookup をサポートするために必要
\\begin{itemize}
\\item 詳細は次ページ
\\end{itemize}
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-5-10]{CSL におけるコンテンツ名順の lookup}
\\begin{itemize}
\\item CSL では， Data がコンテンツの名前順に整列されている
\\item CSL での lookup のアルゴリズム挙動は次の通り
\\begin{enumerate}
\\item 右にポインタを辿り検索対象コンテンツ名とノードを比較する．
\\begin{itemize}
\\item コンテンツ名 $<$ ノード 再び 1 へ
\\item コンテツ名 $>$ ノード 元のノードへ戻り，階層を 1 つ下げて再び
1 へ，最下層なら 2 へ
\\item コンテンツ名 = ノード マッチしたので探索終了
\\end{itemize}
\\item 探索するコンテンツが存在しないので探索終了
\\end{enumerate}
\\end{itemize}
\\includegraphics[width=0.9\\linewidth,height=0.5\\textheight]{./figure/cs_skiplist.pdf}
\\end{frame}
\\begin{frame}[label=sec-5-11]{CCNx における FIB と PIT の概要}
\\begin{itemize}
\\item FIB と PIT はともに， Name Prefix Hash Table (NPHT) のエントリ
Name Prefix Entry (NPE) によって管理される
\\begin{itemize}
\\item NPE は Propagating Entries (PEs) と Forwarding Info Entries
(FIEs) にインデックスしている
\\end{itemize}
\\end{itemize}
\\begin{block}{PEs}%x
\\begin{itemize}
\\item エントリ同士は，双方向でリンクされている
\\item メンバ変数
\\begin{itemize}
\\item 元の interest (unsigned int 型なので，おそらくバイナリのまま．
コメントによるとマッチングに使用する)
\\item 転送した interest のメッセージとそのサイズ
\\end{itemize}
\\end{itemize}
\\end{block}

\\begin{block}{FIEs}%x
\\begin{itemize}
\\item NPE 中に存在
\\item メンバ変数
\\begin{itemize}
\\item face の id
\\item expire までの残り時間
\\end{itemize}
\\end{itemize}
\\end{block}
\\end{frame}

\\begin{frame}[label=sec-5-12]{CCNx のオペレーショナルフロー}
\\begin{itemize}
\\item CCNx では， Interest と Data は，異なる関数で処理される
\\begin{itemize}
\\item Interest: process\\_incoming\\_interest
\\item Data: process\\_incoming\\_content
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-5-13]{Interest 処理のオペレーショナルフロー図}
\\includegraphics[width=.9\\linewidth]{./figure/ccnx_interest_flow.pdf}
\\end{frame}
\\begin{frame}[label=sec-5-14]{Interest 処理のオペレーショナルフロー (1)}
\\begin{itemize}
\\item Interest が CCNx daemon に到着した時の処理を順に述べる
\\begin{enumerate}
\\item CCNx daemon は，バイナリをデコードし， name 部とオプション部に
parse
\\item Interest の nonce を key として， PHT で正確な一致検索を行う
\\begin{itemize}
\\item loop している Interest の破棄
\\end{itemize}
\\item Prefix Seek を行う
\\begin{enumerate}
\\item Interest の nameprefix が\\alert{すべて}存在するかを NPHT で
チェックする (Interest が/a/b/0/1 ならば，/a ・/a/b ・/a/b/0 ・
/a/b/0/1 をすべて)
\\item 存在しなければ， NPHT に新たなエントリを作成
\\item 2 の時， fast lookup のため挿入されたエントリは親 (1 コンポ
ネント短いエントリ) へのポインタを張る (Data が daemon に到
着した際に，できるだけ多くの Interest を消費するため． (3)
で詳細を述べる)
\\end{enumerate}
\\end{enumerate}
\\end{itemize}
\\includegraphics[width=0.8\\linewidth,height=0.15\\paperheight]{./figure/npht.pdf}
\\end{frame}
\\begin{frame}[label=sec-5-15]{Interest 処理のオペレーショナルフロー (2)}
\\begin{itemize}
\\item Interest に対応する Data がキャッシュされているか CS をチェック
\\begin{enumerate}
\\item CSL で潜在的にマッチし得るコンテンツを探索
\\begin{itemize}
\\item コンポーネント数の比較
\\item Name 全体の長さの比較
\\item memcmp における Binary の Name 自体の比較
\\end{itemize}
\\item マッチした場合，そのコンテンツを CS から取ってきて，本当に
Interest を満たすものかどうかチェック
\\begin{itemize}
\\item Interest には，特定コンテンツを排除する Exclude や
るため name だけでは不十分であるため
\\end{itemize}
\\end{enumerate}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-5-16]{Interest 処理のオペレーショナルフロー (3)}
\\begin{enumerate}
\\item コンテンツ有: Interest を消費した (Interest Comsuming の処理) 後，
Data を返送し， NPHT と PHT から Interest を除去
\\begin{itemize}
\\item Data が/a/b/0/1 なら，/a/b/0/1 ・/a/b/0 ・/a/b ・/a を探索する
\\begin{itemize}
\\item オプションによっては， Interest の fullname と NPHT のエント
リが完全一致しなくても良い場合があるため
\\item Interest には， MinSuffixComponents と MaxSuffixComponents というオプ
ションが存在し，マッチしてほしいコンポーネントの範囲を指定することができる
\\item 例えば， Interest の fullname が/a/b/0/1 ， MaxSuffixComponents が
3 の時， Data /a/b/0/1 でも Interest の要件を満たしている
きる
\\end{itemize}
\\end{itemize}

\\item コンテンツ無: NPHT で最長一致検索を行う (FIB の処理)
\\begin{enumerate}
\\item Interest の fullname で探索→ 1 つコンポネント長を短くしたもの
で探索．．．．．．をマッチするか， root prefix に到達するまで繰り返す
\\item Interest を転送した後， NPHT に Interest message を含んだエントリ
を追加， PHT に Interest の nonce を追加
\\end{enumerate}
\\end{enumerate}
\\end{frame}
\\begin{frame}[label=sec-5-17]{Data 処理のオペレーショナルフロー図}
\\includegraphics[width=.9\\linewidth]{./figure/ccnx_data_flow.pdf}
\\end{frame}
\\begin{frame}[label=sec-5-18]{Data 処理のオペレーショナルフロー}
\\begin{itemize}
\\item Interest が CCNx daemon に到着した時の処理を順に述べる
\\begin{enumerate}
\\item CCNx daemon は，バイナリをデコードし， parse
\\item CS seek, saving
\\begin{itemize}
\\item CHT での正確なマッチングを行い，キャシュされているかを確認
(key は Data の full name)
\\item Data は， CHT と CSL に挿入され， CS に格納される
\\end{itemize}
\\item Interest の処理と同様の Interest Consuming の処理
\\end{enumerate}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-5-19]{よく分からなかった点}
\\begin{itemize}
\\item CCNx のデータ構造の中に「 ccn\\_forwarding 」と「 ccn\\_forwarding\\_entry 」
の 2 つのデータ構造があった
\\item この 2 つのデータ構造は，互いに関係がない
\\item NPE からリンクが貼られていたのは前者
\\end{itemize}
\\end{frame}
\\section{2014 年 3 月 5 日}
\\label{sec-6}
\\begin{frame}[label=sec-6-1]{}
\\end{frame}
\\begin{frame}[label=sec-6-2]{前回ミーティングのまとめ}
\\begin{itemize}
\\item 「 Scalable NDN Forwarding:Concepts, Issues and Principles 」を読
み， CCNx のデータ構造についてまとめ， CCNx のデータ構造について
の理解を深める
\\end{itemize}
\\begin{block}{短期的な目標}%x
\\begin{itemize}
\\item CCNx の ver8.1 で機能ごとのブロックを作り，ブロックの処理に必要な
クロック数を測定する
\\end{itemize}
\\end{block}

\\begin{block}{長期的な目標}%x
\\begin{itemize}
\\item 現在はルータの CPU がシングルコアの時のみモデル化できているため，
マルチコアに対応させる
\\end{itemize}
\\end{block}
\\end{frame}

\\begin{frame}[label=sec-6-3]{Scalable NDN Forwarding:Concepts, Issues and Principles}
\\begin{itemize}
\\item 本論文は， CCNx のデータ構造とオペレーショナルフローについてまとめている
\\item ただし， CCNx の ver4.0 を対象としているため，現在の最新である
ver8.1 とは一部異なる可能性がある
\\begin{itemize}
\\item 次スライドから述べる CCNx のデータ構造は ver4.0 のものであること
に留意する
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-6-4]{CCNx のデータ構造}
\\begin{itemize}
\\item CCNx のデータ構造は NDN と異なっている
\\begin{itemize}
\\item NDN
\\begin{itemize}
\\item CS ・ FIB ・ PIT の 3 つのテーブルを持つ
\\end{itemize}
\\item CCNx
\\begin{itemize}
\\item CS に相当する Content Hash Table (CHT) と Content Skip List
(CSL) を持つ
\\item FIB と PIT に相当する Name Prefix Hash Table (NPHT) を持つ
\\item PIT に存在するすべての Interest (PEs の形) の nonce を保持す
る Propagating Hash Table (PHT) を持つ
\\end{itemize}
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-6-5]{CCNx のデータ構造図}
\\includegraphics[width=.9\\linewidth]{./figure/ccnx_data_structure.pdf}
\\end{frame}
\\begin{frame}[label=sec-6-6]{CCNx における CS の概要}
\\begin{itemize}
\\item Data の格納場所と， Data を指すポインタをエントリに持つテーブルに分けられる
\\begin{itemize}
\\item Data の格納場所
\\begin{itemize}
\\item Content Array (CA)
\\item Straggler Hash Table (SHT)
\\end{itemize}
\\item テーブル
\\begin{itemize}
\\item Content Hash Table (CHT)
\\item Content Skip List (CSL)
\\end{itemize}
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-6-7]{CS における Data の格納}
\\begin{itemize}
\\item Data に番号をつけて， CA か SHT に保存する
\\begin{itemize}
\\item daemon に到着した Data には，ユニークな accession number が割り
当てられる
\\begin{itemize}
\\item accession number は， 1 ずつ増加する
\\end{itemize}
\\item キャッシュされた Data は， Content Array (CA) に保存さ
れ， accession number によってインデックスされる
\\item Data がキャッシュされるごとに CA がサポートする accession
number の範囲が移動する
\\begin{itemize}
\\item サポートするスロット数は固定であるため，スライディングウィン
ドウのようにサポートする場所が移動していく
\\end{itemize}
\\item 古くなり CA のサポートから外れたが，人気のある Data は， SHT に
保存される
\\begin{itemize}
\\item どうやって Data が人気か判断するのか， CA と同じように accession
number でアクセスするのか分からないため，ソースを読む必要があ
る
\\end{itemize}
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-6-8]{Content Store のテーブル}
\\begin{itemize}
\\item Content Hash Table (CHT)
\\begin{itemize}
\\item key は Data のフルネーム
\\end{itemize}
\\item Content Skip List (CSL)
\\begin{itemize}
\\item 標準的な skip list
\\item コンテンツ名順の lookup をサポートするために必要
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-6-9]{CCNx における FIB と PIT の概要}
\\begin{itemize}
\\item FIB と PIT はともに， Name Prefix Hash Table (NPHT) によって管理
される
\\begin{itemize}
\\item NPHT は Propagating Entries (PEs) と Forwarding Info Entries
(FIEs) にインデックスしている
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-6-10]{CCNx のオペレーショナルフロー}
\\begin{itemize}
\\item CCNx では， Interest と Data は，異なる関数で処理される
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-6-11]{Interest 処理のオペレーショナルフロー図}
\\includegraphics[width=.9\\linewidth]{./figure/ccnx_interest_flow.pdf}
\\end{frame}
\\begin{frame}[label=sec-6-12]{Interest 処理のオペレーショナルフロー (1)}
\\begin{itemize}
\\item Interest が CCNx daemon に到着した時の処理を順に述べる
\\begin{enumerate}
\\item CCNx daemon は，バイナリをデコードし， name 部とオプション部に
parse
\\item Interest の nonce を key として， PHT で正確な一致検索を行う
\\begin{itemize}
\\item loop している Interest の破棄
\\end{itemize}
\\item Prefix Seek を行う
\\begin{enumerate}
\\item Interest の prefix が\\alert{すべて}存在するかを NPHT でチェックする
\\item 存在しなければ， NPHT に新たなエントリを作成
\\item 2 の時， fast lookup のため prefix は親へのポインタを張る
\\end{enumerate}
\\end{enumerate}
\\end{itemize}

\\includegraphics[width=0.8\\linewidth,height=0.15\\paperheight]{./figure/npht.pdf}
\\end{frame}
\\begin{frame}[label=sec-6-13]{Interest 処理のオペレーショナルフロー (2)}
\\begin{enumerate}
\\item Interest に対応する Data がキャッシュされているか CS をチェック
\\begin{enumerate}
\\item CSL で潜在的にマッチし得るコンテンツを探索
\\item マッチした場合，そのコンテンツを CS から取ってきて，本当に
Interest を満たすものかどうかチェック
\\begin{itemize}
\\item Interest には，特定コンテンツを排除する除外フィルタなどがあ
るため name だけでは不十分であるため
\\end{itemize}
\\end{enumerate}
\\end{enumerate}
\\end{frame}

\\begin{frame}[label=sec-6-14]{Interest 処理のオペレーショナルフロー (3)}
\\begin{enumerate}
\\item コンテンツ有: Interest を消費した (Interest Comsuming の処理) 後， Data パケットを返送し， NPHT
と PHT から Interest の name を除去
\\begin{itemize}
\\item Data が/a/b/0/1 なら，\\alert{/a/b/0 ・/a/b ・/a をすべて}探索
する
\\begin{itemize}
\\item できるだけ多くの Interest を消費するため
\\item 例えば， Interest /a/b/0 が，最初の 3 コンポネントでのみのマッチを
必要としている場合，コンテンツ/a/b/0/1 が Interest/a/b/0 を満たす
\\end{itemize}
\\end{itemize}

\\item コンテンツ無: NPHT で最長一致検索を行う (FIB の処理)
\\begin{enumerate}
\\item Interest の fullname で探索→ 1 つコンポネント長を短くしたもの
で探索．．．．．．をマッチするか， root prefix に到達するまで繰り返す
\\item Interest を転送した後， NPHT に Interest message を含んだエントリ
を追加， PHT に Interest の nonce を追加
\\end{enumerate}
\\end{enumerate}
\\end{frame}
\\begin{frame}[label=sec-6-15]{Data 処理のオペレーショナルフロー図}
\\includegraphics[width=.9\\linewidth]{./figure/ccnx_data_flow.pdf}
\\end{frame}
\\begin{frame}[label=sec-6-16]{Data 処理のオペレーショナルフロー}
\\begin{itemize}
\\item Interest が CCNx daemon に到着した時の処理を順に述べる
\\begin{enumerate}
\\item CCNx daemon は，バイナリをデコードし， parse
\\item CS seek, saving
\\begin{itemize}
\\item CHT での正確なマッチングを行い，キャシュされているかを確認
(key は Data の full name)
\\item Data は， CHT と CSL に挿入され， CS に格納される
\\end{itemize}
\\item Interest の処理と同様の Interest Consuming の処理
\\end{enumerate}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-6-17]{所感}
\\begin{itemize}
\\item CCNx のデータ構造について大まかな理解はできたと思われる
\\item 一方で，各テーブルのエントリの構造などの細かい所については触れられ
ていなかったため，ソースコードを読んでいく必要があると感じた
\\end{itemize}
\\end{frame}
% Emacs 24.3.1 (Org mode 8.2.5h)
\\end{document}" #("** 前回ミーティングのまとめ (2)
   - フォワーディングエンジンの動作は，基本的に CCNx に従う
     - Cisco の NDN ルータのソフトウェアではオプションの処理ができず，
       現実的に利用するのは難しいと判断したため
   - CCNx では， FIB と PIT を NPHT (Name Prefix Hash Table) で管理して
     いるため， PIT と CS を排他的に割り当てするためには， NPHT ( FIB ・
     PIT) と CS をパーティショニングする必要がある" 0 1 (face org-level-2 fontified t) 1 3 (face org-level-2 fontified t) 3 19 (face org-level-2 fontified t) 19 273 (fontified t)) #("   - 下図の D (ディスパッチャ) と A0 〜 A2 (NDN パケットを処理するプロ
     セス) がパケットを処理するのに要するクロック数を測定する
     - 下図の A0 〜 A2 がパケットを処理するのに要するクロック数は，中井さんの測定し
       た結果から分かる
     - D が処理するのに要するクロック数は，新たに計測する
       - そのために，まずはディスパッチャの設計を考える必要がある

[[./figure/hardware-crop.pdf]]
" 0 48 (fontified t) 48 221 (fontified t) 221 222 (fontified t) 222 223 (face org-link htmlize-link #4=(:uri #3="./figure/hardware-crop.pdf") help-echo #2="LINK: ./figure/hardware-crop.pdf" font-lock-multiline t mouse-face highlight keymap #1=(keymap (follow-link . mouse-face) (mouse-3 . org-find-file-at-mouse) (mouse-2 . org-open-at-mouse)) invisible org-link org-no-flyspell t fontified t) 223 224 (face org-link rear-nonsticky #6=(mouse-face highlight keymap invisible intangible help-echo org-linked-text htmlize-link) htmlize-link #4# help-echo #2# font-lock-multiline t mouse-face highlight keymap #1# invisible org-link org-no-flyspell t fontified t) 224 249 (face org-link htmlize-link #5=(:uri #3#) help-echo #2# font-lock-multiline t mouse-face highlight keymap #1# org-no-flyspell t fontified t) 249 250 (face org-link rear-nonsticky #6# htmlize-link #5# help-echo #2# font-lock-multiline t mouse-face highlight keymap #1# org-no-flyspell t fontified t) 250 251 (face org-link htmlize-link #4# help-echo #2# font-lock-multiline t mouse-face highlight keymap #1# invisible org-link org-no-flyspell t fontified t) 251 252 (face org-link rear-nonsticky #6# htmlize-link #4# help-echo #2# font-lock-multiline t mouse-face highlight keymap #1# invisible org-link org-no-flyspell t fontified t) 252 253 (rear-nonsticky t fontified t)) #("** 前回ミーティングのまとめ (1)
   - 下図の D (ディスパッチャ) と A0 〜 A2 (NDN パケットを処理するプロ
     セス) がパケットを処理するのに要するクロック数を測定する
     - 下図の A0 〜 A2 がパケットを処理するのに要するクロック数は，中井さんの測定し
       た結果から分かる
     - D が処理するのに要するクロック数は，新たに計測する
       - そのために，まずはディスパッチャの設計を考える必要がある

[[./figure/hardware-crop.pdf]]
" 0 1 (face org-level-2 fontified t) 1 3 (face org-level-2 fontified t) 3 19 (face org-level-2 fontified t) 19 68 (fontified t) 68 241 (fontified t) 241 273 (fontified nil)) #("** " 0 1 (face org-level-2 fontified t) 1 3 (face org-level-2 fontified t)) #("** 研究目標
*** 短期的な目標 (5 月)
    - 中井さんが提案した NDN ルータの電力消費モデルをマルチコア CPU に対応させる
*** それ以降の目標
    - CCNx の最新 ver に対応させる
    - FIB ・ PIT ・ CS のテーブルサイズの大きさが，電力消費にどのような
      影響を与えるかを調査する
      - 該当エントリの lookup に要する時間が長くなるため，テーブルサイ
        ズが大きいほうが電力消費は大きくなると思われる
" 0 1 (face org-level-2 fontified t) 1 3 (face org-level-2 fontified t) 3 7 (face org-level-2 fontified t) 7 8 (fontified t) 8 10 (face org-level-3 fontified t) 10 12 (face org-level-3 fontified t) 12 24 (face org-level-3 fontified t) 24 74 (fontified t) 74 76 (face org-level-3 fontified t) 76 78 (face org-level-3 fontified t) 78 85 (face org-level-3 fontified t) 85 253 (fontified t)) #("* " 0 2 (face org-level-1 fontified t)) #("

" 0 1 (fontified t) 1 2 (fontified t))))
(setq-default session-file-alist '(("~/Dropbox/meeting/withHasegawa/GreenICN/ohsugi-M1-meeting.org" 455 455 1 nil nil 542 (overwrite-mode)) ("~/Dropbox/configure/.emacs.d/var/recentf" 9607 nil 1 nil nil nil (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/inits/05_color-theme.el" 167 nil 1 nil nil nil (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/color-theme-solarized-20140401.957/color-theme-solarized-autoloads.el" 1191 nil 1 nil nil 1191 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/inits/05_font.el" 58 2 1 nil nil 2 (overwrite-mode)) ("~/.config/awesome/rc.lua" 17771 1744 1 nil nil 13603 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/var/recentf" 9542 nil 1 nil nil nil (overwrite-mode)) ("/mnt/Dropbox/rc.lua" 21601 21527 1 nil nil nil (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/url/cookies" 507 nil 1 nil nil nil (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/helm-20140403.513/helm-autoloads.el" 45170 nil 1 nil nil 45170 (overwrite-mode)) ("/mnt/Dropbox/meeting/withHasegawa/GreenICN/ohsugi-M1-meeting.org" 713 439 1 nil nil 713 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/helm-20140401.2209/helm-autoloads.el" 45163 nil 1 nil nil 45163 (overwrite-mode)) ("~/hoge.tex" 147 148 1 nil nil 162 (overwrite-mode)) ("~/hoge.bib" 77 1 1 nil nil 314 (overwrite-mode)) ("/mnt/Dropbox/meeting/withHasegawa/GreenICN/ohsugi-M1-meeting.tex" 29462 nil 1 nil nil nil (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/inits/50_auto-complete.el" 101 1 1 nil nil 101 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/snippets/org-mode/figure" 50 nil 1 nil nil 114 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/inits/20_org-mode.el" 1806 nil 1 nil nil 1806 (overwrite-mode)) ("/mnt/Windows8x64/Windows8.vmx" 3494 nil 1 nil nil nil (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/helm-20140329.1236/helm-autoloads.el" 45168 nil 1 nil nil 45168 (overwrite-mode)) ("/mnt/Dropbox/configure/.zshrc" 860 749 1 nil nil 764 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/dash-20140327.116/dash-autoloads.el" 174 nil 1 nil nil 174 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/helm-20140328.905/helm-autoloads.el" 45167 nil 1 nil nil 45167 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/yaxception-20140327.409/yaxception-autoloads.el" 192 nil 1 nil nil 192 (overwrite-mode)) ("~/au_wifi.js" 75 67 1 nil nil 1086 (overwrite-mode)) ("~/Dropbox/job_hunting/FUTURE_Architect/slide.org" 1545 1550 1 nil nil 1545 (overwrite-mode)) ("~/Dropbox/job_hunting/FUTURE_Architect/slide.tex" 2782 nil 1 nil nil nil (overwrite-mode)) ("~/Dropbox/job_hunting/HITACHI/es.org" 339 272 1 nil nil 1866 (overwrite-mode)) ("~/Dropbox/job_hunting/HITACHI/hitach_jobmatching.txt" 1 nil 1 nil nil nil (overwrite-mode)) ("~/Dropbox/storage/report/ネットワークセミナーⅡ/paper.tex" 1573 nil 1 nil nil nil (overwrite-mode)) ("~/Dropbox/storage/report/ネットワークセミナーⅡ/33E13003.pdf" 1 nil 1 nil nil nil (overwrite-mode)) ("~/Dropbox/job_hunting/FUTURE_Architect/es.org" 609 nil 1 nil nil nil (overwrite-mode)) ("~/Dropbox/storage/report/ネットワークセミナーⅡ/paper.org" 1158 1311 1 nil nil nil (overwrite-mode)) ("~/Dropbox/configure/.emacs.d/elpa/helm-20140326.1237/helm-autoloads.el" 44947 nil 1 nil nil 44947 (overwrite-mode)) ("~/Dropbox/configure/.emacs.d/elpa/yaxception-20140326.1804/yaxception-autoloads.el" 192 nil 1 nil nil 192 (overwrite-mode)) ("~/Dropbox/job_hunting/HITACHI/情報通信システム社es.org" 596 391 1 nil nil 240 (overwrite-mode)) ("~/Dropbox/job_hunting/NTTDATA/es.org" 19 1095 1 nil nil nil (overwrite-mode)) ("/mnt/Dropbox/job_hunting/HITACHI/情報通信システム社es.org" 159 93 1 nil nil 84 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/org-ac-20140302.413/org-ac-autoloads.el" 550 nil 1 nil nil 550 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/auto-complete-pcmp-20140226.2251/auto-complete-pcmp-autoloads.el" 215 nil 1 nil nil 215 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/log4e-20130514.912/log4e-autoloads.el" 177 nil 1 nil nil 177 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/yaxception-20140320.814/yaxception-autoloads.el" 192 nil 1 nil nil 192 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/auto-complete-20140322.321/auto-complete-config.el" 18432 878 1 nil nil nil (overwrite-mode)) ("~/hote.txt" 6 nil 1 nil nil 6 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/auto-complete-20140322.321/auto-complete.el" 20900 68949 1 nil nil nil (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/auto-complete-20140322.321/auto-complete-pkg.el" 1 nil 1 nil nil nil (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/inits/10_helm.el" 932 907 1 nil nil 932 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/org-20140324/org-loaddefs.el" 86900 nil 1 nil nil 86900 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/org-20140324/org-autoloads.el" 27238 nil 1 nil nil 27238 (overwrite-mode)) ("/mnt/Dropbox/job_hunting/HITACHI/hitach_jobmatching.txt" 150 nil 1 nil nil nil (overwrite-mode)) ("/mnt/Dropbox/job_hunting/HITACHI/es.org" 1 1710 1 nil nil nil (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/helm-20140323.1210/helm-autoloads.el" 44941 nil 1 nil nil 44941 (overwrite-mode)) ("/mnt/Dropbox/job_hunting/NTTDATA/es.org" 1028 731 1 nil nil nil (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/inits/99_popwin.el" 2 nil 1 nil nil nil (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/org-20140317/org-loaddefs.el" 86900 nil 1 nil nil 86900 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/helm-20140317.326/helm-autoloads.el" 44857 nil 1 nil nil 44857 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/org-20140317/org-autoloads.el" 27223 nil 1 nil nil 27223 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/multi-term-20140316.1714/multi-term-autoloads.el" 1341 nil 1 nil nil 1341 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/auto-complete-20140314.802/auto-complete-autoloads.el" 1481 nil 1 nil nil 1481 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/helm-20140315.28/helm-autoloads.el" 44939 nil 1 nil nil 44939 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/yasnippet-20140314.255/yasnippet-autoloads.el" 1493 nil 1 nil nil 1493 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/helm-20140312.2221/helm-autoloads.el" 45351 nil 1 nil nil 45351 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/yasnippet-20140313.1329/yasnippet-autoloads.el" 1494 nil 1 nil nil 1494 (overwrite-mode)) ("~/Dropbox/meeting/withHasegawa/GreenICN/ohsugi-M1-meeting.tex" 14216 nil 1 nil nil nil (overwrite-mode)) ("~/Dropbox/configure/.emacs.d/elpa/helm-20140311.818/helm-autoloads.el" 45349 nil 1 nil nil 45349 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/dash-20140308.656/dash-autoloads.el" 174 nil 1 nil nil 174 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/helm-20140309.505/helm-autoloads.el" 45354 nil 1 nil nil 45354 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/lua-mode-20140306.2249/lua-mode-autoloads.el" 512 nil 1 nil nil 512 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/popwin-20140309.745/popwin-autoloads.el" 2533 nil 1 nil nil 2533 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/helm-20140306.2141/helm-autoloads.el" 45352 nil 1 nil nil 45352 (overwrite-mode)) ("~/hoge/achievement_20140307.html" 2376 nil 1 nil nil nil (overwrite-mode)) ("/mnt/Dropbox/meeting/withHasegawa/140305/140305-M1meeting.org" 1 3151 1 nil nil 3232 (overwrite-mode)) ("/mnt/Dropbox/meeting/withHasegawa/140305/140305-M1meeting.tex" 6306 nil 1 nil nil nil (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/helm-20140303.2232/helm-autoloads.el" 45351 nil 1 nil nil 45351 (overwrite-mode)) ("/mnt/Dropbox/old/old_presentation/graduation_thesis/abstract.tex" 1 nil 1 nil nil nil (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/concurrent-20140303.1635/concurrent-autoloads.el" 192 nil 1 nil nil 192 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/dash-20140303.1404/dash-autoloads.el" 174 nil 1 nil nil 174 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/deferred-20140303.1634/deferred-autoloads.el" 186 nil 1 nil nil 186 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/helm-20140303.755/helm-autoloads.el" 45353 nil 1 nil nil 45353 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/yasnippet-20140303.53/yasnippet-autoloads.el" 1493 nil 1 nil nil 1493 (overwrite-mode)) ("~/Dropbox/configure/.emacs.d/url/cookies" 511 nil 1 nil nil nil (overwrite-mode)) ("~/Dropbox/configure/.emacs.d/elpa/ctable-20140301.1809/ctable-autoloads.el" 180 nil 1 nil nil 180 (overwrite-mode)) ("~/Dropbox/configure/.emacs.d/elpa/epc-20140301.1811/epc-autoloads.el" 181 nil 1 nil nil 181 (overwrite-mode)) ("~/Dropbox/configure/.emacs.d/elpa/helm-20140301.210/helm-autoloads.el" 45351 nil 1 nil nil 45351 (overwrite-mode)) ("~/Dropbox/etc/book_list/book_list.org" 724 1159 1 nil nil 724 (overwrite-mode)) ("~/Dropbox/configure/.emacs.d/snippets/org-mode/report" 50 nil 1 nil nil 68 (overwrite-mode)) ("~/Dropbox/configure/.emacs.d/elpa/auctex-11.87.3/auctex-autoloads.el" 10919 nil 1 nil nil 10919 (overwrite-mode)) ("~/Dropbox/configure/.emacs.d/elpa/yasnippet-20140227.703/yasnippet-autoloads.el" 1494 nil 1 nil nil 1494 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/cl-lib-0.5/cl-lib-autoloads.el" 407 nil 1 nil nil 407 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/helm-20140226.129/helm-autoloads.el" 45032 nil 1 nil nil 45032 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/yasnippet-20140223.1202/yasnippet-autoloads.el" 1491 nil 1 nil nil 1491 (overwrite-mode)) ("~/Dropbox/job_hunting/NRI/es.org" 762 108 1 nil nil 648 (overwrite-mode)) ("~/Dropbox/configure/.emacs.d/elpa/helm-20140225.1146/helm-autoloads.el" 45062 nil 1 nil nil 45062 (overwrite-mode)) ("~/Dropbox/configure/.emacs.d/elpa/org-20140224/org-loaddefs.el" 86900 nil 1 nil nil 86900 (overwrite-mode)) ("~/Dropbox/configure/.emacs.d/elpa/helm-20140223.1212/helm-autoloads.el" 45055 nil 1 nil nil 45055 (overwrite-mode)) ("~/Dropbox/configure/.emacs.d/elpa/org-20140224/org-autoloads.el" 27239 nil 1 nil nil 27239 (overwrite-mode))))
(setq-default TeX-command-history '("Evince" "LatexMk"))
(setq-default buffer-name-history '("*Backtrace*" "20_org-mode.el" "hote.txt" "*Packages*" "es.org" "PKGBUILD" "*init log*"))
(setq-default command-history '((find-file "~/Dropbox/rc.lua" t) (find-file "~/hoge.tex" t) (find-file "~/hoge.bib" t) (kill-buffer "*Backtrace*") (kill-buffer "20_org-mode.el") (find-file "/mnt/Windows8x64/Windows8.vmx" t) (find-file "~/au_wifi.js" t) (find-file "~/Dropbox/storage/report/ネットワークセミナーⅡ/paper.org" t) (find-file "~/Dropbox/storage/report/ネットワークセミナーⅡ/paper.tex" t) (find-file "~/Dropbox/storage/report/ネットワークセミナーⅡ/" t) (describe-variable (quote ac-source-filename)) (describe-function (quote ac-config-default)) (find-file "~/hote.txt" t) (find-file "~/.emacs.d/elpa/auto-complete-20140322.321/auto-complete.el" t) (find-file "~/.emacs.d/elpa/auto-complete-20140322.321/auto-complete-pkg.el" t) (find-file "~/.emacs.d/elpa/auto-complete-20140322.321/" t) (describe-variable (quote ac-sources)) (find-file "~/.emacs.d/inits/05_font.el" t) (query-replace "./" "./figure/" nil (if (and transient-mark-mode mark-active) (region-beginning)) (if (and transient-mark-mode mark-active) (region-end))) (describe-function (quote global-auto-complete-mode)) (describe-function (quote auto-complete-mode-maybe)) (describe-variable (quote ac-modes)) (kill-buffer "hote.txt") (describe-key "s" 1 nil) (describe-key "" 1 nil) (find-file "~/Dropbox/job_hunting/HITACHI/情報通信システム社es.org" t) (find-file "~/Dropbox/job_hunting/HITACHI/hitach_jobmatching.txt" t) (find-file "~/.emacs.d/inits/99_popwin.el" t) (kill-buffer "*Packages*") (kill-buffer "es.org") (kill-buffer "PKGBUILD") (yas-load-snippet-buffer-and-close (quote org-mode) nil) (find-file "~/Dropbox/meeting/withHasegawa/140305/" t) (find-file "~/Dropbox/meeting/withHasegawa/140305/140305-M1meeting.org" t) (dired-create-directory "~/Dropbox/meeting/withHasegawa/140305") (find-file "~/Dropbox/meeting/withHasegawa/" t) (kill-buffer "*init log*")))
(setq-default extended-command-history '("package-list-packages" "count-lines-region" "describe-variable" "eval-buffer" "describe-function" "auto-complete-mode" "describe-mode" "Buffer-menu-mode" "describe-key" "eval-defun" "pascal-mode"))
(setq-default helm-c-grep-history '("valid-file" "filename"))
(setq-default helm-c-source-complex-command-history '((name . "Complex Command History") (candidates lambda nil (mapcar (quote prin1-to-string) command-history)) (type . sexp)))
(setq-default helm-c-source-file-name-history '((name . "File Name History") (candidates . file-name-history) (persistent-action . ignore) (filtered-candidate-transformer . helm-file-name-history-transformer) (action ("Find file" . helm-find-many-files) ("Find file as root" . helm-find-file-as-root) ("Find file other window" . find-file-other-window) ("Find file other frame" . find-file-other-frame) ("Open dired in file's directory" . helm-open-dired) ("Grep File(s) `C-u recurse'" . helm-find-files-grep) ("Zgrep File(s) `C-u Recurse'" . helm-ff-zgrep) ("Pdfgrep File(s)" . helm-ff-pdfgrep) ("Insert as org link" . helm-files-insert-as-org-link) ("Checksum File" . helm-ff-checksum) ("Ediff File" . helm-find-files-ediff-files) ("Ediff Merge File" . helm-find-files-ediff-merge-files) ("Etags `M-., C-u tap, C-u C-u reload tag file'" . helm-ff-etags-select) ("View file" . view-file) ("Insert file" . insert-file) ("Delete file(s)" . helm-delete-marked-files) ("Open file externally (C-u to choose)" . helm-open-file-externally) ("Open file with default tool" . helm-open-file-with-default-tool) ("Find file in hex dump" . hexl-find-file))))
(setq-default helm-c-source-global-mark-ring '((name . "global-mark-ring") (candidates . helm-global-mark-ring-get-candidates) (action ("Goto line" lambda (candidate) (let ((items (split-string candidate ":"))) (helm-switch-to-buffer (cl-second items)) (helm-goto-line (string-to-number (car items)))))) (persistent-action lambda (candidate) (let ((items (split-string candidate ":"))) (helm-switch-to-buffer (cl-second items)) (helm-goto-line (string-to-number (car items))) (helm-highlight-current-line))) (persistent-help . "Show this line")))
(setq-default helm-c-source-kill-ring '((name . "Kill Ring") (init lambda nil (helm-attrset (quote last-command) last-command)) (candidates . helm-kill-ring-candidates) (filtered-candidate-transformer helm-kill-ring-transformer) (action ("Yank" . helm-kill-ring-action) ("Delete" lambda (candidate) (cl-loop for cand in (helm-marked-candidates) do (setq kill-ring (delete cand kill-ring))))) (keymap keymap (27 keymap (117 . helm-previous-line) (121 . helm-next-line)) keymap (menu-bar keymap (help-menu keymap (describe keymap (describe-mode . helm-help)))) (help keymap (109 . helm-help)) (f1 keymap (109 . helm-help)) (8 . delete-backward-char) (20 . helm-toggle-resplit-and-swap-windows) (C-tab . undefined) (triple-mouse-3 . ignore) (double-mouse-3 . ignore) (mouse-3 . ignore) (drag-mouse-3 . ignore) (down-mouse-3 . ignore) (triple-mouse-2 . ignore) (double-mouse-2 . ignore) (mouse-2 . ignore) (drag-mouse-2 . ignore) (down-mouse-2 . ignore) (triple-mouse-1 . ignore) (double-mouse-1 . ignore) (mouse-1 . ignore) (drag-mouse-1 . ignore) (down-mouse-1 . ignore) (67108897 . helm-toggle-suspend-update) (3 keymap (1 . all-from-helm-occur) (21 . helm-force-update) (6 . helm-follow-mode) (11 . helm-kill-selection-and-quit) (25 . helm-yank-selection) (4 . helm-delete-current-selection) (45 . helm-swap-windows)) (67108987 . helm-enlarge-window) (67108989 . helm-narrow-window) (19 . undefined) (18 . undefined) (23 . helm-yank-text-at-point) (24 keymap (2 . helm-resume-list-buffers-after-quit) (98 . helm-resume-previous-session-after-quit) (6 . helm-quit-and-find-file)) (11 . helm-delete-minibuffer-contents) (67108896 . helm-toggle-visible-mark) (0 . helm-toggle-visible-mark) (C-M-up . helm-scroll-other-window-down) (C-M-down . helm-scroll-other-window) (M-prior . helm-scroll-other-window-down) (M-next . helm-scroll-other-window) (12 . helm-recenter-top-bottom-other-window) (15 . helm-next-source) (10 . helm-select-3rd-action) (5 . helm-select-2nd-action-or-end-of-line) (26 . helm-execute-persistent-action) (9 . helm-select-action) (13 . helm-exit-minibuffer) (left . helm-previous-source) (right . helm-next-source) (7 . helm-keyboard-quit) (22 . helm-next-page) (27 keymap (110 . next-history-element) (112 . previous-history-element) (115 . undefined) (5 . helm-display-all-sources) (1 . helm-show-all-in-this-source-only) (117 . helm-unmark-all) (97 . helm-mark-all) (109 . helm-toggle-all-marks) (41 . helm-next-visible-mark) (40 . helm-prev-visible-mark) (91) (32 . helm-toggle-visible-mark) (33554454 . helm-scroll-other-window-down) (25 . helm-scroll-other-window-down) (22 . helm-scroll-other-window) (12 . helm-reposition-window-other-window) (62 . helm-end-of-buffer) (60 . helm-beginning-of-buffer) (118 . helm-previous-page)) (next . helm-next-page) (prior . helm-previous-page) (16 . helm-previous-line) (14 . helm-next-line) (up . helm-previous-line) (down . helm-next-line) keymap (26 . undefined) (18 . helm-minibuffer-history) (S-tab . zlc-select-previous) (backtab . zlc-select-previous) (menu-bar keymap (minibuf #1="Minibuf" keymap (previous menu-item "Previous History Item" previous-history-element :help "Put previous minibuffer history element in the minibuffer") (next menu-item "Next History Item" next-history-element :help "Put next minibuffer history element in the minibuffer") (isearch-backward menu-item "Isearch History Backward" isearch-backward :help "Incrementally search minibuffer history backward") (isearch-forward menu-item "Isearch History Forward" isearch-forward :help "Incrementally search minibuffer history forward") (return menu-item "Enter" exit-minibuffer :key-sequence "" :help "Terminate input and exit minibuffer") (quit menu-item "Quit" abort-recursive-edit :help "Abort input and exit minibuffer") #1#)) (10 . exit-minibuffer) (13 . exit-minibuffer) (7 . minibuffer-keyboard-quit) (C-tab . file-cache-minibuffer-complete) (9 . self-insert-command) (XF86Back . previous-history-element) (up . previous-history-element) (prior . previous-history-element) (XF86Forward . next-history-element) (down . next-history-element) (next . next-history-element) (27 keymap (63 . session-minibuffer-history-help) (114 . previous-matching-history-element) (115 . next-matching-history-element) (112 . previous-history-element) (110 . next-history-element))) (last-command . kill-region) (migemo) (multiline)))
(setq-default helm-c-source-mark-ring '((name . "mark-ring") (candidates . helm-mark-ring-get-candidates) (action ("Goto line" lambda (candidate) (helm-goto-line (string-to-number candidate)))) (persistent-action lambda (candidate) (helm-goto-line (string-to-number candidate)) (helm-highlight-current-line)) (persistent-help . "Show this line")))
(setq-default helm-grep-history '("valid-file" "filename"))
(setq-default helm-source--ff-file-name-history '((name . "File name history") (init lambda nil (with-helm-alive-p (when helm-ff-file-name-history-use-recentf (require (quote recentf)) (or recentf-mode (recentf-mode 1))))) (candidates lambda nil (if helm-ff-file-name-history-use-recentf recentf-list file-name-history)) (persistent-action . ignore) (filtered-candidate-transformer . helm-file-name-history-transformer) (action ("Find file" lambda (candidate) (helm-set-pattern (expand-file-name candidate)) (with-helm-after-update-hook (helm-exit-minibuffer))) ("Find file in helm" lambda (candidate) (helm-set-pattern (expand-file-name candidate))))))
(setq-default helm-source-complex-command-history '((name . "Complex Command History") (candidates lambda nil (mapcar (quote prin1-to-string) command-history)) (type . sexp)))
(setq-default helm-source-file-name-history '((name . "File Name History") (candidates . file-name-history) (persistent-action . ignore) (filtered-candidate-transformer . helm-file-name-history-transformer) (action ("Find file" . helm-find-many-files) ("Find file as root" . helm-find-file-as-root) ("Find file other window" . find-file-other-window) ("Find file other frame" . find-file-other-frame) ("Open dired in file's directory" . helm-open-dired) ("Grep File(s) `C-u recurse'" . helm-find-files-grep) ("Zgrep File(s) `C-u Recurse'" . helm-ff-zgrep) ("Pdfgrep File(s)" . helm-ff-pdfgrep) ("Insert as org link" . helm-files-insert-as-org-link) ("Checksum File" . helm-ff-checksum) ("Ediff File" . helm-find-files-ediff-files) ("Ediff Merge File" . helm-find-files-ediff-merge-files) ("Etags `M-., C-u tap, C-u C-u reload tag file'" . helm-ff-etags-select) ("View file" . view-file) ("Insert file" . insert-file) ("Delete file(s)" . helm-delete-marked-files) ("Open file externally (C-u to choose)" . helm-open-file-externally) ("Open file with default tool" . helm-open-file-with-default-tool) ("Find file in hex dump" . hexl-find-file))))
(setq-default helm-source-global-mark-ring '((name . "global-mark-ring") (candidates . helm-global-mark-ring-get-candidates) (action ("Goto line" lambda (candidate) (let ((items (split-string candidate ":"))) (helm-switch-to-buffer (cl-second items)) (helm-goto-line (string-to-number (car items)))))) (persistent-action lambda (candidate) (let ((items (split-string candidate ":"))) (helm-switch-to-buffer (cl-second items)) (helm-goto-line (string-to-number (car items))) (helm-highlight-current-line))) (persistent-help . "Show this line")))
(setq-default helm-source-kill-ring '((name . "Kill Ring") (init lambda nil (helm-attrset (quote last-command) last-command)) (candidates . helm-kill-ring-candidates) (filtered-candidate-transformer helm-kill-ring-transformer) (action ("Yank" . helm-kill-ring-action) ("Delete" lambda (candidate) (cl-loop for cand in (helm-marked-candidates) do (setq kill-ring (delete cand kill-ring))))) (keymap keymap (27 keymap (117 . helm-previous-line) (121 . helm-next-line)) keymap (menu-bar keymap (help-menu keymap (describe keymap (describe-mode . helm-help)))) (help keymap (109 . helm-help)) (f1 keymap (109 . helm-help)) (8 . delete-backward-char) (20 . helm-toggle-resplit-and-swap-windows) (C-tab . undefined) (triple-mouse-3 . ignore) (double-mouse-3 . ignore) (mouse-3 . ignore) (drag-mouse-3 . ignore) (down-mouse-3 . ignore) (triple-mouse-2 . ignore) (double-mouse-2 . ignore) (mouse-2 . ignore) (drag-mouse-2 . ignore) (down-mouse-2 . ignore) (triple-mouse-1 . ignore) (double-mouse-1 . ignore) (mouse-1 . ignore) (drag-mouse-1 . ignore) (down-mouse-1 . ignore) (67108897 . helm-toggle-suspend-update) (3 keymap (1 . all-from-helm-occur) (21 . helm-force-update) (6 . helm-follow-mode) (11 . helm-kill-selection-and-quit) (25 . helm-yank-selection) (4 . helm-delete-current-selection) (45 . helm-swap-windows)) (67108987 . helm-enlarge-window) (67108989 . helm-narrow-window) (19 . undefined) (18 . undefined) (23 . helm-yank-text-at-point) (24 keymap (2 . helm-resume-list-buffers-after-quit) (98 . helm-resume-previous-session-after-quit) (6 . helm-quit-and-find-file)) (11 . helm-delete-minibuffer-contents) (67108896 . helm-toggle-visible-mark) (0 . helm-toggle-visible-mark) (C-M-up . helm-scroll-other-window-down) (C-M-down . helm-scroll-other-window) (M-prior . helm-scroll-other-window-down) (M-next . helm-scroll-other-window) (12 . helm-recenter-top-bottom-other-window) (15 . helm-next-source) (10 . helm-select-3rd-action) (5 . helm-select-2nd-action-or-end-of-line) (26 . helm-execute-persistent-action) (9 . helm-select-action) (13 . helm-exit-minibuffer) (left . helm-previous-source) (right . helm-next-source) (7 . helm-keyboard-quit) (22 . helm-next-page) (27 keymap (110 . next-history-element) (112 . previous-history-element) (115 . undefined) (5 . helm-display-all-sources) (1 . helm-show-all-in-this-source-only) (117 . helm-unmark-all) (97 . helm-mark-all) (109 . helm-toggle-all-marks) (41 . helm-next-visible-mark) (40 . helm-prev-visible-mark) (91) (32 . helm-toggle-visible-mark) (33554454 . helm-scroll-other-window-down) (25 . helm-scroll-other-window-down) (22 . helm-scroll-other-window) (12 . helm-reposition-window-other-window) (62 . helm-end-of-buffer) (60 . helm-beginning-of-buffer) (118 . helm-previous-page)) (next . helm-next-page) (prior . helm-previous-page) (16 . helm-previous-line) (14 . helm-next-line) (up . helm-previous-line) (down . helm-next-line) keymap (26 . undefined) (18 . helm-minibuffer-history) (S-tab . zlc-select-previous) (backtab . zlc-select-previous) (menu-bar keymap (minibuf #1="Minibuf" keymap (previous menu-item "Previous History Item" previous-history-element :help "Put previous minibuffer history element in the minibuffer") (next menu-item "Next History Item" next-history-element :help "Put next minibuffer history element in the minibuffer") (isearch-backward menu-item "Isearch History Backward" isearch-backward :help "Incrementally search minibuffer history backward") (isearch-forward menu-item "Isearch History Forward" isearch-forward :help "Incrementally search minibuffer history forward") (return menu-item "Enter" exit-minibuffer :key-sequence "" :help "Terminate input and exit minibuffer") (quit menu-item "Quit" abort-recursive-edit :help "Abort input and exit minibuffer") #1#)) (10 . exit-minibuffer) (13 . exit-minibuffer) (7 . minibuffer-keyboard-quit) (C-tab . file-cache-minibuffer-complete) (9 . self-insert-command) (XF86Back . previous-history-element) (up . previous-history-element) (prior . previous-history-element) (XF86Forward . next-history-element) (down . next-history-element) (next . next-history-element) (27 keymap (63 . session-minibuffer-history-help) (114 . previous-matching-history-element) (115 . next-matching-history-element) (112 . previous-history-element) (110 . next-history-element))) (last-command . kill-region) (migemo) (multiline)))
(setq-default helm-source-mark-ring '((name . "mark-ring") (candidates . helm-mark-ring-get-candidates) (action ("Goto line" lambda (candidate) (helm-goto-line (string-to-number candidate)))) (persistent-action lambda (candidate) (helm-goto-line (string-to-number candidate)) (helm-highlight-current-line)) (persistent-help . "Show this line")))
(setq-default minibuffer-history '("org" "color" "font" "rc.lua" "pack" "rc" "rc." "evince hoge.pdf" "hoge" "hoge.bib" "auto-com" "org-mode" "zshrc" "p" "-------" "fu" "future" #("centering" 0 9 (fontified t)) "hitachi"))
(setq-default occur-collect-regexp-history '("\\1"))
(setq-default query-replace-history '("./figure/" "./"))
(setq-default search-ring '("modkey" "org-" "mein" "correct" "orgdef" "org" "auto-co" "ac " "auto-complete" "company" "org auc" "filename" "ac-source" "file" "auto-s" "txt"))
(setq-default serial-name-history '("/dev/ttyS0"))
(setq-default serial-speed-history '("9600" "1200" "2400" "4800" "14400" "19200" "28800" "38400" "57600" "115200"))
(setq-default table-capture-columns-history '(""))
(setq-default table-capture-justify-history '("left"))
(setq-default table-capture-min-cell-width-history '("5"))
(setq-default table-cell-height-history '("1"))
(setq-default table-cell-span-direction-history '("right"))
(setq-default table-cell-split-contents-to-history '("split"))
(setq-default table-cell-split-orientation-history '("horizontally"))
(setq-default table-cell-width-history '("5"))
(setq-default table-col-delim-regexp-history '(""))
(setq-default table-columns-history '("3"))
(setq-default table-insert-row-column-history '("row"))
(setq-default table-justify-history '("center"))
(setq-default table-row-delim-regexp-history '(""))
(setq-default table-rows-history '("3"))
(setq-default table-sequence-count-history '("0"))
(setq-default table-sequence-increment-history '("1"))
(setq-default table-sequence-interval-history '("1"))
(setq-default table-sequence-justify-history '("left"))
(setq-default table-sequence-string-history '("0"))
(setq-default table-source-caption-history '("Table"))
(setq-default table-source-language-history '("html"))
(setq-default table-target-history '("cell"))
