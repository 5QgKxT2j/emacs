;;; Automatically generated on Tue Jul 22 12:13:35 2014
;;; Invoked by k-ohsugi@localhost using 24.3.1
(setq-default kill-ring '("% Created 2014-07-10 木 21:47
\\documentclass[dvipdfmx,11pt]{beamer}
\\usepackage{url}
\\usepackage{pxjahyper}
\\usetheme{Berlin}
\\setbeamertemplate{navigation symbols}{}
\\beamertemplatetextbibitems
\\setbeamertemplate{footline}[frame number]
\\setbeamertemplate{headline}{}


\\institute[]{Osaka University\\\\
Graduate School of Information Science and Technology \\\\
Information Sharing Platform Laboratory \\\\
Master course second year}
\\usetheme{default}
\\author{大杉 海斗}
\\date{\\today}
\\title{ICN Meeting}
\\hypersetup{
  pdfkeywords={},
  pdfsubject={},
  pdfcreator={Emacs 24.3.1 (Org mode 8.2.7b)}}
\\begin{document}

\\maketitle

\\section{2014 年 7 月 15 日}
\\label{sec-1}
\\begin{frame}[label=sec-1-1]{進捗状況}
\\begin{itemize}
\\item CCN ルータの要件を調査するため，「 On Content-Centric Router Design and Implications 」を読んだ
\\begin{itemize}
\\item 主に CS のことにしか触れられていなかったため期待外れであった
\\end{itemize}
\\item 
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-1-2]{モデル化対象のルータ}
\\begin{itemize}
\\item アクセスネットワーク上のソフトウェアルータ
\\begin{itemize}
\\item ICN のパケット処理は複雑であり， IP ルータのようにハードウェア化
するのには時間がかかり，しばらくソフトウェアルータが使われると予
想されるから
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-3]{ルータが満たすべき要件}
\\begin{itemize}
\\item スループットが Gbps を超える
\\begin{itemize}
\\item アクセスネットワークにおける pps がであり，パケットサイズを
1500byte と仮定した時
\\item 
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-4]{ルータのハードウェアの仕様}
\\begin{itemize}
\\item Cisco ASR9000
\\begin{itemize}
\\item CPU: 2 * Intel 2.0GHz 6core Westmere EP (Xeon) (HTT 有)
\\item NIC: 4 * Intel Niantic 10GE interfaces
\\item STORAGE: 3.2TB SSD
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-5]{ルータの設計概要}
\\begin{itemize}
\\item 多くの設計は Cisco が提案しているソフトウェアルータと同様である
\\item 異なる点は次の通りである
\\begin{itemize}
\\item アクティブな CPU コアの数が可変である
\\begin{itemize}
\\item 消費電力を削減できる
\\end{itemize}
\\item FIB の構造に Bloom Filter を採用する
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-6]{FIB の構造}
\\begin{itemize}
\\item Bloom Filter ベースのデータ構造を採用する
\\begin{itemize}
\\item FIB の更新間隔が， BGP と OSPF の更新間隔と同じであると仮定す
ると，更新頻度は高くないため，複数のハッシュ値の計算に費やす
リソースは少なくて済む
\\begin{itemize}
\\item BGP: 経路情報が追加または削除された時
\\item OSPF:リンクのアップダウンがなければ 30 分間隔で更新される (ア
クセスネットワークでは，リンクのアップダウンはそれほど起こ ら
ないのではないかと予想される (要調査))
\\end{itemize}
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-7]{PIT ・ CS の構造}
\\begin{itemize}
\\item 
\\end{itemize}
\\end{frame}


\\begin{frame}[label=sec-1-8]{}
\\end{frame}

\\section{2014 年 7 月 8 日}
\\label{sec-2}
\\begin{frame}[label=sec-2-1]{進捗状況}
\\begin{itemize}
\\item 「 FIA Router: Cost-Effective, Energy-Efficient, and High-Speed
Router for Future Internet Architecture 」を読んだ
\\item パフォーマンスに重点をおいた NDN ルータの設計を行った
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-2-2]{NDN ルータの概要}
\\begin{itemize}
\\item FIB は Bloom Filter (BF) ベースのデータ構造， PIT と CS は統合し普
通の chain ハッシュテーブルで構築
\\begin{itemize}
\\item ハッシュ化する対象は，パケットの full name
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-2-3]{FIB}
\\begin{itemize}
\\item BF ベースのデータ構造を採用する
\\begin{itemize}
\\item 探索がメイン
\\begin{itemize}
\\item デフォルトルートにフォワーディングするパケットが来た時は，該
当エントリが存在しないため，該当エントリがあるかないかがすぐに分かっ
た方がよい
\\end{itemize}
\\item エントリの更新頻度が高くないため，複数のハッシュ値を計算すること
で発生するオーバーヘッドが小さい
\\item 一例として BFAST
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-2-4]{CS ・ PIT}
\\begin{itemize}
\\item 普通の chain ハッシュテーブルで統合して構築
\\begin{itemize}
\\item 探索・エントリの更新・新規エントリの挿入削除のすべてが同程度発生す
る
\\begin{itemize}
\\item ヒットしない時， Interest と Data の往復で，探索が CS2 回
PIT2 回・挿入削除が CS1 回 PIT2 回
\\item エントリの更新頻度が高いため，複数のハッシュ値の計算によるオーバーヘッドが
大きい
\\end{itemize}
\\item どちらも Exact Match (EM)
\\item ルータ中の CS と PIT 内で同一の prefix を持つエントリは存在しえな
いため，統合できる (1bit のフラグを立てるだけでよい)
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-2-5]{PIT (CS) の分割}
\\begin{itemize}
\\item PIT (CS) は M ($>$ N) 個に分割する (N は CPU コアの数)
\\item CPU コアが， PIT にアクセスするときは下記のテーブルを参照してハッ
シュ値に応じた PIT の先頭番地を入手してアクセスする．
\\begin{itemize}
\\item このテーブルはすべての CPU コアがアクセス可能であるとする
\\end{itemize}
\\end{itemize}
\\begin{center}
\\begin{tabular}{ll}
ハッシュ値 mod M & PIT へのポインタ\\\\
\\hline
0 & PIT$[0]$\\\\
1 & PIT$[1]$\\\\
\\ldots{}\\ldots{} & \\\\
M-1 & PIT$[M-1]$\\\\
\\end{tabular}
\\end{center}
\\end{frame}
\\begin{frame}[label=sec-2-6]{Interest 受信時のフロー}
\\begin{enumerate}
\\item Dispatcher が NIC から Interest を受け取り， fullname からハッシュ
値を計算
\\item (ハッシュ値 mod N) に基づいて Interest を，実際に処理を行う CPU コアへと割
り当てする
\\item PIT の探索を行う
\\begin{enumerate}
\\item (ハッシュ値 mod M) を計算し，テーブルを参照することで PIT への
ポインタを入手
\\item PIT へのポインタを通して実際に PIT へアクセスする
\\end{enumerate}
\\item FIB の探索を行う
\\begin{enumerate}
\\item (k-1) 個のハッシュ値を新たに計算し， BFAST の探索方法にしたがっ
て探索
\\end{enumerate}
\\end{enumerate}
\\end{frame}
\\begin{frame}[label=sec-2-7]{Data 受信時のフロー}
\\begin{itemize}
\\item Interest の処理の 1 〜 3 を行う
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-2-8]{}
\\end{frame}
\\section{2014 年 6 月 17 日}
\\label{sec-3}
\\begin{frame}[label=sec-3-1]{進捗状況}
\\begin{itemize}
\\item 「 BFAST: Unified and Scalable Index for NDN Forwarding
Architecture 」を読み，自分のルーティングアルゴリズムに適用させる
方法を考えた
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-3-2]{BFAST: Unified and Scalable Index for NDN Forwarding Architecture の概要}
\\begin{itemize}
\\item FIB ・ PIT ・ CS のエントリを別々に探索するのは時間がかかるので，
これらのテーブルを同時に探索できるような unified index を提案して
いる
\\begin{itemize}
\\item unified index は， 3 つのテーブルと LPM (Longest Prefix Match)
・ EM (Exact Match) をサポートする
\\end{itemize}
\\item unified index のエントリは， CS ・ PIT ・ FIB のエントリへの
pointer と pointer が指すエントリの含まれるテーブルを表す type (CS ・
PIT ・ FIB のいずれか) を持つ
\\end{itemize}
\\centering
\\includegraphics[height=0.5\\textheight]{./figure/overview_unified_index.pdf}
\\end{frame}

\\begin{frame}[label=sec-3-3]{BFAST の提案}
\\begin{itemize}
\\item Unified Index を実現するために BFAST というデータ構造を提案する
\\begin{itemize}
\\item BFAST は， 2 つの Counting Bloom Filter とハッシュテーブルから
構成される
\\end{itemize}
\\end{itemize}
\\centering
\\includegraphics[width=0.7\\linewidth,height=0.7\\textheight]{./figure/bfast_comp.pdf}
\\end{frame}

\\begin{frame}[label=sec-3-4]{補足: (Counting) Bloom Filter}
\\begin{itemize}
\\item Counting Bloom Filter は Bloom Filter の実装の一種で，再生成せずに
要素を削除できるものである． Counting Bloom Filter では，配列の各
要素はビットから n ビットのカウンタに拡張されている．
\\item 要素の追加は各配列要素のインクリメントになり，参照は各配列要素がゼ
ロでないことを確認することになる．削除する場合，対応する配列要素の
カウンタをデクリメントすればよい．
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-3-5]{BFAST の提案までの流れ (1)}
\\begin{enumerate}
\\item 1 つのハッシュ関数にかけたハッシュ値の bucket にエントリを挿入するだ
けだとハッシュテーブルのバランスが悪くなる
\\item バランスを取るために， k 個 (図では k=3) のハッシュ関数にかけて
得られた k 個のハッシュ値のうちエントリ数が最小の bucket にエント
リを挿入することにする
\\item 各 bucket が持つエントリ数を別のテーブル Counter で管理することにする
\\begin{itemize}
\\item エントリ数が最小の bucket を見つけるために，すべての bucket の
エントリを辿らなくてよくなる
\\end{itemize}
\\end{enumerate}
\\centering
\\includegraphics[width=1.0\\linewidth,height=0.4\\textheight]{./figure/bfast_flow.pdf}
\\end{frame}

\\begin{frame}[label=sec-3-6]{BFAST の提案までの流れ (2): Counting Bloom Filter の導入}
\\begin{columns}
\\begin{column}{0.5\\textwidth}
\\begin{block}{概要図}%x
\\centering
\\includegraphics[height=0.4\\textheight]{./figure/hash_table_with_counting_bloom_filter.pdf}
\\begin{itemize}
\\item Counter を Counting Bloom Filter (CBF) にする
\\begin{itemize}
\\item CBF のエントリが 0 ならば，エントリが存在しない事が分かるため高
速で EM ・ LPM が可能
\\end{itemize}
\\end{itemize}
\\end{block}
\\end{column}

\\begin{column}{0.5\\textwidth}
\\begin{block}{挿入アルゴリズム}%x
\\includegraphics[height=0.48\\textheight]{./figure/Algorithm1.pdf}
\\begin{itemize}
\\item k: ハッシュ関数の個数
\\item $f_i$ (): ハッシュ関数
\\item $B_i$: i 番目の bucket
\\item $C_i$: $B_i$ のカウンタ
\\end{itemize}
\\end{block}
\\end{column}
\\end{columns}
\\end{frame}

\\begin{frame}[label=sec-3-7]{BFAST の提案までの流れ (3):}
\\begin{itemize}
\\item 前スライドの構造では，エントリの探索が上手く行かない
\\begin{itemize}
\\item k 個のハッシュ値のうち CBF が最小の bucket に該当するエントリが
あるとは限らないから
\\begin{itemize}
\\item 別のエントリを挿入するときに CBF がインクリメントさせる可能性が
あるから
\\end{itemize}
\\end{itemize}
\\item これを解決するため， auxiliary CBF (aCBF) を導入する
\\begin{itemize}
\\item エントリを挿入する時に，どのハッシュ関数が最小の C\\_i となる i
を導出したかを記録する
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-3-8]{完成版 BFAST}
\\begin{columns}
\\begin{column}{0.5\\textwidth}
\\begin{block}{概要図}%x
\\centering
\\includegraphics[width=.9\\linewidth]{./figure/bfast_comp.pdf}
\\end{block}
\\end{column}

\\begin{column}{0.5\\textwidth}
\\begin{block}{挿入アルゴリズム}%x
\\centering
\\includegraphics[width=0.99\\linewidth,height=0.55\\textheight]{./figure/bfast_insert.pdf}
\\end{block}
\\end{column}
\\end{columns}
\\end{frame}

\\begin{frame}[label=sec-3-9]{BFAST での探索と削除}
\\begin{columns}
\\begin{column}{0.5\\textwidth}
\\begin{block}{探索アルゴリズム}%x
\\centering
\\includegraphics[width=0.99\\linewidth,height=0.55\\textheight]{./figure/bfast_lookup.pdf}
\\begin{itemize}
\\item 探索要素を k 個のハッシュ関数にかけたハッシュ値をインデックスとし
た mCBF の要素に 0 があるならば，要素は存在しない (line 3-5)
\\end{itemize}
\\end{block}
\\end{column}

\\begin{column}{0.5\\textwidth}
\\begin{block}{削除アルゴリズム}%x
\\centering
\\includegraphics[width=0.99\\linewidth,height=0.55\\textheight]{./figure/bfast_delete.pdf}
\\begin{itemize}
\\item mCBF と aCBF の値をデクリメントする操作が抜けてるのでは?
\\end{itemize}
\\end{block}
\\end{column}
\\end{columns}
\\end{frame}

\\begin{frame}[label=sec-3-10]{BFAST における EM と LPM}
\\begin{itemize}
\\item EM は前ページの探索アルゴリズムで行える
\\item LPM は， prefix を fullname から 1 コンポネントずつ短くして EM と同
じ方法で行う
\\end{itemize}
\\centering
\\includegraphics[width=.9\\linewidth]{./figure/LPM.pdf}
\\end{frame}

\\begin{frame}[label=sec-3-11]{BFAST の Scalability と Extensibility}
\\begin{itemize}
\\item BFAST はテーブルを再構築せずに動的に拡張できる
\\begin{itemize}
\\item 格納する要素が増えると探索にかかる時間が増えてしまう
\\begin{itemize}
\\item mCBF の false positive の確率が上昇するため不要な lookup が増
える
\\item ハッシュテーブルのリンクを何度も辿ることになる
\\end{itemize}
\\item これを防ぐために，テーブルのテーブルの再構築を行うと，時間がかかる上
に，通常のパケットフォワーディングを阻害してしまう
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-3-12]{BFAST の拡張}
\\begin{itemize}
\\item BFAST の拡張前後では，異なる aCBF を用いる
\\begin{itemize}
\\item 要素の探索は， aCBF と aCBF'のどちらに要素があるかをチェックし
てから開始する
\\begin{itemize}
\\item ハッシュテーブル (および mCBF) へ要素の挿入位置が拡張前のハッ
シュテーブルの大きさ N と拡張後の N'で異なってくるため
\\end{itemize}
\\end{itemize}
\\end{itemize}

\\centering
\\includegraphics[width=0.8\\linewidth,height=0.6\\textheight]{./figure/extend_bfast.pdf}
\\end{frame}

\\begin{frame}[label=sec-3-13]{BFAST での NDN フォワーディングの全体像}
\\begin{itemize}
\\item prefix 自体は，テーブルエントリだけに格納して， unified index では
signature を用いる
\\begin{itemize}
\\item signature は， prefix をハッシュ関数にかけて生成する
\\begin{itemize}
\\item index のサイズを劇的位に小さく出来る
\\item エラーレートは無視できるほど小さい
\\end{itemize}
\\end{itemize}
\\item PIT と FIB を指す unified index のエントリは face 番号も格納する
\\begin{itemize}
\\item 探索速度向上のため
\\end{itemize}
\\end{itemize}

\\centering
\\includegraphics[width=0.9\\linewidth,height=0.55\\textheight]{./figure/NDN_with_bfast.pdf}
\\end{frame}

\\begin{frame}[label=sec-3-14]{いかにして BFAST を我々の NDN ルータモデルに導入するか}
\\begin{itemize}
\\item 我々の NDN ルータモデルのテーブル集合を BFAST に置きかえるだけでよ
い
\\begin{itemize}
\\item root prefix のハッシュ値で CPU に割り振る
\\begin{itemize}
\\item LPM を行う時に， 1 コンポネントずつ短い prefix を見ていくため，
LPM を同じ CPU で行えるようにしたい
\\end{itemize}
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-3-15]{BFAST と CCNx の比較}
\\begin{itemize}
\\item パフォーマンスに関しては， BFAST の方が圧倒的によさそう
\\begin{itemize}
\\item アルゴリズム的に， CCNx のデータ構造と比べて探索等がすむ
\\item 論文中の評価
\\end{itemize}
\\item メモリ利用量は CCNx の方が少ない
\\begin{itemize}
\\item CCNx が NPHT を使って FIB と PIT をまとめて管理しているからだと
思われる
\\item CCNx は， Android 版があるなどモバイル端末上でも動作することを
考えているようなので，ロースペックな端末でも動作することを設計
方針にしていると予想される
\\end{itemize}
\\end{itemize}
\\begin{table}[htb]
\\caption{メモリ利用量}
\\centering
\\begin{tabular}{lrr}
 & 3MFIB & 10MFIB\\\\
\\hline
BFAST & 149.09 & 539.58\\\\
CCNx & 102.44 & 384.05\\\\
\\end{tabular}
\\end{table}
\\end{frame}

\\begin{frame}[label=sec-3-16]{所感}
\\begin{itemize}
\\item 我々の対象であるソフトウェアルータで使うには， CCNx のデータ構造は不向き
\\begin{itemize}
\\item テーブルの探索時間に時間がかかりすぎているため，パフォーマンス
が低い
\\item メモリは 16G と潤沢にあるので，そんなに省メモリを考える必要はな
い
\\end{itemize}
\\item パフォーマンスと省電力の両方を考慮に入れた NDN ルータを提案するな
らば，データ構造は， BFAST を採用すべきである
\\begin{itemize}
\\item メモリの利用量は電力にほとんど影響しないと予想される
\\end{itemize}
\\end{itemize}
\\end{frame}

\\section{2014 年 6 月 13 日}
\\label{sec-4}
\\begin{frame}[label=sec-4-1]{前回までのミーティングのまとめ}
\\begin{itemize}
\\item 現在は， ICN ルータの省電力化と ICN ネットワーク全体の省電力化を
どちらも考えているので，ルータの省電力化に焦点を当てる
\\item まずは，ルータの FIB ・ PIT ・ CS の構造を考えるため，関連研究の論
文を読む
\\begin{itemize}
\\item 電力効率のよいテーブル構造を議論したい
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-4-2]{進捗状況}
\\begin{itemize}
\\item 「 Scalable NDN Forwarding: Concepts, Issues and Principles 」を読み知
見を得た
\\begin{itemize}
\\item NDN のソフトウェアルータで 1Gbps を達成するためのルータの設計方
針が述べられている
\\end{itemize}
\\item 現在，「 BFAST: Unified and Scalable Index for NDN Forwarding Architecture 」
を読み進めている
\\begin{itemize}
\\item FIB ・ PIT ・ CS のエントリを別々に探索するのは時間がかかるので，
これらのテーブルを同時に探索できるような unified index を提案している
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-4-3]{現在の考えのまとめ}
\\begin{itemize}
\\item name prefix の長さに関わらず を固定長の prefix として扱う手法が必要である
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-4-4]{その他の探索アルゴリズム}
\\begin{itemize}
\\item FIB
\\begin{itemize}
\\item 2-stage LPM (Longest Prefix Match) algorithm
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-4-5]{2-stage LPM algorithm の概要}
\\begin{itemize}
\\item LPM を fullname ではなく，ある長さ $M$ の prefix から開始する
\\begin{itemize}
\\item マッチは fullname よりも大幅に短い prefix で発生しやすい
\\item マッチしなかった時，マッチにかかる時間は最悪となる
\\item LPM にかかる最悪の時間を一定時間以下に保証できる (マッチングする
回数が $M$ 以下のため)
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-4-6]{2-stage LPM algorithm の処理の流れ}
\\begin{enumerate}
\\item LPM を長さ $M$ の prefix から開始する
\\item マッチングなし: LPM 終了
\\item マッチングあり: 最大の長さ $MD$ からマッチするまで繰り返す
\\end{enumerate}
\\end{frame}
% Emacs 24.3.1 (Org mode 8.2.7b)
\\end{document}" #("るため" 0 3 (fontified t)) #("     - 
" 0 5 (fontified t) 5 7 (fontified t) 7 8 (fontified t)) "% Created 2014-07-10 木 21:45
\\documentclass[dvipdfmx,11pt]{beamer}
\\usepackage{url}
\\usepackage{pxjahyper}
\\usetheme{Berlin}
\\setbeamertemplate{navigation symbols}{}
\\beamertemplatetextbibitems
\\setbeamertemplate{footline}[frame number]
\\setbeamertemplate{headline}{}


\\institute[]{Osaka University\\\\
Graduate School of Information Science and Technology \\\\
Information Sharing Platform Laboratory \\\\
Master course second year}
\\usetheme{default}
\\author{大杉 海斗}
\\date{\\today}
\\title{ICN Meeting}
\\hypersetup{
  pdfkeywords={},
  pdfsubject={},
  pdfcreator={Emacs 24.3.1 (Org mode 8.2.7b)}}
\\begin{document}

\\maketitle

\\section{2014 年 7 月 15 日}
\\label{sec-1}
\\begin{frame}[label=sec-1-1]{進捗状況}
\\begin{itemize}
\\item CCN ルータの要件を調査するため，「 On Content-Centric Router Design and Implications 」を読んだ
\\begin{itemize}
\\item 主に CS のことにしか触れられていなかったため期待外れであった
\\end{itemize}
\\item 
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-1-2]{モデル化対象のルータ}
\\begin{itemize}
\\item アクセスネットワーク上のソフトウェアルータ
\\begin{itemize}
\\item ICN のパケット処理は複雑であり， IP ルータのようにハードウェア化
するのには時間がかかり，しばらくソフトウェアルータが使われると予
想されるから
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-3]{ルータが満たすべき要件}
\\begin{itemize}
\\item スループットが Gbps を超える
\\begin{itemize}
\\item アクセスネットワークにおける pps が，であるため
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-4]{ルータのハードウェアの仕様}
\\begin{itemize}
\\item Cisco ASR9000
\\begin{itemize}
\\item CPU: 2 * Intel 2.0GHz 6core Westmere EP (Xeon) (HTT 有)
\\item NIC: 4 * Intel Niantic 10GE interfaces
\\item STORAGE: 3.2TB SSD
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-5]{ルータの設計概要}
\\begin{itemize}
\\item 多くの設計は Cisco が提案しているソフトウェアルータと同様である
\\item 異なる点は次の通りである
\\begin{itemize}
\\item アクティブな CPU コアの数が可変である
\\begin{itemize}
\\item 消費電力を削減できる
\\end{itemize}
\\item FIB の構造に Bloom Filter を採用する
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-6]{FIB の構造}
\\begin{itemize}
\\item Bloom Filter ベースのデータ構造を採用する
\\begin{itemize}
\\item FIB の更新間隔が， BGP と OSPF の更新間隔と同じであると仮定す
ると，更新頻度は高くないため，複数のハッシュ値の計算に費やす
リソースは少なくて済む
\\begin{itemize}
\\item BGP: 経路情報が追加または削除された時
\\item OSPF:リンクのアップダウンがなければ 30 分間隔で更新される (ア
クセスネットワークでは，リンクのアップダウンはそれほど起こ ら
ないのではないかと予想される (要調査))
\\end{itemize}
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-7]{PIT ・ CS の構造}
\\begin{itemize}
\\item 
\\end{itemize}
\\end{frame}


\\begin{frame}[label=sec-1-8]{}
\\end{frame}

\\section{2014 年 7 月 8 日}
\\label{sec-2}
\\begin{frame}[label=sec-2-1]{進捗状況}
\\begin{itemize}
\\item 「 FIA Router: Cost-Effective, Energy-Efficient, and High-Speed
Router for Future Internet Architecture 」を読んだ
\\item パフォーマンスに重点をおいた NDN ルータの設計を行った
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-2-2]{NDN ルータの概要}
\\begin{itemize}
\\item FIB は Bloom Filter (BF) ベースのデータ構造， PIT と CS は統合し普
通の chain ハッシュテーブルで構築
\\begin{itemize}
\\item ハッシュ化する対象は，パケットの full name
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-2-3]{FIB}
\\begin{itemize}
\\item BF ベースのデータ構造を採用する
\\begin{itemize}
\\item 探索がメイン
\\begin{itemize}
\\item デフォルトルートにフォワーディングするパケットが来た時は，該
当エントリが存在しないため，該当エントリがあるかないかがすぐに分かっ
た方がよい
\\end{itemize}
\\item エントリの更新頻度が高くないため，複数のハッシュ値を計算すること
で発生するオーバーヘッドが小さい
\\item 一例として BFAST
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-2-4]{CS ・ PIT}
\\begin{itemize}
\\item 普通の chain ハッシュテーブルで統合して構築
\\begin{itemize}
\\item 探索・エントリの更新・新規エントリの挿入削除のすべてが同程度発生す
る
\\begin{itemize}
\\item ヒットしない時， Interest と Data の往復で，探索が CS2 回
PIT2 回・挿入削除が CS1 回 PIT2 回
\\item エントリの更新頻度が高いため，複数のハッシュ値の計算によるオーバーヘッドが
大きい
\\end{itemize}
\\item どちらも Exact Match (EM)
\\item ルータ中の CS と PIT 内で同一の prefix を持つエントリは存在しえな
いため，統合できる (1bit のフラグを立てるだけでよい)
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-2-5]{PIT (CS) の分割}
\\begin{itemize}
\\item PIT (CS) は M ($>$ N) 個に分割する (N は CPU コアの数)
\\item CPU コアが， PIT にアクセスするときは下記のテーブルを参照してハッ
シュ値に応じた PIT の先頭番地を入手してアクセスする．
\\begin{itemize}
\\item このテーブルはすべての CPU コアがアクセス可能であるとする
\\end{itemize}
\\end{itemize}
\\begin{center}
\\begin{tabular}{ll}
ハッシュ値 mod M & PIT へのポインタ\\\\
\\hline
0 & PIT$[0]$\\\\
1 & PIT$[1]$\\\\
\\ldots{}\\ldots{} & \\\\
M-1 & PIT$[M-1]$\\\\
\\end{tabular}
\\end{center}
\\end{frame}
\\begin{frame}[label=sec-2-6]{Interest 受信時のフロー}
\\begin{enumerate}
\\item Dispatcher が NIC から Interest を受け取り， fullname からハッシュ
値を計算
\\item (ハッシュ値 mod N) に基づいて Interest を，実際に処理を行う CPU コアへと割
り当てする
\\item PIT の探索を行う
\\begin{enumerate}
\\item (ハッシュ値 mod M) を計算し，テーブルを参照することで PIT への
ポインタを入手
\\item PIT へのポインタを通して実際に PIT へアクセスする
\\end{enumerate}
\\item FIB の探索を行う
\\begin{enumerate}
\\item (k-1) 個のハッシュ値を新たに計算し， BFAST の探索方法にしたがっ
て探索
\\end{enumerate}
\\end{enumerate}
\\end{frame}
\\begin{frame}[label=sec-2-7]{Data 受信時のフロー}
\\begin{itemize}
\\item Interest の処理の 1 〜 3 を行う
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-2-8]{}
\\end{frame}
\\section{2014 年 6 月 17 日}
\\label{sec-3}
\\begin{frame}[label=sec-3-1]{進捗状況}
\\begin{itemize}
\\item 「 BFAST: Unified and Scalable Index for NDN Forwarding
Architecture 」を読み，自分のルーティングアルゴリズムに適用させる
方法を考えた
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-3-2]{BFAST: Unified and Scalable Index for NDN Forwarding Architecture の概要}
\\begin{itemize}
\\item FIB ・ PIT ・ CS のエントリを別々に探索するのは時間がかかるので，
これらのテーブルを同時に探索できるような unified index を提案して
いる
\\begin{itemize}
\\item unified index は， 3 つのテーブルと LPM (Longest Prefix Match)
・ EM (Exact Match) をサポートする
\\end{itemize}
\\item unified index のエントリは， CS ・ PIT ・ FIB のエントリへの
pointer と pointer が指すエントリの含まれるテーブルを表す type (CS ・
PIT ・ FIB のいずれか) を持つ
\\end{itemize}
\\centering
\\includegraphics[height=0.5\\textheight]{./figure/overview_unified_index.pdf}
\\end{frame}

\\begin{frame}[label=sec-3-3]{BFAST の提案}
\\begin{itemize}
\\item Unified Index を実現するために BFAST というデータ構造を提案する
\\begin{itemize}
\\item BFAST は， 2 つの Counting Bloom Filter とハッシュテーブルから
構成される
\\end{itemize}
\\end{itemize}
\\centering
\\includegraphics[width=0.7\\linewidth,height=0.7\\textheight]{./figure/bfast_comp.pdf}
\\end{frame}

\\begin{frame}[label=sec-3-4]{補足: (Counting) Bloom Filter}
\\begin{itemize}
\\item Counting Bloom Filter は Bloom Filter の実装の一種で，再生成せずに
要素を削除できるものである． Counting Bloom Filter では，配列の各
要素はビットから n ビットのカウンタに拡張されている．
\\item 要素の追加は各配列要素のインクリメントになり，参照は各配列要素がゼ
ロでないことを確認することになる．削除する場合，対応する配列要素の
カウンタをデクリメントすればよい．
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-3-5]{BFAST の提案までの流れ (1)}
\\begin{enumerate}
\\item 1 つのハッシュ関数にかけたハッシュ値の bucket にエントリを挿入するだ
けだとハッシュテーブルのバランスが悪くなる
\\item バランスを取るために， k 個 (図では k=3) のハッシュ関数にかけて
得られた k 個のハッシュ値のうちエントリ数が最小の bucket にエント
リを挿入することにする
\\item 各 bucket が持つエントリ数を別のテーブル Counter で管理することにする
\\begin{itemize}
\\item エントリ数が最小の bucket を見つけるために，すべての bucket の
エントリを辿らなくてよくなる
\\end{itemize}
\\end{enumerate}
\\centering
\\includegraphics[width=1.0\\linewidth,height=0.4\\textheight]{./figure/bfast_flow.pdf}
\\end{frame}

\\begin{frame}[label=sec-3-6]{BFAST の提案までの流れ (2): Counting Bloom Filter の導入}
\\begin{columns}
\\begin{column}{0.5\\textwidth}
\\begin{block}{概要図}%x
\\centering
\\includegraphics[height=0.4\\textheight]{./figure/hash_table_with_counting_bloom_filter.pdf}
\\begin{itemize}
\\item Counter を Counting Bloom Filter (CBF) にする
\\begin{itemize}
\\item CBF のエントリが 0 ならば，エントリが存在しない事が分かるため高
速で EM ・ LPM が可能
\\end{itemize}
\\end{itemize}
\\end{block}
\\end{column}

\\begin{column}{0.5\\textwidth}
\\begin{block}{挿入アルゴリズム}%x
\\includegraphics[height=0.48\\textheight]{./figure/Algorithm1.pdf}
\\begin{itemize}
\\item k: ハッシュ関数の個数
\\item $f_i$ (): ハッシュ関数
\\item $B_i$: i 番目の bucket
\\item $C_i$: $B_i$ のカウンタ
\\end{itemize}
\\end{block}
\\end{column}
\\end{columns}
\\end{frame}

\\begin{frame}[label=sec-3-7]{BFAST の提案までの流れ (3):}
\\begin{itemize}
\\item 前スライドの構造では，エントリの探索が上手く行かない
\\begin{itemize}
\\item k 個のハッシュ値のうち CBF が最小の bucket に該当するエントリが
あるとは限らないから
\\begin{itemize}
\\item 別のエントリを挿入するときに CBF がインクリメントさせる可能性が
あるから
\\end{itemize}
\\end{itemize}
\\item これを解決するため， auxiliary CBF (aCBF) を導入する
\\begin{itemize}
\\item エントリを挿入する時に，どのハッシュ関数が最小の C\\_i となる i
を導出したかを記録する
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-3-8]{完成版 BFAST}
\\begin{columns}
\\begin{column}{0.5\\textwidth}
\\begin{block}{概要図}%x
\\centering
\\includegraphics[width=.9\\linewidth]{./figure/bfast_comp.pdf}
\\end{block}
\\end{column}

\\begin{column}{0.5\\textwidth}
\\begin{block}{挿入アルゴリズム}%x
\\centering
\\includegraphics[width=0.99\\linewidth,height=0.55\\textheight]{./figure/bfast_insert.pdf}
\\end{block}
\\end{column}
\\end{columns}
\\end{frame}

\\begin{frame}[label=sec-3-9]{BFAST での探索と削除}
\\begin{columns}
\\begin{column}{0.5\\textwidth}
\\begin{block}{探索アルゴリズム}%x
\\centering
\\includegraphics[width=0.99\\linewidth,height=0.55\\textheight]{./figure/bfast_lookup.pdf}
\\begin{itemize}
\\item 探索要素を k 個のハッシュ関数にかけたハッシュ値をインデックスとし
た mCBF の要素に 0 があるならば，要素は存在しない (line 3-5)
\\end{itemize}
\\end{block}
\\end{column}

\\begin{column}{0.5\\textwidth}
\\begin{block}{削除アルゴリズム}%x
\\centering
\\includegraphics[width=0.99\\linewidth,height=0.55\\textheight]{./figure/bfast_delete.pdf}
\\begin{itemize}
\\item mCBF と aCBF の値をデクリメントする操作が抜けてるのでは?
\\end{itemize}
\\end{block}
\\end{column}
\\end{columns}
\\end{frame}

\\begin{frame}[label=sec-3-10]{BFAST における EM と LPM}
\\begin{itemize}
\\item EM は前ページの探索アルゴリズムで行える
\\item LPM は， prefix を fullname から 1 コンポネントずつ短くして EM と同
じ方法で行う
\\end{itemize}
\\centering
\\includegraphics[width=.9\\linewidth]{./figure/LPM.pdf}
\\end{frame}

\\begin{frame}[label=sec-3-11]{BFAST の Scalability と Extensibility}
\\begin{itemize}
\\item BFAST はテーブルを再構築せずに動的に拡張できる
\\begin{itemize}
\\item 格納する要素が増えると探索にかかる時間が増えてしまう
\\begin{itemize}
\\item mCBF の false positive の確率が上昇するため不要な lookup が増
える
\\item ハッシュテーブルのリンクを何度も辿ることになる
\\end{itemize}
\\item これを防ぐために，テーブルのテーブルの再構築を行うと，時間がかかる上
に，通常のパケットフォワーディングを阻害してしまう
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-3-12]{BFAST の拡張}
\\begin{itemize}
\\item BFAST の拡張前後では，異なる aCBF を用いる
\\begin{itemize}
\\item 要素の探索は， aCBF と aCBF'のどちらに要素があるかをチェックし
てから開始する
\\begin{itemize}
\\item ハッシュテーブル (および mCBF) へ要素の挿入位置が拡張前のハッ
シュテーブルの大きさ N と拡張後の N'で異なってくるため
\\end{itemize}
\\end{itemize}
\\end{itemize}

\\centering
\\includegraphics[width=0.8\\linewidth,height=0.6\\textheight]{./figure/extend_bfast.pdf}
\\end{frame}

\\begin{frame}[label=sec-3-13]{BFAST での NDN フォワーディングの全体像}
\\begin{itemize}
\\item prefix 自体は，テーブルエントリだけに格納して， unified index では
signature を用いる
\\begin{itemize}
\\item signature は， prefix をハッシュ関数にかけて生成する
\\begin{itemize}
\\item index のサイズを劇的位に小さく出来る
\\item エラーレートは無視できるほど小さい
\\end{itemize}
\\end{itemize}
\\item PIT と FIB を指す unified index のエントリは face 番号も格納する
\\begin{itemize}
\\item 探索速度向上のため
\\end{itemize}
\\end{itemize}

\\centering
\\includegraphics[width=0.9\\linewidth,height=0.55\\textheight]{./figure/NDN_with_bfast.pdf}
\\end{frame}

\\begin{frame}[label=sec-3-14]{いかにして BFAST を我々の NDN ルータモデルに導入するか}
\\begin{itemize}
\\item 我々の NDN ルータモデルのテーブル集合を BFAST に置きかえるだけでよ
い
\\begin{itemize}
\\item root prefix のハッシュ値で CPU に割り振る
\\begin{itemize}
\\item LPM を行う時に， 1 コンポネントずつ短い prefix を見ていくため，
LPM を同じ CPU で行えるようにしたい
\\end{itemize}
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-3-15]{BFAST と CCNx の比較}
\\begin{itemize}
\\item パフォーマンスに関しては， BFAST の方が圧倒的によさそう
\\begin{itemize}
\\item アルゴリズム的に， CCNx のデータ構造と比べて探索等がすむ
\\item 論文中の評価
\\end{itemize}
\\item メモリ利用量は CCNx の方が少ない
\\begin{itemize}
\\item CCNx が NPHT を使って FIB と PIT をまとめて管理しているからだと
思われる
\\item CCNx は， Android 版があるなどモバイル端末上でも動作することを
考えているようなので，ロースペックな端末でも動作することを設計
方針にしていると予想される
\\end{itemize}
\\end{itemize}
\\begin{table}[htb]
\\caption{メモリ利用量}
\\centering
\\begin{tabular}{lrr}
 & 3MFIB & 10MFIB\\\\
\\hline
BFAST & 149.09 & 539.58\\\\
CCNx & 102.44 & 384.05\\\\
\\end{tabular}
\\end{table}
\\end{frame}

\\begin{frame}[label=sec-3-16]{所感}
\\begin{itemize}
\\item 我々の対象であるソフトウェアルータで使うには， CCNx のデータ構造は不向き
\\begin{itemize}
\\item テーブルの探索時間に時間がかかりすぎているため，パフォーマンス
が低い
\\item メモリは 16G と潤沢にあるので，そんなに省メモリを考える必要はな
い
\\end{itemize}
\\item パフォーマンスと省電力の両方を考慮に入れた NDN ルータを提案するな
らば，データ構造は， BFAST を採用すべきである
\\begin{itemize}
\\item メモリの利用量は電力にほとんど影響しないと予想される
\\end{itemize}
\\end{itemize}
\\end{frame}

\\section{2014 年 6 月 13 日}
\\label{sec-4}
\\begin{frame}[label=sec-4-1]{前回までのミーティングのまとめ}
\\begin{itemize}
\\item 現在は， ICN ルータの省電力化と ICN ネットワーク全体の省電力化を
どちらも考えているので，ルータの省電力化に焦点を当てる
\\item まずは，ルータの FIB ・ PIT ・ CS の構造を考えるため，関連研究の論
文を読む
\\begin{itemize}
\\item 電力効率のよいテーブル構造を議論したい
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-4-2]{進捗状況}
\\begin{itemize}
\\item 「 Scalable NDN Forwarding: Concepts, Issues and Principles 」を読み知
見を得た
\\begin{itemize}
\\item NDN のソフトウェアルータで 1Gbps を達成するためのルータの設計方
針が述べられている
\\end{itemize}
\\item 現在，「 BFAST: Unified and Scalable Index for NDN Forwarding Architecture 」
を読み進めている
\\begin{itemize}
\\item FIB ・ PIT ・ CS のエントリを別々に探索するのは時間がかかるので，
これらのテーブルを同時に探索できるような unified index を提案している
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-4-3]{現在の考えのまとめ}
\\begin{itemize}
\\item name prefix の長さに関わらず を固定長の prefix として扱う手法が必要である
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-4-4]{その他の探索アルゴリズム}
\\begin{itemize}
\\item FIB
\\begin{itemize}
\\item 2-stage LPM (Longest Prefix Match) algorithm
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-4-5]{2-stage LPM algorithm の概要}
\\begin{itemize}
\\item LPM を fullname ではなく，ある長さ $M$ の prefix から開始する
\\begin{itemize}
\\item マッチは fullname よりも大幅に短い prefix で発生しやすい
\\item マッチしなかった時，マッチにかかる時間は最悪となる
\\item LPM にかかる最悪の時間を一定時間以下に保証できる (マッチングする
回数が $M$ 以下のため)
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-4-6]{2-stage LPM algorithm の処理の流れ}
\\begin{enumerate}
\\item LPM を長さ $M$ の prefix から開始する
\\item マッチングなし: LPM 終了
\\item マッチングあり: 最大の長さ $MD$ からマッチするまで繰り返す
\\end{enumerate}
\\end{frame}
% Emacs 24.3.1 (Org mode 8.2.7b)
\\end{document}" #("パケット" 0 4 (fontified t)) #("
" 0 1 (fontified t)) #("

" 0 1 (fontified t) 1 2 (fontified t)) #("       
" 0 7 (fontified t) 7 8 (fontified t)) #("  - 10Gbps を" 0 9 (fontified t) 9 10 (fontified t) 10 11 (fontified t) 11 12 (fontified t)) "% Created 2014-07-10 木 21:41
\\documentclass[dvipdfmx,11pt]{beamer}
\\usepackage{url}
\\usepackage{pxjahyper}
\\usetheme{Berlin}
\\setbeamertemplate{navigation symbols}{}
\\beamertemplatetextbibitems
\\setbeamertemplate{footline}[frame number]
\\setbeamertemplate{headline}{}


\\institute[]{Osaka University\\\\
Graduate School of Information Science and Technology \\\\
Information Sharing Platform Laboratory \\\\
Master course second year}
\\usetheme{default}
\\author{大杉 海斗}
\\date{\\today}
\\title{ICN Meeting}
\\hypersetup{
  pdfkeywords={},
  pdfsubject={},
  pdfcreator={Emacs 24.3.1 (Org mode 8.2.7b)}}
\\begin{document}

\\maketitle

\\section{2014 年 7 月 15 日}
\\label{sec-1}
\\begin{frame}[label=sec-1-1]{進捗状況}
\\begin{itemize}
\\item CCN ルータの要件を調査するため，「 On Content-Centric Router Design and Implications 」を読んだ
\\begin{itemize}
\\item 主に CS のことにしか触れられていなかったため期待外れであった
\\end{itemize}
\\item 
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-1-2]{モデル化対象のルータ}
\\begin{itemize}
\\item アクセスネットワーク上のソフトウェアルータ
\\begin{itemize}
\\item ICN のパケット処理は複雑であり， IP ルータのようにハードウェア化
するのには時間がかかり，しばらくソフトウェアルータが使われると予
想されるから
\\end{itemize}
\\item 10Gbps を
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-3]{ルータが満たすべき要件}
\\begin{itemize}
\\item 
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-4]{ルータのハードウェアの仕様}
\\begin{itemize}
\\item Cisco ASR9000
\\begin{itemize}
\\item CPU: 2 * Intel 2.0GHz 6core Westmere EP (Xeon) (HTT 有)
\\item NIC: 4 * Intel Niantic 10GE interfaces
\\item STORAGE: 3.2TB SSD
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-5]{ルータの設計概要}
\\begin{itemize}
\\item 多くの設計は Cisco が提案しているソフトウェアルータと同様である
\\item 異なる点は次の通りである
\\begin{itemize}
\\item アクティブな CPU コアの数が可変である
\\begin{itemize}
\\item 消費電力を削減できる
\\end{itemize}
\\item FIB の構造に Bloom Filter を採用する
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-6]{FIB の構造}
\\begin{itemize}
\\item Bloom Filter ベースのデータ構造を採用する
\\begin{itemize}
\\item FIB の更新間隔が， BGP と OSPF の更新間隔と同じであると仮定す
ると，更新頻度は高くないため，複数のハッシュ値の計算に費やす
リソースは少なくて済む
\\begin{itemize}
\\item BGP: 経路情報が追加または削除された時
\\item OSPF:リンクのアップダウンがなければ 30 分間隔で更新される (ア
クセスネットワークでは，リンクのアップダウンはそれほど起こ ら
ないのではないかと予想される (要調査))
\\end{itemize}
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-7]{PIT ・ CS の構造}
\\begin{itemize}
\\item 
\\end{itemize}
\\end{frame}


\\begin{frame}[label=sec-1-8]{}
\\end{frame}

\\section{2014 年 7 月 8 日}
\\label{sec-2}
\\begin{frame}[label=sec-2-1]{進捗状況}
\\begin{itemize}
\\item 「 FIA Router: Cost-Effective, Energy-Efficient, and High-Speed
Router for Future Internet Architecture 」を読んだ
\\item パフォーマンスに重点をおいた NDN ルータの設計を行った
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-2-2]{NDN ルータの概要}
\\begin{itemize}
\\item FIB は Bloom Filter (BF) ベースのデータ構造， PIT と CS は統合し普
通の chain ハッシュテーブルで構築
\\begin{itemize}
\\item ハッシュ化する対象は，パケットの full name
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-2-3]{FIB}
\\begin{itemize}
\\item BF ベースのデータ構造を採用する
\\begin{itemize}
\\item 探索がメイン
\\begin{itemize}
\\item デフォルトルートにフォワーディングするパケットが来た時は，該
当エントリが存在しないため，該当エントリがあるかないかがすぐに分かっ
た方がよい
\\end{itemize}
\\item エントリの更新頻度が高くないため，複数のハッシュ値を計算すること
で発生するオーバーヘッドが小さい
\\item 一例として BFAST
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-2-4]{CS ・ PIT}
\\begin{itemize}
\\item 普通の chain ハッシュテーブルで統合して構築
\\begin{itemize}
\\item 探索・エントリの更新・新規エントリの挿入削除のすべてが同程度発生す
る
\\begin{itemize}
\\item ヒットしない時， Interest と Data の往復で，探索が CS2 回
PIT2 回・挿入削除が CS1 回 PIT2 回
\\item エントリの更新頻度が高いため，複数のハッシュ値の計算によるオーバーヘッドが
大きい
\\end{itemize}
\\item どちらも Exact Match (EM)
\\item ルータ中の CS と PIT 内で同一の prefix を持つエントリは存在しえな
いため，統合できる (1bit のフラグを立てるだけでよい)
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-2-5]{PIT (CS) の分割}
\\begin{itemize}
\\item PIT (CS) は M ($>$ N) 個に分割する (N は CPU コアの数)
\\item CPU コアが， PIT にアクセスするときは下記のテーブルを参照してハッ
シュ値に応じた PIT の先頭番地を入手してアクセスする．
\\begin{itemize}
\\item このテーブルはすべての CPU コアがアクセス可能であるとする
\\end{itemize}
\\end{itemize}
\\begin{center}
\\begin{tabular}{ll}
ハッシュ値 mod M & PIT へのポインタ\\\\
\\hline
0 & PIT$[0]$\\\\
1 & PIT$[1]$\\\\
\\ldots{}\\ldots{} & \\\\
M-1 & PIT$[M-1]$\\\\
\\end{tabular}
\\end{center}
\\end{frame}
\\begin{frame}[label=sec-2-6]{Interest 受信時のフロー}
\\begin{enumerate}
\\item Dispatcher が NIC から Interest を受け取り， fullname からハッシュ
値を計算
\\item (ハッシュ値 mod N) に基づいて Interest を，実際に処理を行う CPU コアへと割
り当てする
\\item PIT の探索を行う
\\begin{enumerate}
\\item (ハッシュ値 mod M) を計算し，テーブルを参照することで PIT への
ポインタを入手
\\item PIT へのポインタを通して実際に PIT へアクセスする
\\end{enumerate}
\\item FIB の探索を行う
\\begin{enumerate}
\\item (k-1) 個のハッシュ値を新たに計算し， BFAST の探索方法にしたがっ
て探索
\\end{enumerate}
\\end{enumerate}
\\end{frame}
\\begin{frame}[label=sec-2-7]{Data 受信時のフロー}
\\begin{itemize}
\\item Interest の処理の 1 〜 3 を行う
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-2-8]{}
\\end{frame}
\\section{2014 年 6 月 17 日}
\\label{sec-3}
\\begin{frame}[label=sec-3-1]{進捗状況}
\\begin{itemize}
\\item 「 BFAST: Unified and Scalable Index for NDN Forwarding
Architecture 」を読み，自分のルーティングアルゴリズムに適用させる
方法を考えた
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-3-2]{BFAST: Unified and Scalable Index for NDN Forwarding Architecture の概要}
\\begin{itemize}
\\item FIB ・ PIT ・ CS のエントリを別々に探索するのは時間がかかるので，
これらのテーブルを同時に探索できるような unified index を提案して
いる
\\begin{itemize}
\\item unified index は， 3 つのテーブルと LPM (Longest Prefix Match)
・ EM (Exact Match) をサポートする
\\end{itemize}
\\item unified index のエントリは， CS ・ PIT ・ FIB のエントリへの
pointer と pointer が指すエントリの含まれるテーブルを表す type (CS ・
PIT ・ FIB のいずれか) を持つ
\\end{itemize}
\\centering
\\includegraphics[height=0.5\\textheight]{./figure/overview_unified_index.pdf}
\\end{frame}

\\begin{frame}[label=sec-3-3]{BFAST の提案}
\\begin{itemize}
\\item Unified Index を実現するために BFAST というデータ構造を提案する
\\begin{itemize}
\\item BFAST は， 2 つの Counting Bloom Filter とハッシュテーブルから
構成される
\\end{itemize}
\\end{itemize}
\\centering
\\includegraphics[width=0.7\\linewidth,height=0.7\\textheight]{./figure/bfast_comp.pdf}
\\end{frame}

\\begin{frame}[label=sec-3-4]{補足: (Counting) Bloom Filter}
\\begin{itemize}
\\item Counting Bloom Filter は Bloom Filter の実装の一種で，再生成せずに
要素を削除できるものである． Counting Bloom Filter では，配列の各
要素はビットから n ビットのカウンタに拡張されている．
\\item 要素の追加は各配列要素のインクリメントになり，参照は各配列要素がゼ
ロでないことを確認することになる．削除する場合，対応する配列要素の
カウンタをデクリメントすればよい．
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-3-5]{BFAST の提案までの流れ (1)}
\\begin{enumerate}
\\item 1 つのハッシュ関数にかけたハッシュ値の bucket にエントリを挿入するだ
けだとハッシュテーブルのバランスが悪くなる
\\item バランスを取るために， k 個 (図では k=3) のハッシュ関数にかけて
得られた k 個のハッシュ値のうちエントリ数が最小の bucket にエント
リを挿入することにする
\\item 各 bucket が持つエントリ数を別のテーブル Counter で管理することにする
\\begin{itemize}
\\item エントリ数が最小の bucket を見つけるために，すべての bucket の
エントリを辿らなくてよくなる
\\end{itemize}
\\end{enumerate}
\\centering
\\includegraphics[width=1.0\\linewidth,height=0.4\\textheight]{./figure/bfast_flow.pdf}
\\end{frame}

\\begin{frame}[label=sec-3-6]{BFAST の提案までの流れ (2): Counting Bloom Filter の導入}
\\begin{columns}
\\begin{column}{0.5\\textwidth}
\\begin{block}{概要図}%x
\\centering
\\includegraphics[height=0.4\\textheight]{./figure/hash_table_with_counting_bloom_filter.pdf}
\\begin{itemize}
\\item Counter を Counting Bloom Filter (CBF) にする
\\begin{itemize}
\\item CBF のエントリが 0 ならば，エントリが存在しない事が分かるため高
速で EM ・ LPM が可能
\\end{itemize}
\\end{itemize}
\\end{block}
\\end{column}

\\begin{column}{0.5\\textwidth}
\\begin{block}{挿入アルゴリズム}%x
\\includegraphics[height=0.48\\textheight]{./figure/Algorithm1.pdf}
\\begin{itemize}
\\item k: ハッシュ関数の個数
\\item $f_i$ (): ハッシュ関数
\\item $B_i$: i 番目の bucket
\\item $C_i$: $B_i$ のカウンタ
\\end{itemize}
\\end{block}
\\end{column}
\\end{columns}
\\end{frame}

\\begin{frame}[label=sec-3-7]{BFAST の提案までの流れ (3):}
\\begin{itemize}
\\item 前スライドの構造では，エントリの探索が上手く行かない
\\begin{itemize}
\\item k 個のハッシュ値のうち CBF が最小の bucket に該当するエントリが
あるとは限らないから
\\begin{itemize}
\\item 別のエントリを挿入するときに CBF がインクリメントさせる可能性が
あるから
\\end{itemize}
\\end{itemize}
\\item これを解決するため， auxiliary CBF (aCBF) を導入する
\\begin{itemize}
\\item エントリを挿入する時に，どのハッシュ関数が最小の C\\_i となる i
を導出したかを記録する
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-3-8]{完成版 BFAST}
\\begin{columns}
\\begin{column}{0.5\\textwidth}
\\begin{block}{概要図}%x
\\centering
\\includegraphics[width=.9\\linewidth]{./figure/bfast_comp.pdf}
\\end{block}
\\end{column}

\\begin{column}{0.5\\textwidth}
\\begin{block}{挿入アルゴリズム}%x
\\centering
\\includegraphics[width=0.99\\linewidth,height=0.55\\textheight]{./figure/bfast_insert.pdf}
\\end{block}
\\end{column}
\\end{columns}
\\end{frame}

\\begin{frame}[label=sec-3-9]{BFAST での探索と削除}
\\begin{columns}
\\begin{column}{0.5\\textwidth}
\\begin{block}{探索アルゴリズム}%x
\\centering
\\includegraphics[width=0.99\\linewidth,height=0.55\\textheight]{./figure/bfast_lookup.pdf}
\\begin{itemize}
\\item 探索要素を k 個のハッシュ関数にかけたハッシュ値をインデックスとし
た mCBF の要素に 0 があるならば，要素は存在しない (line 3-5)
\\end{itemize}
\\end{block}
\\end{column}

\\begin{column}{0.5\\textwidth}
\\begin{block}{削除アルゴリズム}%x
\\centering
\\includegraphics[width=0.99\\linewidth,height=0.55\\textheight]{./figure/bfast_delete.pdf}
\\begin{itemize}
\\item mCBF と aCBF の値をデクリメントする操作が抜けてるのでは?
\\end{itemize}
\\end{block}
\\end{column}
\\end{columns}
\\end{frame}

\\begin{frame}[label=sec-3-10]{BFAST における EM と LPM}
\\begin{itemize}
\\item EM は前ページの探索アルゴリズムで行える
\\item LPM は， prefix を fullname から 1 コンポネントずつ短くして EM と同
じ方法で行う
\\end{itemize}
\\centering
\\includegraphics[width=.9\\linewidth]{./figure/LPM.pdf}
\\end{frame}

\\begin{frame}[label=sec-3-11]{BFAST の Scalability と Extensibility}
\\begin{itemize}
\\item BFAST はテーブルを再構築せずに動的に拡張できる
\\begin{itemize}
\\item 格納する要素が増えると探索にかかる時間が増えてしまう
\\begin{itemize}
\\item mCBF の false positive の確率が上昇するため不要な lookup が増
える
\\item ハッシュテーブルのリンクを何度も辿ることになる
\\end{itemize}
\\item これを防ぐために，テーブルのテーブルの再構築を行うと，時間がかかる上
に，通常のパケットフォワーディングを阻害してしまう
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-3-12]{BFAST の拡張}
\\begin{itemize}
\\item BFAST の拡張前後では，異なる aCBF を用いる
\\begin{itemize}
\\item 要素の探索は， aCBF と aCBF'のどちらに要素があるかをチェックし
てから開始する
\\begin{itemize}
\\item ハッシュテーブル (および mCBF) へ要素の挿入位置が拡張前のハッ
シュテーブルの大きさ N と拡張後の N'で異なってくるため
\\end{itemize}
\\end{itemize}
\\end{itemize}

\\centering
\\includegraphics[width=0.8\\linewidth,height=0.6\\textheight]{./figure/extend_bfast.pdf}
\\end{frame}

\\begin{frame}[label=sec-3-13]{BFAST での NDN フォワーディングの全体像}
\\begin{itemize}
\\item prefix 自体は，テーブルエントリだけに格納して， unified index では
signature を用いる
\\begin{itemize}
\\item signature は， prefix をハッシュ関数にかけて生成する
\\begin{itemize}
\\item index のサイズを劇的位に小さく出来る
\\item エラーレートは無視できるほど小さい
\\end{itemize}
\\end{itemize}
\\item PIT と FIB を指す unified index のエントリは face 番号も格納する
\\begin{itemize}
\\item 探索速度向上のため
\\end{itemize}
\\end{itemize}

\\centering
\\includegraphics[width=0.9\\linewidth,height=0.55\\textheight]{./figure/NDN_with_bfast.pdf}
\\end{frame}

\\begin{frame}[label=sec-3-14]{いかにして BFAST を我々の NDN ルータモデルに導入するか}
\\begin{itemize}
\\item 我々の NDN ルータモデルのテーブル集合を BFAST に置きかえるだけでよ
い
\\begin{itemize}
\\item root prefix のハッシュ値で CPU に割り振る
\\begin{itemize}
\\item LPM を行う時に， 1 コンポネントずつ短い prefix を見ていくため，
LPM を同じ CPU で行えるようにしたい
\\end{itemize}
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-3-15]{BFAST と CCNx の比較}
\\begin{itemize}
\\item パフォーマンスに関しては， BFAST の方が圧倒的によさそう
\\begin{itemize}
\\item アルゴリズム的に， CCNx のデータ構造と比べて探索等がすむ
\\item 論文中の評価
\\end{itemize}
\\item メモリ利用量は CCNx の方が少ない
\\begin{itemize}
\\item CCNx が NPHT を使って FIB と PIT をまとめて管理しているからだと
思われる
\\item CCNx は， Android 版があるなどモバイル端末上でも動作することを
考えているようなので，ロースペックな端末でも動作することを設計
方針にしていると予想される
\\end{itemize}
\\end{itemize}
\\begin{table}[htb]
\\caption{メモリ利用量}
\\centering
\\begin{tabular}{lrr}
 & 3MFIB & 10MFIB\\\\
\\hline
BFAST & 149.09 & 539.58\\\\
CCNx & 102.44 & 384.05\\\\
\\end{tabular}
\\end{table}
\\end{frame}

\\begin{frame}[label=sec-3-16]{所感}
\\begin{itemize}
\\item 我々の対象であるソフトウェアルータで使うには， CCNx のデータ構造は不向き
\\begin{itemize}
\\item テーブルの探索時間に時間がかかりすぎているため，パフォーマンス
が低い
\\item メモリは 16G と潤沢にあるので，そんなに省メモリを考える必要はな
い
\\end{itemize}
\\item パフォーマンスと省電力の両方を考慮に入れた NDN ルータを提案するな
らば，データ構造は， BFAST を採用すべきである
\\begin{itemize}
\\item メモリの利用量は電力にほとんど影響しないと予想される
\\end{itemize}
\\end{itemize}
\\end{frame}

\\section{2014 年 6 月 13 日}
\\label{sec-4}
\\begin{frame}[label=sec-4-1]{前回までのミーティングのまとめ}
\\begin{itemize}
\\item 現在は， ICN ルータの省電力化と ICN ネットワーク全体の省電力化を
どちらも考えているので，ルータの省電力化に焦点を当てる
\\item まずは，ルータの FIB ・ PIT ・ CS の構造を考えるため，関連研究の論
文を読む
\\begin{itemize}
\\item 電力効率のよいテーブル構造を議論したい
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-4-2]{進捗状況}
\\begin{itemize}
\\item 「 Scalable NDN Forwarding: Concepts, Issues and Principles 」を読み知
見を得た
\\begin{itemize}
\\item NDN のソフトウェアルータで 1Gbps を達成するためのルータの設計方
針が述べられている
\\end{itemize}
\\item 現在，「 BFAST: Unified and Scalable Index for NDN Forwarding Architecture 」
を読み進めている
\\begin{itemize}
\\item FIB ・ PIT ・ CS のエントリを別々に探索するのは時間がかかるので，
これらのテーブルを同時に探索できるような unified index を提案している
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-4-3]{現在の考えのまとめ}
\\begin{itemize}
\\item name prefix の長さに関わらず を固定長の prefix として扱う手法が必要である
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-4-4]{その他の探索アルゴリズム}
\\begin{itemize}
\\item FIB
\\begin{itemize}
\\item 2-stage LPM (Longest Prefix Match) algorithm
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-4-5]{2-stage LPM algorithm の概要}
\\begin{itemize}
\\item LPM を fullname ではなく，ある長さ $M$ の prefix から開始する
\\begin{itemize}
\\item マッチは fullname よりも大幅に短い prefix で発生しやすい
\\item マッチしなかった時，マッチにかかる時間は最悪となる
\\item LPM にかかる最悪の時間を一定時間以下に保証できる (マッチングする
回数が $M$ 以下のため)
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-4-6]{2-stage LPM algorithm の処理の流れ}
\\begin{enumerate}
\\item LPM を長さ $M$ の prefix から開始する
\\item マッチングなし: LPM 終了
\\item マッチングあり: 最大の長さ $MD$ からマッチするまで繰り返す
\\end{enumerate}
\\end{frame}
% Emacs 24.3.1 (Org mode 8.2.7b)
\\end{document}" "% Created 2014-07-10 木 21:40
\\documentclass[dvipdfmx,11pt]{beamer}
\\usepackage{url}
\\usepackage{pxjahyper}
\\usetheme{Berlin}
\\setbeamertemplate{navigation symbols}{}
\\beamertemplatetextbibitems
\\setbeamertemplate{footline}[frame number]
\\setbeamertemplate{headline}{}


\\institute[]{Osaka University\\\\
Graduate School of Information Science and Technology \\\\
Information Sharing Platform Laboratory \\\\
Master course second year}
\\usetheme{default}
\\author{大杉 海斗}
\\date{\\today}
\\title{ICN Meeting}
\\hypersetup{
  pdfkeywords={},
  pdfsubject={},
  pdfcreator={Emacs 24.3.1 (Org mode 8.2.7b)}}
\\begin{document}

\\maketitle

\\section{2014 年 7 月 15 日}
\\label{sec-1}
\\begin{frame}[label=sec-1-1]{進捗状況}
\\begin{itemize}
\\item CCN ルータの要件を調査するため，「 On Content-Centric Router Design and Implications 」を読んだ
\\begin{itemize}
\\item 主に CS のことにしか触れられていなかったため期待外れであった
\\end{itemize}
\\item 
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-2]{モデル化対象のルータ}
\\begin{itemize}
\\item アクセスネットワーク上のソフトウェアルータ
\\begin{itemize}
\\item ICN のパケット処理は複雑であり， IP ルータのようにハードウェア化
するのには時間がかかり，しばらくソフトウェアルータが使われると予
想されるから
\\item 
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-3]{ルータが満たすべき要件}
\\begin{itemize}
\\item 
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-4]{ルータのハードウェアの仕様}
\\begin{itemize}
\\item Cisco ASR9000
\\begin{itemize}
\\item CPU: 2 * Intel 2.0GHz 6core Westmere EP (Xeon) (HTT 有)
\\item NIC: 4 * Intel Niantic 10GE interfaces
\\item STORAGE: 3.2TB SSD
\\end{itemize}
\\end{itemize}
\\end{frame}


\\begin{frame}[label=sec-1-5]{ルータの設計概要}
\\begin{itemize}
\\item 多くの設計は Cisco が提案しているソフトウェアルータと同様である
\\item 異なる点は次の通りである
\\begin{itemize}
\\item アクティブな CPU コアの数が可変である
\\begin{itemize}
\\item 消費電力を削減できる
\\end{itemize}
\\item FIB の構造に Bloom Filter を採用する
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-6]{FIB の構造}
\\begin{itemize}
\\item Bloom Filter ベースのデータ構造を採用する
\\begin{itemize}
\\item FIB の更新間隔が， BGP と OSPF の更新間隔と同じであると仮定す
ると，更新頻度は高くないため，複数のハッシュ値の計算に費やす
リソースは少なくて済む
\\begin{itemize}
\\item BGP: 経路情報が追加または削除された時
\\item OSPF:リンクのアップダウンがなければ 30 分間隔で更新される (ア
クセスネットワークでは，リンクのアップダウンはそれほど起こ ら
ないのではないかと予想される (要調査))
\\end{itemize}
\\end{itemize}
\\end{itemize}
\\end{frame}


\\begin{frame}[label=sec-1-7]{PIT ・ CS の構造}
\\begin{itemize}
\\item 
\\end{itemize}
\\end{frame}



\\begin{frame}[label=sec-1-8]{}
\\end{frame}

\\section{2014 年 7 月 8 日}
\\label{sec-2}
\\begin{frame}[label=sec-2-1]{進捗状況}
\\begin{itemize}
\\item 「 FIA Router: Cost-Effective, Energy-Efficient, and High-Speed
Router for Future Internet Architecture 」を読んだ
\\item パフォーマンスに重点をおいた NDN ルータの設計を行った
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-2-2]{NDN ルータの概要}
\\begin{itemize}
\\item FIB は Bloom Filter (BF) ベースのデータ構造， PIT と CS は統合し普
通の chain ハッシュテーブルで構築
\\begin{itemize}
\\item ハッシュ化する対象は，パケットの full name
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-2-3]{FIB}
\\begin{itemize}
\\item BF ベースのデータ構造を採用する
\\begin{itemize}
\\item 探索がメイン
\\begin{itemize}
\\item デフォルトルートにフォワーディングするパケットが来た時は，該
当エントリが存在しないため，該当エントリがあるかないかがすぐに分かっ
た方がよい
\\end{itemize}
\\item エントリの更新頻度が高くないため，複数のハッシュ値を計算すること
で発生するオーバーヘッドが小さい
\\item 一例として BFAST
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-2-4]{CS ・ PIT}
\\begin{itemize}
\\item 普通の chain ハッシュテーブルで統合して構築
\\begin{itemize}
\\item 探索・エントリの更新・新規エントリの挿入削除のすべてが同程度発生す
る
\\begin{itemize}
\\item ヒットしない時， Interest と Data の往復で，探索が CS2 回
PIT2 回・挿入削除が CS1 回 PIT2 回
\\item エントリの更新頻度が高いため，複数のハッシュ値の計算によるオーバーヘッドが
大きい
\\end{itemize}
\\item どちらも Exact Match (EM)
\\item ルータ中の CS と PIT 内で同一の prefix を持つエントリは存在しえな
いため，統合できる (1bit のフラグを立てるだけでよい)
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-2-5]{PIT (CS) の分割}
\\begin{itemize}
\\item PIT (CS) は M ($>$ N) 個に分割する (N は CPU コアの数)
\\item CPU コアが， PIT にアクセスするときは下記のテーブルを参照してハッ
シュ値に応じた PIT の先頭番地を入手してアクセスする．
\\begin{itemize}
\\item このテーブルはすべての CPU コアがアクセス可能であるとする
\\end{itemize}
\\end{itemize}
\\begin{center}
\\begin{tabular}{ll}
ハッシュ値 mod M & PIT へのポインタ\\\\
\\hline
0 & PIT$[0]$\\\\
1 & PIT$[1]$\\\\
\\ldots{}\\ldots{} & \\\\
M-1 & PIT$[M-1]$\\\\
\\end{tabular}
\\end{center}
\\end{frame}
\\begin{frame}[label=sec-2-6]{Interest 受信時のフロー}
\\begin{enumerate}
\\item Dispatcher が NIC から Interest を受け取り， fullname からハッシュ
値を計算
\\item (ハッシュ値 mod N) に基づいて Interest を，実際に処理を行う CPU コアへと割
り当てする
\\item PIT の探索を行う
\\begin{enumerate}
\\item (ハッシュ値 mod M) を計算し，テーブルを参照することで PIT への
ポインタを入手
\\item PIT へのポインタを通して実際に PIT へアクセスする
\\end{enumerate}
\\item FIB の探索を行う
\\begin{enumerate}
\\item (k-1) 個のハッシュ値を新たに計算し， BFAST の探索方法にしたがっ
て探索
\\end{enumerate}
\\end{enumerate}
\\end{frame}
\\begin{frame}[label=sec-2-7]{Data 受信時のフロー}
\\begin{itemize}
\\item Interest の処理の 1 〜 3 を行う
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-2-8]{}
\\end{frame}
\\section{2014 年 6 月 17 日}
\\label{sec-3}
\\begin{frame}[label=sec-3-1]{進捗状況}
\\begin{itemize}
\\item 「 BFAST: Unified and Scalable Index for NDN Forwarding
Architecture 」を読み，自分のルーティングアルゴリズムに適用させる
方法を考えた
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-3-2]{BFAST: Unified and Scalable Index for NDN Forwarding Architecture の概要}
\\begin{itemize}
\\item FIB ・ PIT ・ CS のエントリを別々に探索するのは時間がかかるので，
これらのテーブルを同時に探索できるような unified index を提案して
いる
\\begin{itemize}
\\item unified index は， 3 つのテーブルと LPM (Longest Prefix Match)
・ EM (Exact Match) をサポートする
\\end{itemize}
\\item unified index のエントリは， CS ・ PIT ・ FIB のエントリへの
pointer と pointer が指すエントリの含まれるテーブルを表す type (CS ・
PIT ・ FIB のいずれか) を持つ
\\end{itemize}
\\centering
\\includegraphics[height=0.5\\textheight]{./figure/overview_unified_index.pdf}
\\end{frame}

\\begin{frame}[label=sec-3-3]{BFAST の提案}
\\begin{itemize}
\\item Unified Index を実現するために BFAST というデータ構造を提案する
\\begin{itemize}
\\item BFAST は， 2 つの Counting Bloom Filter とハッシュテーブルから
構成される
\\end{itemize}
\\end{itemize}
\\centering
\\includegraphics[width=0.7\\linewidth,height=0.7\\textheight]{./figure/bfast_comp.pdf}
\\end{frame}

\\begin{frame}[label=sec-3-4]{補足: (Counting) Bloom Filter}
\\begin{itemize}
\\item Counting Bloom Filter は Bloom Filter の実装の一種で，再生成せずに
要素を削除できるものである． Counting Bloom Filter では，配列の各
要素はビットから n ビットのカウンタに拡張されている．
\\item 要素の追加は各配列要素のインクリメントになり，参照は各配列要素がゼ
ロでないことを確認することになる．削除する場合，対応する配列要素の
カウンタをデクリメントすればよい．
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-3-5]{BFAST の提案までの流れ (1)}
\\begin{enumerate}
\\item 1 つのハッシュ関数にかけたハッシュ値の bucket にエントリを挿入するだ
けだとハッシュテーブルのバランスが悪くなる
\\item バランスを取るために， k 個 (図では k=3) のハッシュ関数にかけて
得られた k 個のハッシュ値のうちエントリ数が最小の bucket にエント
リを挿入することにする
\\item 各 bucket が持つエントリ数を別のテーブル Counter で管理することにする
\\begin{itemize}
\\item エントリ数が最小の bucket を見つけるために，すべての bucket の
エントリを辿らなくてよくなる
\\end{itemize}
\\end{enumerate}
\\centering
\\includegraphics[width=1.0\\linewidth,height=0.4\\textheight]{./figure/bfast_flow.pdf}
\\end{frame}

\\begin{frame}[label=sec-3-6]{BFAST の提案までの流れ (2): Counting Bloom Filter の導入}
\\begin{columns}
\\begin{column}{0.5\\textwidth}
\\begin{block}{概要図}%x
\\centering
\\includegraphics[height=0.4\\textheight]{./figure/hash_table_with_counting_bloom_filter.pdf}
\\begin{itemize}
\\item Counter を Counting Bloom Filter (CBF) にする
\\begin{itemize}
\\item CBF のエントリが 0 ならば，エントリが存在しない事が分かるため高
速で EM ・ LPM が可能
\\end{itemize}
\\end{itemize}
\\end{block}
\\end{column}

\\begin{column}{0.5\\textwidth}
\\begin{block}{挿入アルゴリズム}%x
\\includegraphics[height=0.48\\textheight]{./figure/Algorithm1.pdf}
\\begin{itemize}
\\item k: ハッシュ関数の個数
\\item $f_i$ (): ハッシュ関数
\\item $B_i$: i 番目の bucket
\\item $C_i$: $B_i$ のカウンタ
\\end{itemize}
\\end{block}
\\end{column}
\\end{columns}
\\end{frame}

\\begin{frame}[label=sec-3-7]{BFAST の提案までの流れ (3):}
\\begin{itemize}
\\item 前スライドの構造では，エントリの探索が上手く行かない
\\begin{itemize}
\\item k 個のハッシュ値のうち CBF が最小の bucket に該当するエントリが
あるとは限らないから
\\begin{itemize}
\\item 別のエントリを挿入するときに CBF がインクリメントさせる可能性が
あるから
\\end{itemize}
\\end{itemize}
\\item これを解決するため， auxiliary CBF (aCBF) を導入する
\\begin{itemize}
\\item エントリを挿入する時に，どのハッシュ関数が最小の C\\_i となる i
を導出したかを記録する
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-3-8]{完成版 BFAST}
\\begin{columns}
\\begin{column}{0.5\\textwidth}
\\begin{block}{概要図}%x
\\centering
\\includegraphics[width=.9\\linewidth]{./figure/bfast_comp.pdf}
\\end{block}
\\end{column}

\\begin{column}{0.5\\textwidth}
\\begin{block}{挿入アルゴリズム}%x
\\centering
\\includegraphics[width=0.99\\linewidth,height=0.55\\textheight]{./figure/bfast_insert.pdf}
\\end{block}
\\end{column}
\\end{columns}
\\end{frame}

\\begin{frame}[label=sec-3-9]{BFAST での探索と削除}
\\begin{columns}
\\begin{column}{0.5\\textwidth}
\\begin{block}{探索アルゴリズム}%x
\\centering
\\includegraphics[width=0.99\\linewidth,height=0.55\\textheight]{./figure/bfast_lookup.pdf}
\\begin{itemize}
\\item 探索要素を k 個のハッシュ関数にかけたハッシュ値をインデックスとし
た mCBF の要素に 0 があるならば，要素は存在しない (line 3-5)
\\end{itemize}
\\end{block}
\\end{column}

\\begin{column}{0.5\\textwidth}
\\begin{block}{削除アルゴリズム}%x
\\centering
\\includegraphics[width=0.99\\linewidth,height=0.55\\textheight]{./figure/bfast_delete.pdf}
\\begin{itemize}
\\item mCBF と aCBF の値をデクリメントする操作が抜けてるのでは?
\\end{itemize}
\\end{block}
\\end{column}
\\end{columns}
\\end{frame}

\\begin{frame}[label=sec-3-10]{BFAST における EM と LPM}
\\begin{itemize}
\\item EM は前ページの探索アルゴリズムで行える
\\item LPM は， prefix を fullname から 1 コンポネントずつ短くして EM と同
じ方法で行う
\\end{itemize}
\\centering
\\includegraphics[width=.9\\linewidth]{./figure/LPM.pdf}
\\end{frame}

\\begin{frame}[label=sec-3-11]{BFAST の Scalability と Extensibility}
\\begin{itemize}
\\item BFAST はテーブルを再構築せずに動的に拡張できる
\\begin{itemize}
\\item 格納する要素が増えると探索にかかる時間が増えてしまう
\\begin{itemize}
\\item mCBF の false positive の確率が上昇するため不要な lookup が増
える
\\item ハッシュテーブルのリンクを何度も辿ることになる
\\end{itemize}
\\item これを防ぐために，テーブルのテーブルの再構築を行うと，時間がかかる上
に，通常のパケットフォワーディングを阻害してしまう
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-3-12]{BFAST の拡張}
\\begin{itemize}
\\item BFAST の拡張前後では，異なる aCBF を用いる
\\begin{itemize}
\\item 要素の探索は， aCBF と aCBF'のどちらに要素があるかをチェックし
てから開始する
\\begin{itemize}
\\item ハッシュテーブル (および mCBF) へ要素の挿入位置が拡張前のハッ
シュテーブルの大きさ N と拡張後の N'で異なってくるため
\\end{itemize}
\\end{itemize}
\\end{itemize}

\\centering
\\includegraphics[width=0.8\\linewidth,height=0.6\\textheight]{./figure/extend_bfast.pdf}
\\end{frame}

\\begin{frame}[label=sec-3-13]{BFAST での NDN フォワーディングの全体像}
\\begin{itemize}
\\item prefix 自体は，テーブルエントリだけに格納して， unified index では
signature を用いる
\\begin{itemize}
\\item signature は， prefix をハッシュ関数にかけて生成する
\\begin{itemize}
\\item index のサイズを劇的位に小さく出来る
\\item エラーレートは無視できるほど小さい
\\end{itemize}
\\end{itemize}
\\item PIT と FIB を指す unified index のエントリは face 番号も格納する
\\begin{itemize}
\\item 探索速度向上のため
\\end{itemize}
\\end{itemize}

\\centering
\\includegraphics[width=0.9\\linewidth,height=0.55\\textheight]{./figure/NDN_with_bfast.pdf}
\\end{frame}

\\begin{frame}[label=sec-3-14]{いかにして BFAST を我々の NDN ルータモデルに導入するか}
\\begin{itemize}
\\item 我々の NDN ルータモデルのテーブル集合を BFAST に置きかえるだけでよ
い
\\begin{itemize}
\\item root prefix のハッシュ値で CPU に割り振る
\\begin{itemize}
\\item LPM を行う時に， 1 コンポネントずつ短い prefix を見ていくため，
LPM を同じ CPU で行えるようにしたい
\\end{itemize}
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-3-15]{BFAST と CCNx の比較}
\\begin{itemize}
\\item パフォーマンスに関しては， BFAST の方が圧倒的によさそう
\\begin{itemize}
\\item アルゴリズム的に， CCNx のデータ構造と比べて探索等がすむ
\\item 論文中の評価
\\end{itemize}
\\item メモリ利用量は CCNx の方が少ない
\\begin{itemize}
\\item CCNx が NPHT を使って FIB と PIT をまとめて管理しているからだと
思われる
\\item CCNx は， Android 版があるなどモバイル端末上でも動作することを
考えているようなので，ロースペックな端末でも動作することを設計
方針にしていると予想される
\\end{itemize}
\\end{itemize}
\\begin{table}[htb]
\\caption{メモリ利用量}
\\centering
\\begin{tabular}{lrr}
 & 3MFIB & 10MFIB\\\\
\\hline
BFAST & 149.09 & 539.58\\\\
CCNx & 102.44 & 384.05\\\\
\\end{tabular}
\\end{table}
\\end{frame}

\\begin{frame}[label=sec-3-16]{所感}
\\begin{itemize}
\\item 我々の対象であるソフトウェアルータで使うには， CCNx のデータ構造は不向き
\\begin{itemize}
\\item テーブルの探索時間に時間がかかりすぎているため，パフォーマンス
が低い
\\item メモリは 16G と潤沢にあるので，そんなに省メモリを考える必要はな
い
\\end{itemize}
\\item パフォーマンスと省電力の両方を考慮に入れた NDN ルータを提案するな
らば，データ構造は， BFAST を採用すべきである
\\begin{itemize}
\\item メモリの利用量は電力にほとんど影響しないと予想される
\\end{itemize}
\\end{itemize}
\\end{frame}

\\section{2014 年 6 月 13 日}
\\label{sec-4}
\\begin{frame}[label=sec-4-1]{前回までのミーティングのまとめ}
\\begin{itemize}
\\item 現在は， ICN ルータの省電力化と ICN ネットワーク全体の省電力化を
どちらも考えているので，ルータの省電力化に焦点を当てる
\\item まずは，ルータの FIB ・ PIT ・ CS の構造を考えるため，関連研究の論
文を読む
\\begin{itemize}
\\item 電力効率のよいテーブル構造を議論したい
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-4-2]{進捗状況}
\\begin{itemize}
\\item 「 Scalable NDN Forwarding: Concepts, Issues and Principles 」を読み知
見を得た
\\begin{itemize}
\\item NDN のソフトウェアルータで 1Gbps を達成するためのルータの設計方
針が述べられている
\\end{itemize}
\\item 現在，「 BFAST: Unified and Scalable Index for NDN Forwarding Architecture 」
を読み進めている
\\begin{itemize}
\\item FIB ・ PIT ・ CS のエントリを別々に探索するのは時間がかかるので，
これらのテーブルを同時に探索できるような unified index を提案している
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-4-3]{現在の考えのまとめ}
\\begin{itemize}
\\item name prefix の長さに関わらず を固定長の prefix として扱う手法が必要である
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-4-4]{その他の探索アルゴリズム}
\\begin{itemize}
\\item FIB
\\begin{itemize}
\\item 2-stage LPM (Longest Prefix Match) algorithm
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-4-5]{2-stage LPM algorithm の概要}
\\begin{itemize}
\\item LPM を fullname ではなく，ある長さ $M$ の prefix から開始する
\\begin{itemize}
\\item マッチは fullname よりも大幅に短い prefix で発生しやすい
\\item マッチしなかった時，マッチにかかる時間は最悪となる
\\item LPM にかかる最悪の時間を一定時間以下に保証できる (マッチングする
回数が $M$ 以下のため)
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-4-6]{2-stage LPM algorithm の処理の流れ}
\\begin{enumerate}
\\item LPM を長さ $M$ の prefix から開始する
\\item マッチングなし: LPM 終了
\\item マッチングあり: 最大の長さ $MD$ からマッチするまで繰り返す
\\end{enumerate}
\\end{frame}
% Emacs 24.3.1 (Org mode 8.2.7b)
\\end{document}" #("はずれであった" 0 7 (fontified t)) "% Created 2014-07-10 木 20:00
\\documentclass[dvipdfmx,11pt]{beamer}
\\usepackage{url}
\\usepackage{pxjahyper}
\\usetheme{Berlin}
\\setbeamertemplate{navigation symbols}{}
\\beamertemplatetextbibitems
\\setbeamertemplate{footline}[frame number]
\\setbeamertemplate{headline}{}


\\institute[]{Osaka University\\\\
Graduate School of Information Science and Technology \\\\
Information Sharing Platform Laboratory \\\\
Master course second year}
\\usetheme{default}
\\author{大杉 海斗}
\\date{\\today}
\\title{ICN Meeting}
\\hypersetup{
  pdfkeywords={},
  pdfsubject={},
  pdfcreator={Emacs 24.3.1 (Org mode 8.2.7b)}}
\\begin{document}

\\maketitle

\\section{2014 年 7 月 15 日}
\\label{sec-1}
\\begin{frame}[label=sec-1-1]{進捗状況}
\\begin{itemize}
\\item CCN ルータの要件を調査するため，「 On Content-Centric Router Design and Implications 」を読んだ
\\item 
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-2]{モデル化対象のルータ}
\\begin{itemize}
\\item アクセスネットワーク上のソフトウェアルータ
\\begin{itemize}
\\item ICN のパケット処理は複雑であり， IP ルータのようにハードウェア化
するのには時間がかかり，しばらくソフトウェアルータが使われると予
想されるから
\\item 
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-3]{ルータが満たすべき要件}
\\begin{itemize}
\\item 
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-4]{ルータのハードウェアの仕様}
\\begin{itemize}
\\item Cisco ASR9000
\\begin{itemize}
\\item CPU: 2 * Intel 2.0GHz 6core Westmere EP (Xeon) (HTT 有)
\\item NIC: 4 * Intel Niantic 10GE interfaces
\\item STORAGE: 3.2TB SSD
\\end{itemize}
\\end{itemize}
\\end{frame}


\\begin{frame}[label=sec-1-5]{ルータの設計概要}
\\begin{itemize}
\\item 多くの設計は Cisco が提案しているソフトウェアルータと同様である
\\item 異なる点は次の通りである
\\begin{itemize}
\\item アクティブな CPU コアの数が可変である
\\begin{itemize}
\\item 消費電力を削減できる
\\end{itemize}
\\item FIB の構造に Bloom Filter を採用する
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-6]{FIB の構造}
\\begin{itemize}
\\item Bloom Filter ベースのデータ構造を採用する
\\begin{itemize}
\\item FIB の更新間隔が， BGP と OSPF の更新間隔と同じであると仮定す
ると，更新頻度は高くないため，複数のハッシュ値の計算に費やす
リソースは少なくて済む
\\begin{itemize}
\\item BGP: 経路情報が追加または削除された時
\\item OSPF:リンクのアップダウンがなければ 30 分間隔で更新される (ア
クセスネットワークでは，リンクのアップダウンはそれほど起こ ら
ないのではないかと予想される (要調査))
\\end{itemize}
\\end{itemize}
\\end{itemize}
\\end{frame}


\\begin{frame}[label=sec-1-7]{PIT ・ CS の構造}
\\begin{itemize}
\\item 
\\end{itemize}
\\end{frame}



\\begin{frame}[label=sec-1-8]{}
\\end{frame}

\\section{2014 年 7 月 8 日}
\\label{sec-2}
\\begin{frame}[label=sec-2-1]{進捗状況}
\\begin{itemize}
\\item 「 FIA Router: Cost-Effective, Energy-Efficient, and High-Speed
Router for Future Internet Architecture 」を読んだ
\\item パフォーマンスに重点をおいた NDN ルータの設計を行った
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-2-2]{NDN ルータの概要}
\\begin{itemize}
\\item FIB は Bloom Filter (BF) ベースのデータ構造， PIT と CS は統合し普
通の chain ハッシュテーブルで構築
\\begin{itemize}
\\item ハッシュ化する対象は，パケットの full name
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-2-3]{FIB}
\\begin{itemize}
\\item BF ベースのデータ構造を採用する
\\begin{itemize}
\\item 探索がメイン
\\begin{itemize}
\\item デフォルトルートにフォワーディングするパケットが来た時は，該
当エントリが存在しないため，該当エントリがあるかないかがすぐに分かっ
た方がよい
\\end{itemize}
\\item エントリの更新頻度が高くないため，複数のハッシュ値を計算すること
で発生するオーバーヘッドが小さい
\\item 一例として BFAST
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-2-4]{CS ・ PIT}
\\begin{itemize}
\\item 普通の chain ハッシュテーブルで統合して構築
\\begin{itemize}
\\item 探索・エントリの更新・新規エントリの挿入削除のすべてが同程度発生す
る
\\begin{itemize}
\\item ヒットしない時， Interest と Data の往復で，探索が CS2 回
PIT2 回・挿入削除が CS1 回 PIT2 回
\\item エントリの更新頻度が高いため，複数のハッシュ値の計算によるオーバーヘッドが
大きい
\\end{itemize}
\\item どちらも Exact Match (EM)
\\item ルータ中の CS と PIT 内で同一の prefix を持つエントリは存在しえな
いため，統合できる (1bit のフラグを立てるだけでよい)
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-2-5]{PIT (CS) の分割}
\\begin{itemize}
\\item PIT (CS) は M ($>$ N) 個に分割する (N は CPU コアの数)
\\item CPU コアが， PIT にアクセスするときは下記のテーブルを参照してハッ
シュ値に応じた PIT の先頭番地を入手してアクセスする．
\\begin{itemize}
\\item このテーブルはすべての CPU コアがアクセス可能であるとする
\\end{itemize}
\\end{itemize}
\\begin{center}
\\begin{tabular}{ll}
ハッシュ値 mod M & PIT へのポインタ\\\\
\\hline
0 & PIT$[0]$\\\\
1 & PIT$[1]$\\\\
\\ldots{}\\ldots{} & \\\\
M-1 & PIT$[M-1]$\\\\
\\end{tabular}
\\end{center}
\\end{frame}
\\begin{frame}[label=sec-2-6]{Interest 受信時のフロー}
\\begin{enumerate}
\\item Dispatcher が NIC から Interest を受け取り， fullname からハッシュ
値を計算
\\item (ハッシュ値 mod N) に基づいて Interest を，実際に処理を行う CPU コアへと割
り当てする
\\item PIT の探索を行う
\\begin{enumerate}
\\item (ハッシュ値 mod M) を計算し，テーブルを参照することで PIT への
ポインタを入手
\\item PIT へのポインタを通して実際に PIT へアクセスする
\\end{enumerate}
\\item FIB の探索を行う
\\begin{enumerate}
\\item (k-1) 個のハッシュ値を新たに計算し， BFAST の探索方法にしたがっ
て探索
\\end{enumerate}
\\end{enumerate}
\\end{frame}
\\begin{frame}[label=sec-2-7]{Data 受信時のフロー}
\\begin{itemize}
\\item Interest の処理の 1 〜 3 を行う
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-2-8]{}
\\end{frame}
\\section{2014 年 6 月 17 日}
\\label{sec-3}
\\begin{frame}[label=sec-3-1]{進捗状況}
\\begin{itemize}
\\item 「 BFAST: Unified and Scalable Index for NDN Forwarding
Architecture 」を読み，自分のルーティングアルゴリズムに適用させる
方法を考えた
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-3-2]{BFAST: Unified and Scalable Index for NDN Forwarding Architecture の概要}
\\begin{itemize}
\\item FIB ・ PIT ・ CS のエントリを別々に探索するのは時間がかかるので，
これらのテーブルを同時に探索できるような unified index を提案して
いる
\\begin{itemize}
\\item unified index は， 3 つのテーブルと LPM (Longest Prefix Match)
・ EM (Exact Match) をサポートする
\\end{itemize}
\\item unified index のエントリは， CS ・ PIT ・ FIB のエントリへの
pointer と pointer が指すエントリの含まれるテーブルを表す type (CS ・
PIT ・ FIB のいずれか) を持つ
\\end{itemize}
\\centering
\\includegraphics[height=0.5\\textheight]{./figure/overview_unified_index.pdf}
\\end{frame}

\\begin{frame}[label=sec-3-3]{BFAST の提案}
\\begin{itemize}
\\item Unified Index を実現するために BFAST というデータ構造を提案する
\\begin{itemize}
\\item BFAST は， 2 つの Counting Bloom Filter とハッシュテーブルから
構成される
\\end{itemize}
\\end{itemize}
\\centering
\\includegraphics[width=0.7\\linewidth,height=0.7\\textheight]{./figure/bfast_comp.pdf}
\\end{frame}

\\begin{frame}[label=sec-3-4]{補足: (Counting) Bloom Filter}
\\begin{itemize}
\\item Counting Bloom Filter は Bloom Filter の実装の一種で，再生成せずに
要素を削除できるものである． Counting Bloom Filter では，配列の各
要素はビットから n ビットのカウンタに拡張されている．
\\item 要素の追加は各配列要素のインクリメントになり，参照は各配列要素がゼ
ロでないことを確認することになる．削除する場合，対応する配列要素の
カウンタをデクリメントすればよい．
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-3-5]{BFAST の提案までの流れ (1)}
\\begin{enumerate}
\\item 1 つのハッシュ関数にかけたハッシュ値の bucket にエントリを挿入するだ
けだとハッシュテーブルのバランスが悪くなる
\\item バランスを取るために， k 個 (図では k=3) のハッシュ関数にかけて
得られた k 個のハッシュ値のうちエントリ数が最小の bucket にエント
リを挿入することにする
\\item 各 bucket が持つエントリ数を別のテーブル Counter で管理することにする
\\begin{itemize}
\\item エントリ数が最小の bucket を見つけるために，すべての bucket の
エントリを辿らなくてよくなる
\\end{itemize}
\\end{enumerate}
\\centering
\\includegraphics[width=1.0\\linewidth,height=0.4\\textheight]{./figure/bfast_flow.pdf}
\\end{frame}

\\begin{frame}[label=sec-3-6]{BFAST の提案までの流れ (2): Counting Bloom Filter の導入}
\\begin{columns}
\\begin{column}{0.5\\textwidth}
\\begin{block}{概要図}%x
\\centering
\\includegraphics[height=0.4\\textheight]{./figure/hash_table_with_counting_bloom_filter.pdf}
\\begin{itemize}
\\item Counter を Counting Bloom Filter (CBF) にする
\\begin{itemize}
\\item CBF のエントリが 0 ならば，エントリが存在しない事が分かるため高
速で EM ・ LPM が可能
\\end{itemize}
\\end{itemize}
\\end{block}
\\end{column}

\\begin{column}{0.5\\textwidth}
\\begin{block}{挿入アルゴリズム}%x
\\includegraphics[height=0.48\\textheight]{./figure/Algorithm1.pdf}
\\begin{itemize}
\\item k: ハッシュ関数の個数
\\item $f_i$ (): ハッシュ関数
\\item $B_i$: i 番目の bucket
\\item $C_i$: $B_i$ のカウンタ
\\end{itemize}
\\end{block}
\\end{column}
\\end{columns}
\\end{frame}

\\begin{frame}[label=sec-3-7]{BFAST の提案までの流れ (3):}
\\begin{itemize}
\\item 前スライドの構造では，エントリの探索が上手く行かない
\\begin{itemize}
\\item k 個のハッシュ値のうち CBF が最小の bucket に該当するエントリが
あるとは限らないから
\\begin{itemize}
\\item 別のエントリを挿入するときに CBF がインクリメントさせる可能性が
あるから
\\end{itemize}
\\end{itemize}
\\item これを解決するため， auxiliary CBF (aCBF) を導入する
\\begin{itemize}
\\item エントリを挿入する時に，どのハッシュ関数が最小の C\\_i となる i
を導出したかを記録する
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-3-8]{完成版 BFAST}
\\begin{columns}
\\begin{column}{0.5\\textwidth}
\\begin{block}{概要図}%x
\\centering
\\includegraphics[width=.9\\linewidth]{./figure/bfast_comp.pdf}
\\end{block}
\\end{column}

\\begin{column}{0.5\\textwidth}
\\begin{block}{挿入アルゴリズム}%x
\\centering
\\includegraphics[width=0.99\\linewidth,height=0.55\\textheight]{./figure/bfast_insert.pdf}
\\end{block}
\\end{column}
\\end{columns}
\\end{frame}

\\begin{frame}[label=sec-3-9]{BFAST での探索と削除}
\\begin{columns}
\\begin{column}{0.5\\textwidth}
\\begin{block}{探索アルゴリズム}%x
\\centering
\\includegraphics[width=0.99\\linewidth,height=0.55\\textheight]{./figure/bfast_lookup.pdf}
\\begin{itemize}
\\item 探索要素を k 個のハッシュ関数にかけたハッシュ値をインデックスとし
た mCBF の要素に 0 があるならば，要素は存在しない (line 3-5)
\\end{itemize}
\\end{block}
\\end{column}

\\begin{column}{0.5\\textwidth}
\\begin{block}{削除アルゴリズム}%x
\\centering
\\includegraphics[width=0.99\\linewidth,height=0.55\\textheight]{./figure/bfast_delete.pdf}
\\begin{itemize}
\\item mCBF と aCBF の値をデクリメントする操作が抜けてるのでは?
\\end{itemize}
\\end{block}
\\end{column}
\\end{columns}
\\end{frame}

\\begin{frame}[label=sec-3-10]{BFAST における EM と LPM}
\\begin{itemize}
\\item EM は前ページの探索アルゴリズムで行える
\\item LPM は， prefix を fullname から 1 コンポネントずつ短くして EM と同
じ方法で行う
\\end{itemize}
\\centering
\\includegraphics[width=.9\\linewidth]{./figure/LPM.pdf}
\\end{frame}

\\begin{frame}[label=sec-3-11]{BFAST の Scalability と Extensibility}
\\begin{itemize}
\\item BFAST はテーブルを再構築せずに動的に拡張できる
\\begin{itemize}
\\item 格納する要素が増えると探索にかかる時間が増えてしまう
\\begin{itemize}
\\item mCBF の false positive の確率が上昇するため不要な lookup が増
える
\\item ハッシュテーブルのリンクを何度も辿ることになる
\\end{itemize}
\\item これを防ぐために，テーブルのテーブルの再構築を行うと，時間がかかる上
に，通常のパケットフォワーディングを阻害してしまう
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-3-12]{BFAST の拡張}
\\begin{itemize}
\\item BFAST の拡張前後では，異なる aCBF を用いる
\\begin{itemize}
\\item 要素の探索は， aCBF と aCBF'のどちらに要素があるかをチェックし
てから開始する
\\begin{itemize}
\\item ハッシュテーブル (および mCBF) へ要素の挿入位置が拡張前のハッ
シュテーブルの大きさ N と拡張後の N'で異なってくるため
\\end{itemize}
\\end{itemize}
\\end{itemize}

\\centering
\\includegraphics[width=0.8\\linewidth,height=0.6\\textheight]{./figure/extend_bfast.pdf}
\\end{frame}

\\begin{frame}[label=sec-3-13]{BFAST での NDN フォワーディングの全体像}
\\begin{itemize}
\\item prefix 自体は，テーブルエントリだけに格納して， unified index では
signature を用いる
\\begin{itemize}
\\item signature は， prefix をハッシュ関数にかけて生成する
\\begin{itemize}
\\item index のサイズを劇的位に小さく出来る
\\item エラーレートは無視できるほど小さい
\\end{itemize}
\\end{itemize}
\\item PIT と FIB を指す unified index のエントリは face 番号も格納する
\\begin{itemize}
\\item 探索速度向上のため
\\end{itemize}
\\end{itemize}

\\centering
\\includegraphics[width=0.9\\linewidth,height=0.55\\textheight]{./figure/NDN_with_bfast.pdf}
\\end{frame}

\\begin{frame}[label=sec-3-14]{いかにして BFAST を我々の NDN ルータモデルに導入するか}
\\begin{itemize}
\\item 我々の NDN ルータモデルのテーブル集合を BFAST に置きかえるだけでよ
い
\\begin{itemize}
\\item root prefix のハッシュ値で CPU に割り振る
\\begin{itemize}
\\item LPM を行う時に， 1 コンポネントずつ短い prefix を見ていくため，
LPM を同じ CPU で行えるようにしたい
\\end{itemize}
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-3-15]{BFAST と CCNx の比較}
\\begin{itemize}
\\item パフォーマンスに関しては， BFAST の方が圧倒的によさそう
\\begin{itemize}
\\item アルゴリズム的に， CCNx のデータ構造と比べて探索等がすむ
\\item 論文中の評価
\\end{itemize}
\\item メモリ利用量は CCNx の方が少ない
\\begin{itemize}
\\item CCNx が NPHT を使って FIB と PIT をまとめて管理しているからだと
思われる
\\item CCNx は， Android 版があるなどモバイル端末上でも動作することを
考えているようなので，ロースペックな端末でも動作することを設計
方針にしていると予想される
\\end{itemize}
\\end{itemize}
\\begin{table}[htb]
\\caption{メモリ利用量}
\\centering
\\begin{tabular}{lrr}
 & 3MFIB & 10MFIB\\\\
\\hline
BFAST & 149.09 & 539.58\\\\
CCNx & 102.44 & 384.05\\\\
\\end{tabular}
\\end{table}
\\end{frame}

\\begin{frame}[label=sec-3-16]{所感}
\\begin{itemize}
\\item 我々の対象であるソフトウェアルータで使うには， CCNx のデータ構造は不向き
\\begin{itemize}
\\item テーブルの探索時間に時間がかかりすぎているため，パフォーマンス
が低い
\\item メモリは 16G と潤沢にあるので，そんなに省メモリを考える必要はな
い
\\end{itemize}
\\item パフォーマンスと省電力の両方を考慮に入れた NDN ルータを提案するな
らば，データ構造は， BFAST を採用すべきである
\\begin{itemize}
\\item メモリの利用量は電力にほとんど影響しないと予想される
\\end{itemize}
\\end{itemize}
\\end{frame}

\\section{2014 年 6 月 13 日}
\\label{sec-4}
\\begin{frame}[label=sec-4-1]{前回までのミーティングのまとめ}
\\begin{itemize}
\\item 現在は， ICN ルータの省電力化と ICN ネットワーク全体の省電力化を
どちらも考えているので，ルータの省電力化に焦点を当てる
\\item まずは，ルータの FIB ・ PIT ・ CS の構造を考えるため，関連研究の論
文を読む
\\begin{itemize}
\\item 電力効率のよいテーブル構造を議論したい
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-4-2]{進捗状況}
\\begin{itemize}
\\item 「 Scalable NDN Forwarding: Concepts, Issues and Principles 」を読み知
見を得た
\\begin{itemize}
\\item NDN のソフトウェアルータで 1Gbps を達成するためのルータの設計方
針が述べられている
\\end{itemize}
\\item 現在，「 BFAST: Unified and Scalable Index for NDN Forwarding Architecture 」
を読み進めている
\\begin{itemize}
\\item FIB ・ PIT ・ CS のエントリを別々に探索するのは時間がかかるので，
これらのテーブルを同時に探索できるような unified index を提案している
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-4-3]{現在の考えのまとめ}
\\begin{itemize}
\\item name prefix の長さに関わらず を固定長の prefix として扱う手法が必要である
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-4-4]{その他の探索アルゴリズム}
\\begin{itemize}
\\item FIB
\\begin{itemize}
\\item 2-stage LPM (Longest Prefix Match) algorithm
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-4-5]{2-stage LPM algorithm の概要}
\\begin{itemize}
\\item LPM を fullname ではなく，ある長さ $M$ の prefix から開始する
\\begin{itemize}
\\item マッチは fullname よりも大幅に短い prefix で発生しやすい
\\item マッチしなかった時，マッチにかかる時間は最悪となる
\\item LPM にかかる最悪の時間を一定時間以下に保証できる (マッチングする
回数が $M$ 以下のため)
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-4-6]{2-stage LPM algorithm の処理の流れ}
\\begin{enumerate}
\\item LPM を長さ $M$ の prefix から開始する
\\item マッチングなし: LPM 終了
\\item マッチングあり: 最大の長さ $MD$ からマッチするまで繰り返す
\\end{enumerate}
\\end{frame}
% Emacs 24.3.1 (Org mode 8.2.7b)
\\end{document}" "% Created 2014-07-10 木 19:59
\\documentclass[dvipdfmx,11pt]{beamer}
\\usepackage{url}
\\usepackage{pxjahyper}
\\usetheme{Berlin}
\\setbeamertemplate{navigation symbols}{}
\\beamertemplatetextbibitems
\\setbeamertemplate{footline}[frame number]
\\setbeamertemplate{headline}{}


\\institute[]{Osaka University\\\\
Graduate School of Information Science and Technology \\\\
Information Sharing Platform Laboratory \\\\
Master course second year}
\\usetheme{default}
\\author{大杉 海斗}
\\date{\\today}
\\title{ICN Meeting}
\\hypersetup{
  pdfkeywords={},
  pdfsubject={},
  pdfcreator={Emacs 24.3.1 (Org mode 8.2.7b)}}
\\begin{document}

\\maketitle

\\section{2014 年 7 月 15 日}
\\label{sec-1}
\\begin{frame}[label=sec-1-1]{進捗状況}
\\begin{itemize}
\\item CCN ルータの要件を調査するため，「 On Content-Centric Router Design and Implications 」を読んだ
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-2]{モデル化対象のルータ}
\\begin{itemize}
\\item アクセスネットワーク上のソフトウェアルータ
\\begin{itemize}
\\item ICN のパケット処理は複雑であり， IP ルータのようにハードウェア化
するのには時間がかかり，しばらくソフトウェアルータが使われると予
想されるから
\\item 
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-3]{ルータが満たすべき要件}
\\begin{itemize}
\\item 
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-4]{ルータのハードウェアの仕様}
\\begin{itemize}
\\item Cisco ASR9000
\\begin{itemize}
\\item CPU: 2 * Intel 2.0GHz 6core Westmere EP (Xeon) (HTT 有)
\\item NIC: 4 * Intel Niantic 10GE interfaces
\\item STORAGE: 3.2TB SSD
\\end{itemize}
\\end{itemize}
\\end{frame}


\\begin{frame}[label=sec-1-5]{ルータの設計概要}
\\begin{itemize}
\\item 多くの設計は Cisco が提案しているソフトウェアルータと同様である
\\item 異なる点は次の通りである
\\begin{itemize}
\\item アクティブな CPU コアの数が可変である
\\begin{itemize}
\\item 消費電力を削減できる
\\end{itemize}
\\item FIB の構造に Bloom Filter を採用する
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-6]{FIB の構造}
\\begin{itemize}
\\item Bloom Filter ベースのデータ構造を採用する
\\begin{itemize}
\\item FIB の更新間隔が， BGP と OSPF の更新間隔と同じであると仮定す
ると，更新頻度は高くないため，複数のハッシュ値の計算に費やす
リソースは少なくて済む
\\begin{itemize}
\\item BGP: 経路情報が追加または削除された時
\\item OSPF:リンクのアップダウンがなければ 30 分間隔で更新される (ア
クセスネットワークでは，リンクのアップダウンはそれほど起こ ら
ないのではないかと予想される (要調査))
\\end{itemize}
\\end{itemize}
\\end{itemize}
\\end{frame}


\\begin{frame}[label=sec-1-7]{PIT ・ CS の構造}
\\begin{itemize}
\\item 
\\end{itemize}
\\end{frame}



\\begin{frame}[label=sec-1-8]{}
\\end{frame}

\\section{2014 年 7 月 8 日}
\\label{sec-2}
\\begin{frame}[label=sec-2-1]{進捗状況}
\\begin{itemize}
\\item 「 FIA Router: Cost-Effective, Energy-Efficient, and High-Speed
Router for Future Internet Architecture 」を読んだ
\\item パフォーマンスに重点をおいた NDN ルータの設計を行った
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-2-2]{NDN ルータの概要}
\\begin{itemize}
\\item FIB は Bloom Filter (BF) ベースのデータ構造， PIT と CS は統合し普
通の chain ハッシュテーブルで構築
\\begin{itemize}
\\item ハッシュ化する対象は，パケットの full name
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-2-3]{FIB}
\\begin{itemize}
\\item BF ベースのデータ構造を採用する
\\begin{itemize}
\\item 探索がメイン
\\begin{itemize}
\\item デフォルトルートにフォワーディングするパケットが来た時は，該
当エントリが存在しないため，該当エントリがあるかないかがすぐに分かっ
た方がよい
\\end{itemize}
\\item エントリの更新頻度が高くないため，複数のハッシュ値を計算すること
で発生するオーバーヘッドが小さい
\\item 一例として BFAST
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-2-4]{CS ・ PIT}
\\begin{itemize}
\\item 普通の chain ハッシュテーブルで統合して構築
\\begin{itemize}
\\item 探索・エントリの更新・新規エントリの挿入削除のすべてが同程度発生す
る
\\begin{itemize}
\\item ヒットしない時， Interest と Data の往復で，探索が CS2 回
PIT2 回・挿入削除が CS1 回 PIT2 回
\\item エントリの更新頻度が高いため，複数のハッシュ値の計算によるオーバーヘッドが
大きい
\\end{itemize}
\\item どちらも Exact Match (EM)
\\item ルータ中の CS と PIT 内で同一の prefix を持つエントリは存在しえな
いため，統合できる (1bit のフラグを立てるだけでよい)
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-2-5]{PIT (CS) の分割}
\\begin{itemize}
\\item PIT (CS) は M ($>$ N) 個に分割する (N は CPU コアの数)
\\item CPU コアが， PIT にアクセスするときは下記のテーブルを参照してハッ
シュ値に応じた PIT の先頭番地を入手してアクセスする．
\\begin{itemize}
\\item このテーブルはすべての CPU コアがアクセス可能であるとする
\\end{itemize}
\\end{itemize}
\\begin{center}
\\begin{tabular}{ll}
ハッシュ値 mod M & PIT へのポインタ\\\\
\\hline
0 & PIT$[0]$\\\\
1 & PIT$[1]$\\\\
\\ldots{}\\ldots{} & \\\\
M-1 & PIT$[M-1]$\\\\
\\end{tabular}
\\end{center}
\\end{frame}
\\begin{frame}[label=sec-2-6]{Interest 受信時のフロー}
\\begin{enumerate}
\\item Dispatcher が NIC から Interest を受け取り， fullname からハッシュ
値を計算
\\item (ハッシュ値 mod N) に基づいて Interest を，実際に処理を行う CPU コアへと割
り当てする
\\item PIT の探索を行う
\\begin{enumerate}
\\item (ハッシュ値 mod M) を計算し，テーブルを参照することで PIT への
ポインタを入手
\\item PIT へのポインタを通して実際に PIT へアクセスする
\\end{enumerate}
\\item FIB の探索を行う
\\begin{enumerate}
\\item (k-1) 個のハッシュ値を新たに計算し， BFAST の探索方法にしたがっ
て探索
\\end{enumerate}
\\end{enumerate}
\\end{frame}
\\begin{frame}[label=sec-2-7]{Data 受信時のフロー}
\\begin{itemize}
\\item Interest の処理の 1 〜 3 を行う
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-2-8]{}
\\end{frame}
\\section{2014 年 6 月 17 日}
\\label{sec-3}
\\begin{frame}[label=sec-3-1]{進捗状況}
\\begin{itemize}
\\item 「 BFAST: Unified and Scalable Index for NDN Forwarding
Architecture 」を読み，自分のルーティングアルゴリズムに適用させる
方法を考えた
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-3-2]{BFAST: Unified and Scalable Index for NDN Forwarding Architecture の概要}
\\begin{itemize}
\\item FIB ・ PIT ・ CS のエントリを別々に探索するのは時間がかかるので，
これらのテーブルを同時に探索できるような unified index を提案して
いる
\\begin{itemize}
\\item unified index は， 3 つのテーブルと LPM (Longest Prefix Match)
・ EM (Exact Match) をサポートする
\\end{itemize}
\\item unified index のエントリは， CS ・ PIT ・ FIB のエントリへの
pointer と pointer が指すエントリの含まれるテーブルを表す type (CS ・
PIT ・ FIB のいずれか) を持つ
\\end{itemize}
\\centering
\\includegraphics[height=0.5\\textheight]{./figure/overview_unified_index.pdf}
\\end{frame}

\\begin{frame}[label=sec-3-3]{BFAST の提案}
\\begin{itemize}
\\item Unified Index を実現するために BFAST というデータ構造を提案する
\\begin{itemize}
\\item BFAST は， 2 つの Counting Bloom Filter とハッシュテーブルから
構成される
\\end{itemize}
\\end{itemize}
\\centering
\\includegraphics[width=0.7\\linewidth,height=0.7\\textheight]{./figure/bfast_comp.pdf}
\\end{frame}

\\begin{frame}[label=sec-3-4]{補足: (Counting) Bloom Filter}
\\begin{itemize}
\\item Counting Bloom Filter は Bloom Filter の実装の一種で，再生成せずに
要素を削除できるものである． Counting Bloom Filter では，配列の各
要素はビットから n ビットのカウンタに拡張されている．
\\item 要素の追加は各配列要素のインクリメントになり，参照は各配列要素がゼ
ロでないことを確認することになる．削除する場合，対応する配列要素の
カウンタをデクリメントすればよい．
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-3-5]{BFAST の提案までの流れ (1)}
\\begin{enumerate}
\\item 1 つのハッシュ関数にかけたハッシュ値の bucket にエントリを挿入するだ
けだとハッシュテーブルのバランスが悪くなる
\\item バランスを取るために， k 個 (図では k=3) のハッシュ関数にかけて
得られた k 個のハッシュ値のうちエントリ数が最小の bucket にエント
リを挿入することにする
\\item 各 bucket が持つエントリ数を別のテーブル Counter で管理することにする
\\begin{itemize}
\\item エントリ数が最小の bucket を見つけるために，すべての bucket の
エントリを辿らなくてよくなる
\\end{itemize}
\\end{enumerate}
\\centering
\\includegraphics[width=1.0\\linewidth,height=0.4\\textheight]{./figure/bfast_flow.pdf}
\\end{frame}

\\begin{frame}[label=sec-3-6]{BFAST の提案までの流れ (2): Counting Bloom Filter の導入}
\\begin{columns}
\\begin{column}{0.5\\textwidth}
\\begin{block}{概要図}%x
\\centering
\\includegraphics[height=0.4\\textheight]{./figure/hash_table_with_counting_bloom_filter.pdf}
\\begin{itemize}
\\item Counter を Counting Bloom Filter (CBF) にする
\\begin{itemize}
\\item CBF のエントリが 0 ならば，エントリが存在しない事が分かるため高
速で EM ・ LPM が可能
\\end{itemize}
\\end{itemize}
\\end{block}
\\end{column}

\\begin{column}{0.5\\textwidth}
\\begin{block}{挿入アルゴリズム}%x
\\includegraphics[height=0.48\\textheight]{./figure/Algorithm1.pdf}
\\begin{itemize}
\\item k: ハッシュ関数の個数
\\item $f_i$ (): ハッシュ関数
\\item $B_i$: i 番目の bucket
\\item $C_i$: $B_i$ のカウンタ
\\end{itemize}
\\end{block}
\\end{column}
\\end{columns}
\\end{frame}

\\begin{frame}[label=sec-3-7]{BFAST の提案までの流れ (3):}
\\begin{itemize}
\\item 前スライドの構造では，エントリの探索が上手く行かない
\\begin{itemize}
\\item k 個のハッシュ値のうち CBF が最小の bucket に該当するエントリが
あるとは限らないから
\\begin{itemize}
\\item 別のエントリを挿入するときに CBF がインクリメントさせる可能性が
あるから
\\end{itemize}
\\end{itemize}
\\item これを解決するため， auxiliary CBF (aCBF) を導入する
\\begin{itemize}
\\item エントリを挿入する時に，どのハッシュ関数が最小の C\\_i となる i
を導出したかを記録する
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-3-8]{完成版 BFAST}
\\begin{columns}
\\begin{column}{0.5\\textwidth}
\\begin{block}{概要図}%x
\\centering
\\includegraphics[width=.9\\linewidth]{./figure/bfast_comp.pdf}
\\end{block}
\\end{column}

\\begin{column}{0.5\\textwidth}
\\begin{block}{挿入アルゴリズム}%x
\\centering
\\includegraphics[width=0.99\\linewidth,height=0.55\\textheight]{./figure/bfast_insert.pdf}
\\end{block}
\\end{column}
\\end{columns}
\\end{frame}

\\begin{frame}[label=sec-3-9]{BFAST での探索と削除}
\\begin{columns}
\\begin{column}{0.5\\textwidth}
\\begin{block}{探索アルゴリズム}%x
\\centering
\\includegraphics[width=0.99\\linewidth,height=0.55\\textheight]{./figure/bfast_lookup.pdf}
\\begin{itemize}
\\item 探索要素を k 個のハッシュ関数にかけたハッシュ値をインデックスとし
た mCBF の要素に 0 があるならば，要素は存在しない (line 3-5)
\\end{itemize}
\\end{block}
\\end{column}

\\begin{column}{0.5\\textwidth}
\\begin{block}{削除アルゴリズム}%x
\\centering
\\includegraphics[width=0.99\\linewidth,height=0.55\\textheight]{./figure/bfast_delete.pdf}
\\begin{itemize}
\\item mCBF と aCBF の値をデクリメントする操作が抜けてるのでは?
\\end{itemize}
\\end{block}
\\end{column}
\\end{columns}
\\end{frame}

\\begin{frame}[label=sec-3-10]{BFAST における EM と LPM}
\\begin{itemize}
\\item EM は前ページの探索アルゴリズムで行える
\\item LPM は， prefix を fullname から 1 コンポネントずつ短くして EM と同
じ方法で行う
\\end{itemize}
\\centering
\\includegraphics[width=.9\\linewidth]{./figure/LPM.pdf}
\\end{frame}

\\begin{frame}[label=sec-3-11]{BFAST の Scalability と Extensibility}
\\begin{itemize}
\\item BFAST はテーブルを再構築せずに動的に拡張できる
\\begin{itemize}
\\item 格納する要素が増えると探索にかかる時間が増えてしまう
\\begin{itemize}
\\item mCBF の false positive の確率が上昇するため不要な lookup が増
える
\\item ハッシュテーブルのリンクを何度も辿ることになる
\\end{itemize}
\\item これを防ぐために，テーブルのテーブルの再構築を行うと，時間がかかる上
に，通常のパケットフォワーディングを阻害してしまう
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-3-12]{BFAST の拡張}
\\begin{itemize}
\\item BFAST の拡張前後では，異なる aCBF を用いる
\\begin{itemize}
\\item 要素の探索は， aCBF と aCBF'のどちらに要素があるかをチェックし
てから開始する
\\begin{itemize}
\\item ハッシュテーブル (および mCBF) へ要素の挿入位置が拡張前のハッ
シュテーブルの大きさ N と拡張後の N'で異なってくるため
\\end{itemize}
\\end{itemize}
\\end{itemize}

\\centering
\\includegraphics[width=0.8\\linewidth,height=0.6\\textheight]{./figure/extend_bfast.pdf}
\\end{frame}

\\begin{frame}[label=sec-3-13]{BFAST での NDN フォワーディングの全体像}
\\begin{itemize}
\\item prefix 自体は，テーブルエントリだけに格納して， unified index では
signature を用いる
\\begin{itemize}
\\item signature は， prefix をハッシュ関数にかけて生成する
\\begin{itemize}
\\item index のサイズを劇的位に小さく出来る
\\item エラーレートは無視できるほど小さい
\\end{itemize}
\\end{itemize}
\\item PIT と FIB を指す unified index のエントリは face 番号も格納する
\\begin{itemize}
\\item 探索速度向上のため
\\end{itemize}
\\end{itemize}

\\centering
\\includegraphics[width=0.9\\linewidth,height=0.55\\textheight]{./figure/NDN_with_bfast.pdf}
\\end{frame}

\\begin{frame}[label=sec-3-14]{いかにして BFAST を我々の NDN ルータモデルに導入するか}
\\begin{itemize}
\\item 我々の NDN ルータモデルのテーブル集合を BFAST に置きかえるだけでよ
い
\\begin{itemize}
\\item root prefix のハッシュ値で CPU に割り振る
\\begin{itemize}
\\item LPM を行う時に， 1 コンポネントずつ短い prefix を見ていくため，
LPM を同じ CPU で行えるようにしたい
\\end{itemize}
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-3-15]{BFAST と CCNx の比較}
\\begin{itemize}
\\item パフォーマンスに関しては， BFAST の方が圧倒的によさそう
\\begin{itemize}
\\item アルゴリズム的に， CCNx のデータ構造と比べて探索等がすむ
\\item 論文中の評価
\\end{itemize}
\\item メモリ利用量は CCNx の方が少ない
\\begin{itemize}
\\item CCNx が NPHT を使って FIB と PIT をまとめて管理しているからだと
思われる
\\item CCNx は， Android 版があるなどモバイル端末上でも動作することを
考えているようなので，ロースペックな端末でも動作することを設計
方針にしていると予想される
\\end{itemize}
\\end{itemize}
\\begin{table}[htb]
\\caption{メモリ利用量}
\\centering
\\begin{tabular}{lrr}
 & 3MFIB & 10MFIB\\\\
\\hline
BFAST & 149.09 & 539.58\\\\
CCNx & 102.44 & 384.05\\\\
\\end{tabular}
\\end{table}
\\end{frame}

\\begin{frame}[label=sec-3-16]{所感}
\\begin{itemize}
\\item 我々の対象であるソフトウェアルータで使うには， CCNx のデータ構造は不向き
\\begin{itemize}
\\item テーブルの探索時間に時間がかかりすぎているため，パフォーマンス
が低い
\\item メモリは 16G と潤沢にあるので，そんなに省メモリを考える必要はな
い
\\end{itemize}
\\item パフォーマンスと省電力の両方を考慮に入れた NDN ルータを提案するな
らば，データ構造は， BFAST を採用すべきである
\\begin{itemize}
\\item メモリの利用量は電力にほとんど影響しないと予想される
\\end{itemize}
\\end{itemize}
\\end{frame}

\\section{2014 年 6 月 13 日}
\\label{sec-4}
\\begin{frame}[label=sec-4-1]{前回までのミーティングのまとめ}
\\begin{itemize}
\\item 現在は， ICN ルータの省電力化と ICN ネットワーク全体の省電力化を
どちらも考えているので，ルータの省電力化に焦点を当てる
\\item まずは，ルータの FIB ・ PIT ・ CS の構造を考えるため，関連研究の論
文を読む
\\begin{itemize}
\\item 電力効率のよいテーブル構造を議論したい
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-4-2]{進捗状況}
\\begin{itemize}
\\item 「 Scalable NDN Forwarding: Concepts, Issues and Principles 」を読み知
見を得た
\\begin{itemize}
\\item NDN のソフトウェアルータで 1Gbps を達成するためのルータの設計方
針が述べられている
\\end{itemize}
\\item 現在，「 BFAST: Unified and Scalable Index for NDN Forwarding Architecture 」
を読み進めている
\\begin{itemize}
\\item FIB ・ PIT ・ CS のエントリを別々に探索するのは時間がかかるので，
これらのテーブルを同時に探索できるような unified index を提案している
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-4-3]{現在の考えのまとめ}
\\begin{itemize}
\\item name prefix の長さに関わらず を固定長の prefix として扱う手法が必要である
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-4-4]{その他の探索アルゴリズム}
\\begin{itemize}
\\item FIB
\\begin{itemize}
\\item 2-stage LPM (Longest Prefix Match) algorithm
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-4-5]{2-stage LPM algorithm の概要}
\\begin{itemize}
\\item LPM を fullname ではなく，ある長さ $M$ の prefix から開始する
\\begin{itemize}
\\item マッチは fullname よりも大幅に短い prefix で発生しやすい
\\item マッチしなかった時，マッチにかかる時間は最悪となる
\\item LPM にかかる最悪の時間を一定時間以下に保証できる (マッチングする
回数が $M$ 以下のため)
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-4-6]{2-stage LPM algorithm の処理の流れ}
\\begin{enumerate}
\\item LPM を長さ $M$ の prefix から開始する
\\item マッチングなし: LPM 終了
\\item マッチングあり: 最大の長さ $MD$ からマッチするまで繰り返す
\\end{enumerate}
\\end{frame}
% Emacs 24.3.1 (Org mode 8.2.7b)
\\end{document}"))
(setq-default session-file-alist '(("/mnt/Dropbox/storage/cloth.org" 34 85 1 nil nil 83 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/var/recentf" 7881 nil 1 nil nil nil (overwrite-mode)) ("/mnt/Dropbox/research/meeting/ICN-meeting.org" 564 530 1 nil nil 564 (overwrite-mode)) ("/mnt/Dropbox/research/meeting/ICN-meeting.tex" 13299 nil 1 nil nil nil (overwrite-mode)) ("/mnt/Dropbox/research/work/IN14/abstract.org" 727 506 1 nil nil nil (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/helm-20140705.320/helm-autoloads.el" 42222 nil 1 nil nil 42222 (overwrite-mode)) ("/mnt/Dropbox/storage/scfes.org" 15 18 1 nil nil 17 (overwrite-mode)) ("/mnt/Dropbox/myfile.txt" 1 nil 1 nil nil nil (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/inits/10_helm.el" 1682 333 1 nil nil 343 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/helm-20140703.2108/helm-autoloads.el" 42258 nil 1 nil nil 42258 (overwrite-mode)) ("~/.mozilla/firefox/sg4susle.default-1376407928725/chaika/skin/DefaultKaiKai/Readme.txt" 7609 nil 1 nil nil nil (overwrite-mode)) ("/mnt/Dropbox/research/work/society14/paperv0.6.tex" 282 282 1 nil nil 2532 (overwrite-mode)) ("/mnt/Dropbox/research/work/society14/abstract.org" 286 1 1 nil nil 323 (overwrite-mode)) ("/mnt/Dropbox/research/work/society14/paperv0.5.tex" 2748 2749 1 nil nil 2737 (overwrite-mode)) ("/mnt/Dropbox/configure/.zshrc" 1935 1930 1 nil nil 1935 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/inits/00_default.el" 2316 1 1 nil nil nil (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/inits/20_org-mode.el" 1 555 1 nil nil 1965 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/snippets/org-mode/figure" 50 nil 1 nil nil 91 (overwrite-mode)) ("/mnt/Dropbox/research/work/society14/paperv0.4.tex" 523 1679 1 nil nil 3894 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/org-20140630/org-loaddefs.el" 86900 nil 1 nil nil 86900 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/helm-20140629.2320/helm-autoloads.el" 42602 nil 1 nil nil 42602 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/org-20140630/org-autoloads.el" 27237 nil 1 nil nil 27237 (overwrite-mode)) ("/mnt/Dropbox/research/work/society14/paperv0.3.tex" 2953 3421 1 nil nil 3715 (overwrite-mode)) ("/mnt/Dropbox/research/work/society14/paper.aux" 1 nil 1 nil nil nil (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/auctex-latexmk-20140627.2146/auctex-latexmk-autoloads.el" 466 nil 1 nil nil 466 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/dash-20140627.2341/dash-autoloads.el" 173 nil 1 nil nil 173 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/helm-20140629.39/helm-autoloads.el" 42605 nil 1 nil nil 42605 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/lua-mode-20140628.1505/lua-mode-autoloads.el" 511 nil 1 nil nil 511 (overwrite-mode)) ("/mnt/Dropbox/research/work/society14/paper.tex" 247 246 1 nil nil 1760 (overwrite-mode)) ("/mnt/Dropbox/research/work/society14/ieicejsp.cls" 1 nil 1 nil nil nil (overwrite-mode)) ("/mnt/Dropbox/research/work/society14/paper (VAIO の競合コピー 2014-06-26).tex" 1778 nil 1 nil nil nil (overwrite-mode)) ("/mnt/Dropbox/research/work/society14/paper.org" 656 nil 1 nil nil 322 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/helm-20140625.252/helm-autoloads.el" 42605 nil 1 nil nil 42605 (overwrite-mode)) ("~/Dropbox/configure/.emacs.d/elpa/org-20140623/org-loaddefs.el" 86900 nil 1 nil nil 86900 (overwrite-mode)) ("~/Dropbox/configure/.emacs.d/elpa/helm-20140624.2318/helm-autoloads.el" 42605 nil 1 nil nil 42605 (overwrite-mode)) ("~/Dropbox/configure/.emacs.d/elpa/lua-mode-20140623.1237/lua-mode-autoloads.el" 510 nil 1 nil nil 510 (overwrite-mode)) ("~/Dropbox/configure/.emacs.d/elpa/org-20140623/org-autoloads.el" 27238 nil 1 nil nil 27238 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/helm-20140621.2211/helm-autoloads.el" 42606 nil 1 nil nil 42606 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/s-20140620.1657/s-autoloads.el" 165 nil 1 nil nil 165 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/yasnippet-20140617.1640/yasnippet-autoloads.el" 1494 nil 1 nil nil 1494 (overwrite-mode)) ("~/.config/awesome/rc.lua" 1 17440 1 nil nil 17598 (overwrite-mode)) ("/sudo:root@desktop:/etc/X11/xorg.conf.d/10-monitor.conf" 289 nil 1 nil nil 138 (overwrite-mode)) ("/mnt/Dropbox/storage/keys-TA/it-keys_ta.org" 1042 nil 1 nil nil nil (overwrite-mode)) ("~/Downloads/作業割り当て.txt" 1 nil 1 nil nil 260 (overwrite-mode)) ("~/Downloads/作業割り当て.txtm" 1 nil 1 nil nil 2 (overwrite-mode)) ("~/Dropbox/configure/.emacs.d/var/recentf" 4216 nil 1 nil nil nil (overwrite-mode)) ("~/Dropbox/configure/.emacs.d/elpa/epc-20140609.2234/epc-autoloads.el" 179 nil 1 nil nil 179 (overwrite-mode)) ("/mnt/Dropbox/research/meeting/M2-meeting.org" 15 202 1 nil nil 15 (overwrite-mode)) ("/mnt/Dropbox/research/poster_introduction/paper.org" 224 4371 1 nil nil 4448 (overwrite-mode)) ("/mnt/Dropbox/research/meeting/M2-meeting.tex" 794 nil 1 nil nil nil (overwrite-mode)) ("/sudo:root@localhost:/etc/X11/xorg.conf.d/20-gpudriver.conf" 1 nil 1 nil nil nil (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/helm-20140608.753/helm-autoloads.el" 48154 nil 1 nil nil 48154 (overwrite-mode)) ("/mnt/Dropbox/research/poster_introduction/paper.tex" 7591 nil 1 nil nil nil (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/helm-20140607.2258/helm-autoloads.el" 48114 nil 1 nil nil 48114 (overwrite-mode)) ("~/.config/awesome/themes/theme.lua" 1765 318 1 nil nil 240 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/dash-20140607.33/dash-autoloads.el" 174 nil 1 nil nil 174 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/auto-complete-20140605.1908/auto-complete-autoloads.el" 1715 nil 1 nil nil 1715 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/helm-20140605.1156/helm-autoloads.el" 48156 nil 1 nil nil 48156 (overwrite-mode))))
(setq-default TeX-command-history '("Evince" "LatexMk" "LaTeX" "Clean All"))
(setq-default buffer-name-history '("*Backtrace*" "ieicejsp.cls" "report8.org" "udp1500byte.gp" "memory_accsess.dat" "*scratch*" "*Async Shell Command*" "ssh:get_ccnx_time.sh" "*gnuplot*" "udp1500byte.out" "*Moccur*" "*Org PDF LaTeX Output*" "__init__.py" "functions.py" "PKGBUILD" "ssh:hoge.c" "forwarding.c" "dummy.c" "256result.data" "ssh:receive.c" "ssh:ssh:ssh:send.c<client1>" "router" "rdtsc.h" "*Packages*" "*Macroexpansion*" "2-13 Daring!!.mp3" "20_org-mode.el" "hote.txt" "es.org" "*init log*"))
(setq-default coding-system-history '("shift_jis" "utf-8-unix" "unix"))
(setq-default command-history '((kill-buffer "*Backtrace*") (package-list-packages nil) (write-file "/mnt/Dropbox/research/work/society14/paperv0.6.tex" t) (find-file "/mnt/Dropbox/research/work/society14/paperv0.5.tex" t) (count-lines-region 1 323 nil) (count-lines-region 1 375 nil) (count-lines-region 1 195 nil) (find-file "/mnt/Dropbox/research/work/society14/abstract.org" t) (write-file "/mnt/Dropbox/research/work/society14/paperv0.5.tex" t) (find-file "~/.zshrc" t) (find-file "~/.emacs.d/inits/00_default.el" t)))
(setq-default extended-command-history '("package-list-packages" "count-lines-region" "ispell-buffer" "eval-buffer" "yas-expand-from-trigger-key" "moccur-grep" "describe-variable" "describe-function" "auto-complete-mode" "describe-mode" "Buffer-menu-mode" "describe-key" "eval-defun" "pascal-mode"))
(setq-default helm-c-grep-history '("valid-file" "filename"))
(setq-default helm-c-source-complex-command-history '((name . "Complex Command History") (candidates lambda nil (mapcar (quote prin1-to-string) command-history)) (type . sexp)))
(setq-default helm-c-source-file-name-history '((name . "File Name History") (candidates . file-name-history) (persistent-action . ignore) (filtered-candidate-transformer . helm-file-name-history-transformer) (action ("Find file" . helm-find-many-files) ("Find file as root" . helm-find-file-as-root) ("Find file other window" . find-file-other-window) ("Find file other frame" . find-file-other-frame) ("Open dired in file's directory" . helm-open-dired) ("Grep File(s) `C-u recurse'" . helm-find-files-grep) ("Zgrep File(s) `C-u Recurse'" . helm-ff-zgrep) ("Pdfgrep File(s)" . helm-ff-pdfgrep) ("Insert as org link" . helm-files-insert-as-org-link) ("Checksum File" . helm-ff-checksum) ("Ediff File" . helm-find-files-ediff-files) ("Ediff Merge File" . helm-find-files-ediff-merge-files) ("Etags `M-., C-u tap, C-u C-u reload tag file'" . helm-ff-etags-select) ("View file" . view-file) ("Insert file" . insert-file) ("Delete file(s)" . helm-delete-marked-files) ("Open file externally (C-u to choose)" . helm-open-file-externally) ("Open file with default tool" . helm-open-file-with-default-tool) ("Find file in hex dump" . hexl-find-file))))
(setq-default helm-c-source-global-mark-ring '((name . "global-mark-ring") (candidates . helm-global-mark-ring-get-candidates) (action ("Goto line" lambda (candidate) (let ((items (split-string candidate ":"))) (helm-switch-to-buffer (cl-second items)) (helm-goto-line (string-to-number (car items)))))) (persistent-action lambda (candidate) (let ((items (split-string candidate ":"))) (helm-switch-to-buffer (cl-second items)) (helm-goto-line (string-to-number (car items))) (helm-highlight-current-line))) (persistent-help . "Show this line")))
(setq-default helm-c-source-kill-ring '((name . "Kill Ring") (init lambda nil (helm-attrset (quote last-command) last-command)) (candidates . helm-kill-ring-candidates) (filtered-candidate-transformer helm-kill-ring-transformer) (action ("Yank" . helm-kill-ring-action) ("Delete" lambda (candidate) (cl-loop for cand in (helm-marked-candidates) do (setq kill-ring (delete cand kill-ring))))) (keymap keymap (27 keymap (117 . helm-previous-line) (121 . helm-next-line)) keymap (menu-bar keymap (help-menu keymap (describe keymap (describe-mode . helm-help)))) (help keymap (109 . helm-help)) (f1 keymap (109 . helm-help)) (8 . delete-backward-char) (20 . helm-toggle-resplit-and-swap-windows) (C-tab . undefined) (triple-mouse-3 . ignore) (double-mouse-3 . ignore) (mouse-3 . ignore) (drag-mouse-3 . ignore) (down-mouse-3 . ignore) (triple-mouse-2 . ignore) (double-mouse-2 . ignore) (mouse-2 . ignore) (drag-mouse-2 . ignore) (down-mouse-2 . ignore) (triple-mouse-1 . ignore) (double-mouse-1 . ignore) (mouse-1 . ignore) (drag-mouse-1 . ignore) (down-mouse-1 . ignore) (67108897 . helm-toggle-suspend-update) (3 keymap (1 . all-from-helm-occur) (21 . helm-force-update) (6 . helm-follow-mode) (11 . helm-kill-selection-and-quit) (25 . helm-yank-selection) (4 . helm-delete-current-selection) (45 . helm-swap-windows)) (67108987 . helm-enlarge-window) (67108989 . helm-narrow-window) (19 . undefined) (18 . undefined) (23 . helm-yank-text-at-point) (24 keymap (2 . helm-resume-list-buffers-after-quit) (98 . helm-resume-previous-session-after-quit) (6 . helm-quit-and-find-file)) (11 . helm-delete-minibuffer-contents) (67108896 . helm-toggle-visible-mark) (0 . helm-toggle-visible-mark) (C-M-up . helm-scroll-other-window-down) (C-M-down . helm-scroll-other-window) (M-prior . helm-scroll-other-window-down) (M-next . helm-scroll-other-window) (12 . helm-recenter-top-bottom-other-window) (15 . helm-next-source) (10 . helm-select-3rd-action) (5 . helm-select-2nd-action-or-end-of-line) (26 . helm-execute-persistent-action) (9 . helm-select-action) (13 . helm-exit-minibuffer) (left . helm-previous-source) (right . helm-next-source) (7 . helm-keyboard-quit) (22 . helm-next-page) (27 keymap (110 . next-history-element) (112 . previous-history-element) (115 . undefined) (5 . helm-display-all-sources) (1 . helm-show-all-in-this-source-only) (117 . helm-unmark-all) (97 . helm-mark-all) (109 . helm-toggle-all-marks) (41 . helm-next-visible-mark) (40 . helm-prev-visible-mark) (91) (32 . helm-toggle-visible-mark) (33554454 . helm-scroll-other-window-down) (25 . helm-scroll-other-window-down) (22 . helm-scroll-other-window) (12 . helm-reposition-window-other-window) (62 . helm-end-of-buffer) (60 . helm-beginning-of-buffer) (118 . helm-previous-page)) (next . helm-next-page) (prior . helm-previous-page) (16 . helm-previous-line) (14 . helm-next-line) (up . helm-previous-line) (down . helm-next-line) keymap (26 . undefined) (18 . helm-minibuffer-history) (S-tab . zlc-select-previous) (backtab . zlc-select-previous) (menu-bar keymap (minibuf #1="Minibuf" keymap (previous menu-item "Previous History Item" previous-history-element :help "Put previous minibuffer history element in the minibuffer") (next menu-item "Next History Item" next-history-element :help "Put next minibuffer history element in the minibuffer") (isearch-backward menu-item "Isearch History Backward" isearch-backward :help "Incrementally search minibuffer history backward") (isearch-forward menu-item "Isearch History Forward" isearch-forward :help "Incrementally search minibuffer history forward") (return menu-item "Enter" exit-minibuffer :key-sequence "" :help "Terminate input and exit minibuffer") (quit menu-item "Quit" abort-recursive-edit :help "Abort input and exit minibuffer") #1#)) (10 . exit-minibuffer) (13 . exit-minibuffer) (7 . minibuffer-keyboard-quit) (C-tab . file-cache-minibuffer-complete) (9 . self-insert-command) (XF86Back . previous-history-element) (up . previous-history-element) (prior . previous-history-element) (XF86Forward . next-history-element) (down . next-history-element) (next . next-history-element) (27 keymap (63 . session-minibuffer-history-help) (114 . previous-matching-history-element) (115 . next-matching-history-element) (112 . previous-history-element) (110 . next-history-element))) (last-command . kill-region) (migemo) (multiline)))
(setq-default helm-c-source-mark-ring '((name . "mark-ring") (candidates . helm-mark-ring-get-candidates) (action ("Goto line" lambda (candidate) (helm-goto-line (string-to-number candidate)))) (persistent-action lambda (candidate) (helm-goto-line (string-to-number candidate)) (helm-highlight-current-line)) (persistent-help . "Show this line")))
(setq-default helm-c-source-minibuffer-history '((name . "Minibuffer History") (header-name lambda (name) (format "%s (%s)" name minibuffer-history-variable)) (candidates lambda nil (let ((history (cl-loop for i in (symbol-value minibuffer-history-variable) unless (string= "" i) collect i))) (if (consp (car history)) (mapcar (quote prin1-to-string) history) history))) (migemo) (multiline) (action lambda (candidate) (delete-minibuffer-contents) (insert candidate))))
(setq-default helm-ff-history '("/home/k-ohsugi/" "/mnt/Dropbox/.dropbox.cache/" "/mnt/Dropbox/configure/.emacs.d/inits/" "/mnt/Dropbox/research/meeting/" "/mnt/Dropbox/research/work/society14/" "/mnt/Dropbox/storage/" "/home/corgi/Dropbox/storage/" "/home/corgi/" "/mnt/Dropbox/" "/home/k-ohsugi/Dropbox/research/energy_result/icn_acm/" "/home/k-ohsugi/Dropbox/meeting/withHasegawa/GreenICN/utils/"))
(setq-default helm-grep-history '("valid-file" "filename"))
(setq-default helm-source--ff-file-name-history '((name . "File name history") (init lambda nil (with-helm-alive-p (when helm-ff-file-name-history-use-recentf (require (quote recentf)) (or recentf-mode (recentf-mode 1))))) (candidates lambda nil (if helm-ff-file-name-history-use-recentf recentf-list file-name-history)) (persistent-action . ignore) (filtered-candidate-transformer . helm-file-name-history-transformer) (action ("Find file" lambda (candidate) (helm-set-pattern (expand-file-name candidate)) (with-helm-after-update-hook (helm-exit-minibuffer))) ("Find file in helm" lambda (candidate) (helm-set-pattern (expand-file-name candidate))))))
(setq-default helm-source-comint-input-ring '((name . "Comint history") (candidates lambda nil (with-helm-current-buffer (ring-elements comint-input-ring))) (action . helm-comint-input-ring-action)))
(setq-default helm-source-complex-command-history '((name . "Complex Command History") (candidates lambda nil (mapcar (quote prin1-to-string) command-history)) (type . sexp)))
(setq-default helm-source-file-name-history '((name . "File Name History") (candidates . file-name-history) (persistent-action . ignore) (filtered-candidate-transformer . helm-file-name-history-transformer) (action ("Find file" . helm-find-many-files) ("Find file as root" . helm-find-file-as-root) ("Find file other window" . find-file-other-window) ("Find file other frame" . find-file-other-frame) ("Open dired in file's directory" . helm-open-dired) ("Grep File(s) `C-u recurse'" . helm-find-files-grep) ("Zgrep File(s) `C-u Recurse'" . helm-ff-zgrep) ("Pdfgrep File(s)" . helm-ff-pdfgrep) ("Insert as org link" . helm-files-insert-as-org-link) ("Checksum File" . helm-ff-checksum) ("Ediff File" . helm-find-files-ediff-files) ("Ediff Merge File" . helm-find-files-ediff-merge-files) ("Etags `M-., C-u tap, C-u C-u reload tag file'" . helm-ff-etags-select) ("View file" . view-file) ("Insert file" . insert-file) ("Delete file(s)" . helm-delete-marked-files) ("Open file externally (C-u to choose)" . helm-open-file-externally) ("Open file with default tool" . helm-open-file-with-default-tool) ("Find file in hex dump" . hexl-find-file))))
(setq-default helm-source-global-mark-ring '((name . "global-mark-ring") (candidates . helm-global-mark-ring-get-candidates) (action ("Goto line" lambda (candidate) (let ((items (split-string candidate ":"))) (helm-switch-to-buffer (cl-second items)) (helm-goto-line (string-to-number (car items)))))) (persistent-action lambda (candidate) (let ((items (split-string candidate ":"))) (helm-switch-to-buffer (cl-second items)) (helm-goto-line (string-to-number (car items))) (helm-highlight-current-line))) (persistent-help . "Show this line")))
(setq-default helm-source-kill-ring '((name . "Kill Ring") (init lambda nil (helm-attrset (quote last-command) last-command)) (candidates . helm-kill-ring-candidates) (filtered-candidate-transformer helm-kill-ring-transformer) (action ("Yank" . helm-kill-ring-action) ("Delete" lambda (candidate) (cl-loop for cand in (helm-marked-candidates) do (setq kill-ring (delete cand kill-ring))))) (keymap keymap (27 keymap (117 . helm-previous-line) (121 . helm-next-line)) keymap (menu-bar keymap (help-menu keymap (describe keymap (describe-mode . helm-help)))) (help keymap (109 . helm-help)) (f1 keymap (109 . helm-help)) (8 . delete-backward-char) (20 . helm-toggle-resplit-and-swap-windows) (C-tab . undefined) (triple-mouse-3 . ignore) (double-mouse-3 . ignore) (mouse-3 . ignore) (drag-mouse-3 . ignore) (down-mouse-3 . ignore) (triple-mouse-2 . ignore) (double-mouse-2 . ignore) (mouse-2 . ignore) (drag-mouse-2 . ignore) (down-mouse-2 . ignore) (triple-mouse-1 . ignore) (double-mouse-1 . ignore) (mouse-1 . ignore) (drag-mouse-1 . ignore) (down-mouse-1 . ignore) (67108897 . helm-toggle-suspend-update) (3 keymap (1 . all-from-helm-occur) (21 . helm-force-update) (6 . helm-follow-mode) (11 . helm-kill-selection-and-quit) (25 . helm-yank-selection) (4 . helm-delete-current-selection) (45 . helm-swap-windows)) (67108987 . helm-enlarge-window) (67108989 . helm-narrow-window) (19 . undefined) (18 . undefined) (23 . helm-yank-text-at-point) (24 keymap (2 . helm-resume-list-buffers-after-quit) (98 . helm-resume-previous-session-after-quit) (6 . helm-quit-and-find-file)) (11 . helm-delete-minibuffer-contents) (67108896 . helm-toggle-visible-mark) (0 . helm-toggle-visible-mark) (C-M-up . helm-scroll-other-window-down) (C-M-down . helm-scroll-other-window) (M-prior . helm-scroll-other-window-down) (M-next . helm-scroll-other-window) (12 . helm-recenter-top-bottom-other-window) (15 . helm-next-source) (10 . helm-select-3rd-action) (5 . helm-select-2nd-action-or-end-of-line) (26 . helm-execute-persistent-action) (9 . helm-select-action) (13 . helm-exit-minibuffer) (left . helm-previous-source) (right . helm-next-source) (7 . helm-keyboard-quit) (22 . helm-next-page) (27 keymap (110 . next-history-element) (112 . previous-history-element) (115 . undefined) (5 . helm-display-all-sources) (1 . helm-show-all-in-this-source-only) (117 . helm-unmark-all) (97 . helm-mark-all) (109 . helm-toggle-all-marks) (41 . helm-next-visible-mark) (40 . helm-prev-visible-mark) (91) (32 . helm-toggle-visible-mark) (33554454 . helm-scroll-other-window-down) (25 . helm-scroll-other-window-down) (22 . helm-scroll-other-window) (12 . helm-reposition-window-other-window) (62 . helm-end-of-buffer) (60 . helm-beginning-of-buffer) (118 . helm-previous-page)) (next . helm-next-page) (prior . helm-previous-page) (16 . helm-previous-line) (14 . helm-next-line) (up . helm-previous-line) (down . helm-next-line) keymap (26 . undefined) (18 . helm-minibuffer-history) (S-tab . zlc-select-previous) (backtab . zlc-select-previous) (menu-bar keymap (minibuf #1="Minibuf" keymap (previous menu-item "Previous History Item" previous-history-element :help "Put previous minibuffer history element in the minibuffer") (next menu-item "Next History Item" next-history-element :help "Put next minibuffer history element in the minibuffer") (isearch-backward menu-item "Isearch History Backward" isearch-backward :help "Incrementally search minibuffer history backward") (isearch-forward menu-item "Isearch History Forward" isearch-forward :help "Incrementally search minibuffer history forward") (return menu-item "Enter" exit-minibuffer :key-sequence "" :help "Terminate input and exit minibuffer") (quit menu-item "Quit" abort-recursive-edit :help "Abort input and exit minibuffer") #1#)) (10 . exit-minibuffer) (13 . exit-minibuffer) (7 . minibuffer-keyboard-quit) (C-tab . file-cache-minibuffer-complete) (9 . self-insert-command) (XF86Back . previous-history-element) (up . previous-history-element) (prior . previous-history-element) (XF86Forward . next-history-element) (down . next-history-element) (next . next-history-element) (27 keymap (63 . session-minibuffer-history-help) (114 . previous-matching-history-element) (115 . next-matching-history-element) (112 . previous-history-element) (110 . next-history-element))) (last-command . kill-region) (migemo) (multiline)))
(setq-default helm-source-mark-ring '((name . "mark-ring") (candidates . helm-mark-ring-get-candidates) (action ("Goto line" lambda (candidate) (helm-goto-line (string-to-number candidate)))) (persistent-action lambda (candidate) (helm-goto-line (string-to-number candidate)) (helm-highlight-current-line)) (persistent-help . "Show this line")))
(setq-default helm-source-minibuffer-history '((name . "Minibuffer History") (header-name lambda (name) (format "%s (%s)" name minibuffer-history-variable)) (candidates lambda nil (let ((history (cl-loop for i in (symbol-value minibuffer-history-variable) unless (string= "" i) collect i))) (if (consp (car history)) (mapcar (quote prin1-to-string) history) history))) (migemo) (multiline) (action lambda (candidate) (delete-minibuffer-contents) (insert candidate))))
(setq-default minibuffer-history '("cl" "-------" "abst" "org" "icn" "pack" "scfes" "helm" "evince paperv0.6.pdf" "tex" #("慮するよう拡張した．" 0 9 (fontified t) 9 10 (fontified t rear-nonsticky t)) #("のアクセスが消費する電力も考慮するよう拡張した．" 0 24 (fontified t)) "evince paperv0.5.pdf" "zshr" "/home/k-ohsugi/.ema" "/mnt/Dropbox/configure/.emacs.d/inits/" #("fig" 0 3 (fontified t face font-lock-comment-face)) "org-mode" "pac" "evince paperv0.4.pdf" "/mnt/Dropbox/research/meeting/" "/mnt/Dropbox/research/work/society14/paperv0.4.tex" "/mnt/Dropbox/storage/scfes.org" "evince paperv0.3.pdf" "7x2" "/home/corgi/Dropbox/storage/cloth.org" "/home/corgi/drop" "/mnt/Dropbox/research/work/society14/pap" "evince paper.pdf" #("mincho" 0 6 (fontified t)) "/mnt/Dropbox/research/work/society14/" "/mnt/Dropbox/" "figure" "rc.lua"))
(setq-default occur-collect-regexp-history '("\\1"))
(setq-default query-replace-history '("screen.count ()" "2" "time -p" "time" "3s" "10s" "${SIZE}" "1GB" "\"" "'" "NAME" "NAME1" "10MB" "1MB" "1024" "4096" "68" "204" "819" "COUNT" "NPARA" "50000" "10000" "45" "50" "research_2014_group_001-ccn.pdf" "research_group_001-icn.pdf" "M1" "B4" "M" "M2" "Master" "Doctor" "D3" "./figure/" "./"))
(setq-default regexp-history '("block" "blocksize"))
(setq-default search-ring '("in" "$" "ccn" "icn" "マルチコア" "31" "tex" "pdf" "ls_" "colors" "ls" "tmux" "prompt" "ssh" "shared"))
(setq-default serial-name-history '("/dev/ttyS0"))
(setq-default serial-speed-history '("9600" "1200" "2400" "4800" "14400" "19200" "28800" "38400" "57600" "115200"))
(setq-default shell-command-history '("'" "4096"))
(setq-default table-capture-columns-history '(""))
(setq-default table-capture-justify-history '("left"))
(setq-default table-capture-min-cell-width-history '("5"))
(setq-default table-cell-height-history '("1"))
(setq-default table-cell-span-direction-history '("right"))
(setq-default table-cell-split-contents-to-history '("split"))
(setq-default table-cell-split-orientation-history '("horizontally"))
(setq-default table-cell-width-history '("5"))
(setq-default table-col-delim-regexp-history '(""))
(setq-default table-columns-history '("3"))
(setq-default table-insert-row-column-history '("row"))
(setq-default table-justify-history '("center"))
(setq-default table-row-delim-regexp-history '(""))
(setq-default table-rows-history '("3"))
(setq-default table-sequence-count-history '("0"))
(setq-default table-sequence-increment-history '("1"))
(setq-default table-sequence-interval-history '("1"))
(setq-default table-sequence-justify-history '("left"))
(setq-default table-sequence-string-history '("0"))
(setq-default table-source-caption-history '("Table"))
(setq-default table-source-language-history '("html"))
(setq-default table-target-history '("cell"))
