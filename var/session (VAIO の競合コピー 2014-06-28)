;;; Automatically generated on Sat Jun 28 17:31:49 2014
;;; Invoked by k-ohsugi@VAIO using 24.3.1
(setq-default kill-ring '(#("tmp/clamd.log" 0 13 (fontified t)) #("\\ref{hoge}よ
り， 1 つの Interest パケットを処理するのに xxx クロック CPU が消費することが
分かっているため，" 0 1 (fontified t face #1=(font-lock-keyword-face font-latex-sedate-face)) 1 4 (fontified t face #1#) 4 5 (fontified t) 5 9 (fontified t face (font-lock-constant-face)) 9 11 (fontified t) 11 12 (fontified t) 12 13 (fontified t) 13 14 (fontified t) 14 15 (fontified t) 15 16 (fontified t) 16 17 (fontified t) 17 18 (fontified t) 18 19 (fontified t) 19 20 (fontified t) 20 21 (fontified t) 21 27 (fontified t) 27 28 (fontified t) 28 29 (fontified t) 29 30 (fontified t) 30 32 (fontified t) 32 39 (fontified t) 39 40 (fontified t) 40 41 (fontified t) 41 42 (fontified t) 42 43 (fontified t) 43 44 (fontified t) 44 45 (fontified t) 45 46 (fontified t) 46 48 (fontified t) 48 49 (fontified t) 49 50 (fontified t) 50 51 (fontified t) 51 52 (fontified t) 52 53 (fontified t) 53 54 (fontified t) 54 55 (fontified t) 55 63 (fontified t) 63 71 (fontified t) 71 72 (fontified t)) #("た．" 0 1 (fontified t) 1 2 (fontified t)) #("の測定
" 0 3 (fontified t) 3 4 (fontified t)) #("ただし， CPU の動作周波数の変動が消費電力に与える影響を除外するた
め， CPU の動作周波数を 1.6GHz に固定した．" 0 12 (fontified t) 12 13 (fontified t) 13 14 (fontified t) 14 34 (fontified t) 34 35 (fontified t) 35 36 (fontified t) 36 37 (fontified t) 37 38 (fontified t) 38 39 (fontified t) 39 40 (fontified t) 40 41 (fontified t) 41 42 (fontified t) 42 43 (fontified t) 43 46 (fontified t) 46 49 (fontified t) 49 50 (fontified t) 50 51 (fontified t) 51 52 (fontified t) 52 64 (fontified t)) #("を行わせた" 0 5 (fontified t)) #("クライアント-サーバ間で 1500Byte の UDP セグメントを" 0 11 (fontified t) 11 12 (fontified t) 12 13 (fontified t) 13 14 (fontified t) 14 20 (fontified t) 20 21 (fontified t) 21 22 (fontified t) 22 23 (fontified t) 23 24 (fontified t) 24 25 (fontified t) 25 26 (fontified t) 26 27 (fontified t) 27 28 (fontified t) 28 29 (fontified t) 29 34 (fontified t)) #("省電力" 0 3 (fontified t)) #("あるだろう．" 0 5 (fontified t) 5 6 (fontified t)) #("をを考慮" 0 1 (fontified t) 1 4 (fontified t)) #("他をスリープさせる必要
があるだろう．" 0 11 (fontified t) 11 12 (fontified t) 12 18 (fontified t) 18 19 (fontified t)) #("とな
" 0 2 (fontified t) 2 3 (fontified t)) #("測定結果は，
" 0 6 (fontified t) 6 7 (fontified t)) #("\\ref{fig:Pmem}" 0 4 (fontified t face (font-lock-keyword-face font-latex-sedate-face)) 4 5 (fontified t) 5 13 (fontified t face (font-lock-constant-face)) 13 14 (fontified t)) #("%\\usepackage{graphicx}
%\\usepackage{insertfig}
%\\usepackage{mediabb}
" 0 1 (font-lock-multiline t face font-lock-comment-delimiter-face fontified t) 1 12 (font-lock-multiline t face (font-lock-comment-face font-latex-sedate-face) fontified t) 12 22 (font-lock-multiline t face font-lock-comment-face fontified t) 22 23 (font-lock-multiline t fontified t) 23 24 (fontified t face font-lock-comment-delimiter-face font-lock-multiline t) 24 35 (fontified t face (font-lock-comment-face font-latex-sedate-face) font-lock-multiline t) 35 46 (fontified t face font-lock-comment-face font-lock-multiline t) 46 47 (font-lock-multiline t fontified t) 47 48 (fontified t face font-lock-comment-delimiter-face font-lock-multiline t) 48 59 (fontified t face (font-lock-comment-face font-latex-sedate-face) font-lock-multiline t) 59 68 (fontified t face font-lock-comment-face font-lock-multiline t) 68 69 (font-lock-multiline t fontified t)) #("
" 0 1 (fontified t)) #("


" 0 1 (fontified t) 1 2 (fontified t) 2 3 (fontified t)) #("本研究は〜" 0 5 (fontified t)) #("

" 0 1 (fontified t) 1 2 (fontified t)) #("
hoge" 0 1 (fontified t) 1 5 (fontified t)) #("\\begin{equation}
P_{router}(cores,rate_{IP}) = P_{cpu}(cores) + P_{mem}(bytes) + P_{nic}(rate_{IP}) + P_{IDLE}
\\end{equation}


" 0 6 (face (font-lock-keyword-face font-latex-sedate-face) fontified t) 6 7 (fontified t) 7 15 (face (font-lock-function-name-face) fontified t) 15 16 (fontified t rear-nonsticky t) 16 17 (face #2=(font-latex-math-face) font-lock-multiline t fontified t) 17 19 (face #2# font-lock-multiline t fontified t) 19 20 (face #3=(font-latex-math-face font-latex-subscript-face) font-lock-multiline t fontified t display #1=(raise -0.3)) 20 21 (face #3# font-lock-multiline t fontified t display #1#) 21 22 (face #3# font-lock-multiline t fontified t display #1#) 22 23 (face #3# font-lock-multiline t fontified t display #1#) 23 24 (face #3# font-lock-multiline t fontified t display #1#) 24 25 (face #3# font-lock-multiline t fontified t display #1#) 25 26 (face #3# font-lock-multiline t fontified t display #1#) 26 27 (face #3# font-lock-multiline t fontified t display #1#) 27 39 (face #2# font-lock-multiline t fontified t) 39 40 (face #4=(font-latex-math-face font-latex-subscript-face) font-lock-multiline t fontified t display #1#) 40 41 (face #4# font-lock-multiline t fontified t display #1#) 41 42 (face #4# font-lock-multiline t fontified t display #1#) 42 43 (face #4# font-lock-multiline t fontified t display #1#) 43 44 (face #2# font-lock-multiline t fontified t display nil) 44 49 (face #2# font-lock-multiline t fontified t) 49 50 (face #5=(font-latex-math-face font-latex-subscript-face) font-lock-multiline t fontified t display #1#) 50 51 (face #5# font-lock-multiline t fontified t display #1#) 51 52 (face #5# font-lock-multiline t fontified t display #1#) 52 53 (face #5# font-lock-multiline t fontified t display #1#) 53 54 (face #5# font-lock-multiline t fontified t display #1#) 54 60 (face #2# font-lock-multiline t fontified t) 60 61 (face #2# font-lock-multiline t fontified t) 61 62 (face #2# font-lock-multiline t fontified t) 62 66 (face #2# font-lock-multiline t fontified t) 66 67 (face #6=(font-latex-math-face font-latex-subscript-face) font-lock-multiline t fontified t display #1#) 67 68 (face #6# font-lock-multiline t fontified t display #1#) 68 71 (face #6# font-lock-multiline t fontified t display #1#) 71 77 (face #2# font-lock-multiline t fontified t) 77 78 (face #2# font-lock-multiline t fontified t) 78 79 (face #2# font-lock-multiline t fontified t) 79 81 (face #2# font-lock-multiline t fontified t) 81 83 (face #2# font-lock-multiline t fontified t) 83 84 (face #7=(font-latex-math-face font-latex-subscript-face) font-lock-multiline t fontified t display #1#) 84 85 (face #7# font-lock-multiline t fontified t display #1#) 85 86 (face #7# font-lock-multiline t fontified t display #1#) 86 87 (face #7# font-lock-multiline t fontified t display #1#) 87 88 (face #7# font-lock-multiline t fontified t display #1#) 88 94 (face #2# font-lock-multiline t fontified t) 94 95 (face #8=(font-latex-math-face font-latex-subscript-face) font-lock-multiline t fontified t display #1#) 95 96 (face #8# font-lock-multiline t fontified t display #1#) 96 97 (face #8# font-lock-multiline t fontified t display #1#) 97 98 (face #8# font-lock-multiline t fontified t display #1#) 98 99 (face #2# font-lock-multiline t fontified t display nil) 99 100 (face #2# font-lock-multiline t fontified t) 100 102 (face #2# font-lock-multiline t fontified t) 102 104 (face #2# font-lock-multiline t fontified t) 104 105 (face #9=(font-latex-math-face font-latex-subscript-face) font-lock-multiline t fontified t display #1#) 105 106 (face #9# font-lock-multiline t fontified t display #1#) 106 110 (face #9# font-lock-multiline t fontified t display #1#) 110 111 (face #2# font-lock-multiline t fontified t) 111 112 (font-lock-multiline t face #10=(font-lock-keyword-face font-latex-sedate-face) fontified t) 112 115 (font-lock-multiline t face #10# fontified t) 115 116 (font-lock-multiline t fontified t) 116 124 (font-lock-multiline t face (font-lock-function-name-face) fontified t) 124 125 (font-lock-multiline t fontified t rear-nonsticky t) 125 126 (fontified t rear-nonsticky t) 126 127 (fontified t) 127 128 (fontified t)) #("\\begin{equation}
P_{router}(cores,rate_{IP}) = P_{cpu}(cores) + P_{mem}(bytes) + P_{nic}(rate_{IP}) + P_{IDLE}
\\end{equation}
" 0 6 (face (font-lock-keyword-face font-latex-sedate-face) fontified t) 6 7 (fontified t) 7 15 (face (font-lock-function-name-face) fontified t) 15 16 (rear-nonsticky t fontified t) 16 17 (face #2=(font-latex-math-face) font-lock-multiline t fontified t) 17 19 (face #2# font-lock-multiline t fontified t) 19 20 (face #3=(font-latex-math-face font-latex-subscript-face) font-lock-multiline t display #1=(raise -0.3) fontified t) 20 21 (face #3# font-lock-multiline t display #1# fontified t) 21 22 (face #3# font-lock-multiline t display #1# fontified t) 22 23 (face #3# font-lock-multiline t display #1# fontified t) 23 24 (face #3# font-lock-multiline t display #1# fontified t) 24 25 (face #3# font-lock-multiline t display #1# fontified t) 25 26 (face #3# font-lock-multiline t display #1# fontified t) 26 27 (face #3# font-lock-multiline t display #1# fontified t) 27 39 (face #2# font-lock-multiline t fontified t) 39 40 (face #4=(font-latex-math-face font-latex-subscript-face) font-lock-multiline t display #1# fontified t) 40 41 (face #4# font-lock-multiline t display #1# fontified t) 41 42 (face #4# font-lock-multiline t display #1# fontified t) 42 43 (face #4# font-lock-multiline t display #1# fontified t) 43 44 (face #2# font-lock-multiline t display nil fontified t) 44 49 (face #2# font-lock-multiline t fontified t) 49 50 (face #5=(font-latex-math-face font-latex-subscript-face) font-lock-multiline t display #1# fontified t) 50 51 (face #5# font-lock-multiline t display #1# fontified t) 51 52 (face #5# font-lock-multiline t display #1# fontified t) 52 53 (face #5# font-lock-multiline t display #1# fontified t) 53 54 (face #5# font-lock-multiline t display #1# fontified t) 54 60 (face #2# font-lock-multiline t fontified t) 60 61 (face #2# font-lock-multiline t fontified t) 61 62 (face #2# font-lock-multiline t fontified t) 62 66 (face #2# font-lock-multiline t fontified t) 66 67 (face #6=(font-latex-math-face font-latex-subscript-face) font-lock-multiline t display #1# fontified t) 67 68 (face #6# font-lock-multiline t display #1# fontified t) 68 71 (face #6# font-lock-multiline t display #1# fontified t) 71 77 (face #2# font-lock-multiline t fontified t) 77 78 (face #2# font-lock-multiline t fontified t) 78 79 (face #2# font-lock-multiline t fontified t) 79 81 (face #2# font-lock-multiline t fontified t) 81 83 (face #2# font-lock-multiline t fontified t) 83 84 (face #7=(font-latex-math-face font-latex-subscript-face) font-lock-multiline t fontified t display #1#) 84 85 (face #7# font-lock-multiline t fontified t display #1#) 85 86 (face #7# font-lock-multiline t fontified t display #1#) 86 87 (face #7# font-lock-multiline t fontified t display #1#) 87 88 (face #7# font-lock-multiline t fontified t display #1#) 88 94 (face #2# font-lock-multiline t fontified t) 94 95 (face #8=(font-latex-math-face font-latex-subscript-face) font-lock-multiline t fontified t display #1#) 95 96 (face #8# font-lock-multiline t fontified t display #1#) 96 97 (face #8# font-lock-multiline t fontified t display #1#) 97 98 (face #8# font-lock-multiline t fontified t display #1#) 98 99 (face #2# font-lock-multiline t fontified t display nil) 99 100 (face #2# font-lock-multiline t fontified t) 100 102 (face #2# font-lock-multiline t fontified t) 102 104 (face #2# font-lock-multiline t fontified t) 104 105 (face #9=(font-latex-math-face font-latex-subscript-face) font-lock-multiline t fontified t display #1#) 105 106 (face #9# font-lock-multiline t fontified t display #1#) 106 110 (face #9# font-lock-multiline t fontified t display #1#) 110 111 (face #2# font-lock-multiline t fontified t) 111 112 (font-lock-multiline t face #10=(font-lock-keyword-face font-latex-sedate-face) fontified t) 112 115 (font-lock-multiline t face #10# fontified t) 115 116 (font-lock-multiline t fontified t) 116 124 (font-lock-multiline t face (font-lock-function-name-face) fontified t) 124 125 (font-lock-multiline t rear-nonsticky t fontified t) 125 126 (fontified t)) "\\begin{equation}" #("router" 0 1 (face (font-latex-math-face font-latex-subscript-face) display (raise -0.3) fontified t) 1 6 (face font-latex-math-face fontified t)) #("forwarding rate, i.e., rate IP [packet/s].
P router ( cores, rate IP ) = P cpu ( cores ) + P mem ( bytes )" 0 42 (fontified t) 42 43 (fontified t) 43 105 (fontified t) 105 106 (fontified t rear-nonsticky t)) "forwarding rate, i.e., rate IP [packet/s].
P router ( cores, rate IP ) = P cpu ( cores ) + P mem ( bytes )" "% Created 2014-06-23 Mon 18:01
\\documentclass[dvipdfmx,11pt]{beamer}
\\usepackage{url}
\\usepackage{pxjahyper}
\\usetheme{Berlin}
\\setbeamertemplate{navigation symbols}{}
\\beamertemplatetextbibitems
\\setbeamertemplate{footline}[frame number]
\\setbeamertemplate{headline}{}


\\institute[]{Osaka University\\\\
Graduate School of Information Science and Technology \\\\
Information Sharing Platform Laboratory \\\\
Master course second year}
\\usetheme{default}
\\author{大杉 海斗}
\\date{\\today}
\\title{ICN Meeting}
\\hypersetup{
  pdfkeywords={},
  pdfsubject={},
  pdfcreator={Emacs 24.3.1 (Org mode 8.2.7a)}}
\\begin{document}

\\maketitle

\\section{2014 年 6 月 17 日}
\\label{sec-1}
\\begin{frame}[label=sec-1-1]{進捗状況}
\\begin{itemize}
\\item 「 BFAST: Unified and Scalable Index for NDN Forwarding
Architecture 」を読み，自分のルーティングアルゴリズムに適用させる
方法を考えた
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-1-2]{BFAST: Unified and Scalable Index for NDN Forwarding Architecture の概要}
\\begin{itemize}
\\item FIB ・ PIT ・ CS のエントリを別々に探索するのは時間がかかるので，
これらのテーブルを同時に探索できるような unified index を提案して
いる
\\begin{itemize}
\\item unified index は， 3 つのテーブルと LPM (Longest Prefix Match)
・ EM (Exact Match) をサポートする
\\end{itemize}
\\item unified index のエントリは， CS ・ PIT ・ FIB のエントリへの
pointer と pointer が指すエントリの含まれるテーブルを表す type (CS ・
PIT ・ FIB のいずれか) を持つ
\\end{itemize}
\\centering
\\includegraphics[height=0.5\\textheight]{./figure/overview_unified_index.pdf}
\\end{frame}

\\begin{frame}[label=sec-1-3]{BFAST の提案}
\\begin{itemize}
\\item Unified Index を実現するために BFAST というデータ構造を提案する
\\begin{itemize}
\\item BFAST は， 2 つの Counting Bloom Filter とハッシュテーブルから
構成される
\\end{itemize}
\\end{itemize}
\\centering
\\includegraphics[width=0.7\\linewidth,height=0.7\\textheight]{./figure/bfast_comp.pdf}
\\end{frame}

\\begin{frame}[label=sec-1-4]{補足: (Counting) Bloom Filter}
\\begin{itemize}
\\item Counting Bloom Filter は Bloom Filter の実装の一種で，再生成せずに
要素を削除できるものである． Counting Bloom Filter では，配列の各
要素はビットから n ビットのカウンタに拡張されている．
\\item 要素の追加は各配列要素のインクリメントになり，参照は各配列要素がゼ
ロでないことを確認することになる．削除する場合，対応する配列要素の
カウンタをデクリメントすればよい．
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-5]{BFAST の提案までの流れ (1)}
\\begin{enumerate}
\\item 1 つのハッシュ関数にかけたハッシュ値の bucket にエントリを挿入するだ
けだとハッシュテーブルのバランスが悪くなる
\\item バランスを取るために， k 個 (図では k=3) のハッシュ関数にかけて
得られた k 個のハッシュ値のうちエントリ数が最小の bucket にエント
リを挿入することにする
\\item 各 bucket が持つエントリ数を別のテーブル Counter で管理することにする
\\begin{itemize}
\\item エントリ数が最小の bucket を見つけるために，すべての bucket の
エントリを辿らなくてよくなる
\\end{itemize}
\\end{enumerate}
\\centering
\\includegraphics[width=1.0\\linewidth,height=0.4\\textheight]{./figure/bfast_flow.pdf}
\\end{frame}

\\begin{frame}[label=sec-1-6]{BFAST の提案までの流れ (2): Counting Bloom Filter の導入}
\\begin{columns}
\\begin{column}{0.5\\textwidth}
\\begin{block}{概要図}%x
\\centering
\\includegraphics[height=0.4\\textheight]{./figure/hash_table_with_counting_bloom_filter.pdf}
\\begin{itemize}
\\item Counter を Counting Bloom Filter (CBF) にする
\\begin{itemize}
\\item CBF のエントリが 0 ならば，エントリが存在しない事が分かるため高
速で EM ・ LPM が可能
\\end{itemize}
\\end{itemize}
\\end{block}
\\end{column}

\\begin{column}{0.5\\textwidth}
\\begin{block}{挿入アルゴリズム}%x
\\includegraphics[height=0.48\\textheight]{./figure/Algorithm1.pdf}
\\begin{itemize}
\\item k: ハッシュ関数の個数
\\item $f_i$ (): ハッシュ関数
\\item $B_i$: i 番目の bucket
\\item $C_i$: $B_i$ のカウンタ
\\end{itemize}
\\end{block}
\\end{column}
\\end{columns}
\\end{frame}

\\begin{frame}[label=sec-1-7]{BFAST の提案までの流れ (3):}
\\begin{itemize}
\\item 前スライドの構造では，エントリの探索が上手く行かない
\\begin{itemize}
\\item k 個のハッシュ値のうち CBF が最小の bucket に該当するエントリが
あるとは限らないから
\\begin{itemize}
\\item 別のエントリを挿入するときに CBF がインクリメントさせる可能性が
あるから
\\end{itemize}
\\end{itemize}
\\item これを解決するため， auxiliary CBF (aCBF) を導入する
\\begin{itemize}
\\item エントリを挿入する時に，どのハッシュ関数が最小の C\\_i となる i
を導出したかを記録する
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-1-8]{完成版 BFAST}
\\begin{columns}
\\begin{column}{0.5\\textwidth}
\\begin{block}{概要図}%x
\\centering
\\includegraphics[width=.9\\linewidth]{./figure/bfast_comp.pdf}
\\end{block}
\\end{column}

\\begin{column}{0.5\\textwidth}
\\begin{block}{挿入アルゴリズム}%x
\\centering
\\includegraphics[width=0.99\\linewidth,height=0.55\\textheight]{./figure/bfast_insert.pdf}
\\end{block}
\\end{column}
\\end{columns}
\\end{frame}

\\begin{frame}[label=sec-1-9]{BFAST での探索と削除}
\\begin{columns}
\\begin{column}{0.5\\textwidth}
\\begin{block}{探索アルゴリズム}%x
\\centering
\\includegraphics[width=0.99\\linewidth,height=0.55\\textheight]{./figure/bfast_lookup.pdf}
\\begin{itemize}
\\item 探索要素を k 個のハッシュ関数にかけたハッシュ値をインデックスとし
た mCBF の要素に 0 があるならば，要素は存在しない (line 3-5)
\\end{itemize}
\\end{block}
\\end{column}

\\begin{column}{0.5\\textwidth}
\\begin{block}{削除アルゴリズム}%x
\\centering
\\includegraphics[width=0.99\\linewidth,height=0.55\\textheight]{./figure/bfast_delete.pdf}
\\begin{itemize}
\\item mCBF と aCBF の値をデクリメントする操作が抜けてるのでは?
\\end{itemize}
\\end{block}
\\end{column}
\\end{columns}
\\end{frame}

\\begin{frame}[label=sec-1-10]{BFAST における EM と LPM}
\\begin{itemize}
\\item EM は前ページの探索アルゴリズムで行える
\\item LPM は， prefix を fullname から 1 コンポネントずつ短くして EM と同
じ方法で行う
\\end{itemize}
\\centering
\\includegraphics[width=.9\\linewidth]{./figure/LPM.pdf}
\\end{frame}

\\begin{frame}[label=sec-1-11]{BFAST の Scalability と Extensibility}
\\begin{itemize}
\\item BFAST はテーブルを再構築せずに動的に拡張できる
\\begin{itemize}
\\item 格納する要素が増えると探索にかかる時間が増えてしまう
\\begin{itemize}
\\item mCBF の false positive の確率が上昇するため不要な lookup が増
える
\\item ハッシュテーブルのリンクを何度も辿ることになる
\\end{itemize}
\\item これを防ぐために，テーブルのテーブルの再構築を行うと，時間がかかる上
に，通常のパケットフォワーディングを阻害してしまう
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-12]{BFAST の拡張}
\\begin{itemize}
\\item BFAST の拡張前後では，異なる aCBF を用いる
\\begin{itemize}
\\item 要素の探索は， aCBF と aCBF'のどちらに要素があるかをチェックし
てから開始する
\\begin{itemize}
\\item ハッシュテーブル (および mCBF) へ要素の挿入位置が拡張前のハッ
シュテーブルの大きさ N と拡張後の N'で異なってくるため
\\end{itemize}
\\end{itemize}
\\end{itemize}

\\centering
\\includegraphics[width=0.8\\linewidth,height=0.6\\textheight]{./figure/extend_bfast.pdf}
\\end{frame}

\\begin{frame}[label=sec-1-13]{BFAST での NDN フォワーディングの全体像}
\\begin{itemize}
\\item prefix 自体は，テーブルエントリだけに格納して， unified index では
signature を用いる
\\begin{itemize}
\\item signature は， prefix をハッシュ関数にかけて生成する
\\begin{itemize}
\\item index のサイズを劇的位に小さく出来る
\\item エラーレートは無視できるほど小さい
\\end{itemize}
\\end{itemize}
\\item PIT と FIB を指す unified index のエントリは face 番号も格納する
\\begin{itemize}
\\item 探索速度向上のため
\\end{itemize}
\\end{itemize}

\\centering
\\includegraphics[width=0.9\\linewidth,height=0.55\\textheight]{./figure/NDN_with_bfast.pdf}
\\end{frame}

\\begin{frame}[label=sec-1-14]{いかにして BFAST を我々の NDN ルータモデルに導入するか}
\\begin{itemize}
\\item 我々の NDN ルータモデルのテーブル集合を BFAST に置きかえるだけでよ
い
\\begin{itemize}
\\item root prefix のハッシュ値で CPU に割り振る
\\begin{itemize}
\\item LPM を行う時に， 1 コンポネントずつ短い prefix を見ていくため，
LPM を同じ CPU で行えるようにしたい
\\end{itemize}
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-1-15]{}
\\end{frame}

\\section{2014 年 6 月 13 日}
\\label{sec-2}
\\begin{frame}[label=sec-2-1]{前回までのミーティングのまとめ}
\\begin{itemize}
\\item 現在は， ICN ルータの省電力化と ICN ネットワーク全体の省電力化を
どちらも考えているので，ルータの省電力化に焦点を当てる
\\item まずは，ルータの FIB ・ PIT ・ CS の構造を考えるため，関連研究の論
文を読む
\\begin{itemize}
\\item 電力効率のよいテーブル構造を議論したい
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-2-2]{進捗状況}
\\begin{itemize}
\\item 「 Scalable NDN Forwarding: Concepts, Issues and Principles 」を読み知
見を得た
\\begin{itemize}
\\item NDN のソフトウェアルータで 1Gbps を達成するためのルータの設計方
針が述べられている
\\end{itemize}
\\item 現在，「 BFAST: Unified and Scalable Index for NDN Forwarding Architecture 」
を読み進めている
\\begin{itemize}
\\item FIB ・ PIT ・ CS のエントリを別々に探索するのは時間がかかるので，
これらのテーブルを同時に探索できるような unified index を提案している
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-2-3]{現在の考えのまとめ}
\\begin{itemize}
\\item name prefix の長さに関わらず を固定長の prefix として扱う手法が必要である
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-2-4]{その他の探索アルゴリズム}
\\begin{itemize}
\\item FIB
\\begin{itemize}
\\item 2-stage LPM (Longest Prefix Match) algorithm
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-2-5]{2-stage LPM algorithm の概要}
\\begin{itemize}
\\item LPM を fullname ではなく，ある長さ $M$ の prefix から開始する
\\begin{itemize}
\\item マッチは fullname よりも大幅に短い prefix で発生しやすい
\\item マッチしなかった時，マッチにかかる時間は最悪となる
\\item LPM にかかる最悪の時間を一定時間以下に保証できる (マッチングする
回数が $M$ 以下のため)
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-2-6]{2-stage LPM algorithm の処理の流れ}
\\begin{enumerate}
\\item LPM を長さ $M$ の prefix から開始する
\\item マッチングなし: LPM 終了
\\item マッチングあり: 最大の長さ $MD$ からマッチするまで繰り返す
\\end{enumerate}
\\end{frame}
% Emacs 24.3.1 (Org mode 8.2.7a)
\\end{document}" #("** 前回までのミーティングのまとめ
   - 
" 0 1 (fontified t face org-level-2) 1 3 (fontified t face org-level-2) 3 18 (fontified t face org-level-2) 18 19 (fontified t) 19 24 (fontified t) 24 25 (fontified t)) "% Created 2014-06-23 Mon 17:20
\\documentclass[dvipdfmx,11pt]{beamer}
\\usepackage{url}
\\usepackage{pxjahyper}
\\usetheme{Berlin}
\\setbeamertemplate{navigation symbols}{}
\\beamertemplatetextbibitems
\\setbeamertemplate{footline}[frame number]
\\setbeamertemplate{headline}{}


\\institute[]{Osaka University\\\\
Graduate School of Information Science and Technology \\\\
Information Sharing Platform Laboratory \\\\
Master course second year}
\\usetheme{default}
\\author{大杉 海斗}
\\date{\\today}
\\title{ICN Meeting}
\\hypersetup{
  pdfkeywords={},
  pdfsubject={},
  pdfcreator={Emacs 24.3.1 (Org mode 8.2.7a)}}
\\begin{document}

\\maketitle

\\section{2014 年 6 月 17 日}
\\label{sec-1}
\\begin{frame}[label=sec-1-1]{前回までのミーティングのまとめ}
\\begin{itemize}
\\item 
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-1-2]{進捗状況}
\\begin{itemize}
\\item 「 BFAST: Unified and Scalable Index for NDN Forwarding
Architecture 」を読み，自分のルーティングアルゴリズムに適用させる
方法を考えた
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-1-3]{BFAST: Unified and Scalable Index for NDN Forwarding Architecture の概要}
\\begin{itemize}
\\item FIB ・ PIT ・ CS のエントリを別々に探索するのは時間がかかるので，
これらのテーブルを同時に探索できるような unified index を提案して
いる
\\begin{itemize}
\\item unified index は， 3 つのテーブルと LPM (Longest Prefix Match)
・ EM (Exact Match) をサポートする
\\end{itemize}
\\item unified index のエントリは， CS ・ PIT ・ FIB のエントリへの
pointer と pointer が指すエントリの含まれるテーブルを表す type (CS ・
PIT ・ FIB のいずれか) を持つ
\\end{itemize}
\\centering
\\includegraphics[height=0.5\\textheight]{./figure/overview_unified_index.pdf}
\\end{frame}

\\begin{frame}[label=sec-1-4]{BFAST の提案}
\\begin{itemize}
\\item Unified Index を実現するために BFAST というデータ構造を提案する
\\begin{itemize}
\\item BFAST は， 2 つの Counting Bloom Filter とハッシュテーブルから
構成される
\\end{itemize}
\\end{itemize}
\\centering
\\includegraphics[width=0.7\\linewidth,height=0.7\\textheight]{./figure/bfast_comp.pdf}
\\end{frame}

\\begin{frame}[label=sec-1-5]{補足: (Counting) Bloom Filter}
\\begin{itemize}
\\item Counting Bloom Filter は Bloom Filter の実装の一種で，再生成せずに
要素を削除できるものである． Counting Bloom Filter では，配列の各
要素はビットから n ビットのカウンタに拡張されている．
\\item 要素の追加は各配列要素のインクリメントになり，参照は各配列要素がゼ
ロでないことを確認することになる．削除する場合，対応する配列要素の
カウンタをデクリメントすればよい．
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-6]{BFAST の提案までの流れ (1)}
\\begin{enumerate}
\\item 1 つのハッシュ関数にかけたハッシュ値の bucket にエントリを挿入するだ
けだとハッシュテーブルのバランスが悪くなる
\\item バランスを取るために， k 個 (図では k=3) のハッシュ関数にかけて
得られた k 個のハッシュ値のうちエントリ数が最小の bucket にエント
リを挿入することにする
\\item 各 bucket が持つエントリ数を別のテーブル Counter で管理することにする
\\begin{itemize}
\\item エントリ数が最小の bucket を見つけるために，すべての bucket の
エントリを辿らなくてよくなる
\\end{itemize}
\\end{enumerate}
\\centering
\\includegraphics[width=1.0\\linewidth,height=0.4\\textheight]{./figure/bfast_flow.pdf}
\\end{frame}

\\begin{frame}[label=sec-1-7]{BFAST の提案までの流れ (2): Counting Bloom Filter の導入}
\\begin{columns}
\\begin{column}{0.5\\textwidth}
\\begin{block}{概要図}%x
\\centering
\\includegraphics[height=0.4\\textheight]{./figure/hash_table_with_counting_bloom_filter.pdf}
\\begin{itemize}
\\item Counter を Counting Bloom Filter (CBF) にする
\\begin{itemize}
\\item CBF のエントリが 0 ならば，エントリが存在しない事が分かるため高
速で EM ・ LPM が可能
\\end{itemize}
\\end{itemize}
\\end{block}
\\end{column}

\\begin{column}{0.5\\textwidth}
\\begin{block}{挿入アルゴリズム}%x
\\includegraphics[height=0.48\\textheight]{./figure/Algorithm1.pdf}
\\begin{itemize}
\\item k: ハッシュ関数の個数
\\item $f_i$ (): ハッシュ関数
\\item $B_i$: i 番目の bucket
\\item $C_i$: $B_i$ のカウンタ
\\end{itemize}
\\end{block}
\\end{column}
\\end{columns}
\\end{frame}

\\begin{frame}[label=sec-1-8]{BFAST の提案までの流れ (3):}
\\begin{itemize}
\\item 前スライドの構造では，エントリの探索が上手く行かない
\\begin{itemize}
\\item k 個のハッシュ値のうち CBF が最小の bucket に該当するエントリが
あるとは限らないから
\\begin{itemize}
\\item 別のエントリを挿入するときに CBF がインクリメントさせる可能性が
あるから
\\end{itemize}
\\end{itemize}
\\item これを解決するため， auxiliary CBF (aCBF) を導入する
\\begin{itemize}
\\item エントリを挿入する時に，どのハッシュ関数が最小の C\\_i となる i
を導出したかを記録する
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-1-9]{完成版 BFAST}
\\begin{columns}
\\begin{column}{0.5\\textwidth}
\\begin{block}{概要図}%x
\\centering
\\includegraphics[width=.9\\linewidth]{./figure/bfast_comp.pdf}
\\end{block}
\\end{column}

\\begin{column}{0.5\\textwidth}
\\begin{block}{挿入アルゴリズム}%x
\\centering
\\includegraphics[width=0.99\\linewidth,height=0.55\\textheight]{./figure/bfast_insert.pdf}
\\end{block}
\\end{column}
\\end{columns}
\\end{frame}

\\begin{frame}[label=sec-1-10]{BFAST での探索と削除}
\\begin{columns}
\\begin{column}{0.5\\textwidth}
\\begin{block}{探索アルゴリズム}%x
\\centering
\\includegraphics[width=0.99\\linewidth,height=0.55\\textheight]{./figure/bfast_lookup.pdf}
\\begin{itemize}
\\item 探索要素を k 個のハッシュ関数にかけたハッシュ値をインデックスとし
た mCBF の要素に 0 があるならば，要素は存在しない (line 3-5)
\\end{itemize}
\\end{block}
\\end{column}

\\begin{column}{0.5\\textwidth}
\\begin{block}{削除アルゴリズム}%x
\\centering
\\includegraphics[width=0.99\\linewidth,height=0.55\\textheight]{./figure/bfast_delete.pdf}
\\begin{itemize}
\\item mCBF と aCBF の値をデクリメントする操作が抜けてるのでは?
\\end{itemize}
\\end{block}
\\end{column}
\\end{columns}
\\end{frame}

\\begin{frame}[label=sec-1-11]{BFAST における EM と LPM}
\\begin{itemize}
\\item EM は前ページの探索アルゴリズムで行える
\\item LPM は， prefix を fullname から 1 コンポネントずつ短くして EM と同
じ方法で行う
\\end{itemize}
\\centering
\\includegraphics[width=.9\\linewidth]{./figure/LPM.pdf}
\\end{frame}

\\begin{frame}[label=sec-1-12]{BFAST の Scalability と Extensibility}
\\begin{itemize}
\\item BFAST はテーブルを再構築せずに動的に拡張できる
\\begin{itemize}
\\item 格納する要素が増えると探索にかかる時間が増えてしまう
\\begin{itemize}
\\item mCBF の false positive の確率が上昇するため不要な lookup が増
える
\\item ハッシュテーブルのリンクを何度も辿ることになる
\\end{itemize}
\\item これを防ぐために，テーブルのテーブルの再構築を行うと，時間がかかる上
に，通常のパケットフォワーディングを阻害してしまう
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-13]{BFAST の拡張}
\\begin{itemize}
\\item BFAST の拡張前後では，異なる aCBF を用いる
\\begin{itemize}
\\item 要素の探索は， aCBF と aCBF'のどちらに要素があるかをチェックし
てから開始する
\\begin{itemize}
\\item ハッシュテーブル (および mCBF) へ要素の挿入位置が拡張前のハッ
シュテーブルの大きさ N と拡張後の N'で異なってくるため
\\end{itemize}
\\end{itemize}
\\end{itemize}

\\centering
\\includegraphics[width=0.8\\linewidth,height=0.6\\textheight]{./figure/extend_bfast.pdf}
\\end{frame}

\\begin{frame}[label=sec-1-14]{BFAST での NDN フォワーディングの全体像}
\\begin{itemize}
\\item prefix 自体は，テーブルエントリだけに格納して， unified index では
signature を用いる
\\begin{itemize}
\\item signature は， prefix をハッシュ関数にかけて生成する
\\begin{itemize}
\\item index のサイズを劇的位に小さく出来る
\\item エラーレートは無視できるほど小さい
\\end{itemize}
\\end{itemize}
\\item PIT と FIB を指す unified index のエントリは face 番号も格納する
\\begin{itemize}
\\item 探索速度向上のため
\\end{itemize}
\\end{itemize}

\\centering
\\includegraphics[width=0.9\\linewidth,height=0.55\\textheight]{./figure/NDN_with_bfast.pdf}
\\end{frame}

\\begin{frame}[label=sec-1-15]{いかにして BFAST を我々の NDN ルータモデルに導入するか}
\\begin{itemize}
\\item 我々の NDN ルータモデルのテーブル集合を BFAST に置きかえるだけでよ
い
\\begin{itemize}
\\item root prefix のハッシュ値でテーブルに割り振る
\\begin{itemize}
\\item LPM を行う時に， 1 コンポネントずつ短い prefix を見ていくため，
LPM を同じ CPU で行えるようにしたい
\\end{itemize}
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-1-16]{}
\\end{frame}

\\section{2014 年 6 月 13 日}
\\label{sec-2}
\\begin{frame}[label=sec-2-1]{前回までのミーティングのまとめ}
\\begin{itemize}
\\item 現在は， ICN ルータの省電力化と ICN ネットワーク全体の省電力化を
どちらも考えているので，ルータの省電力化に焦点を当てる
\\item まずは，ルータの FIB ・ PIT ・ CS の構造を考えるため，関連研究の論
文を読む
\\begin{itemize}
\\item 電力効率のよいテーブル構造を議論したい
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-2-2]{進捗状況}
\\begin{itemize}
\\item 「 Scalable NDN Forwarding: Concepts, Issues and Principles 」を読み知
見を得た
\\begin{itemize}
\\item NDN のソフトウェアルータで 1Gbps を達成するためのルータの設計方
針が述べられている
\\end{itemize}
\\item 現在，「 BFAST: Unified and Scalable Index for NDN Forwarding Architecture 」
を読み進めている
\\begin{itemize}
\\item FIB ・ PIT ・ CS のエントリを別々に探索するのは時間がかかるので，
これらのテーブルを同時に探索できるような unified index を提案している
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-2-3]{現在の考えのまとめ}
\\begin{itemize}
\\item name prefix の長さに関わらず を固定長の prefix として扱う手法が必要である
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-2-4]{その他の探索アルゴリズム}
\\begin{itemize}
\\item FIB
\\begin{itemize}
\\item 2-stage LPM (Longest Prefix Match) algorithm
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-2-5]{2-stage LPM algorithm の概要}
\\begin{itemize}
\\item LPM を fullname ではなく，ある長さ $M$ の prefix から開始する
\\begin{itemize}
\\item マッチは fullname よりも大幅に短い prefix で発生しやすい
\\item マッチしなかった時，マッチにかかる時間は最悪となる
\\item LPM にかかる最悪の時間を一定時間以下に保証できる (マッチングする
回数が $M$ 以下のため)
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-2-6]{2-stage LPM algorithm の処理の流れ}
\\begin{enumerate}
\\item LPM を長さ $M$ の prefix から開始する
\\item マッチングなし: LPM 終了
\\item マッチングあり: 最大の長さ $MD$ からマッチするまで繰り返す
\\end{enumerate}
\\end{frame}
% Emacs 24.3.1 (Org mode 8.2.7a)
\\end{document}" "% Created 2014-06-23 Mon 17:20
\\documentclass[dvipdfmx,11pt]{beamer}
\\usepackage{url}
\\usepackage{pxjahyper}
\\usetheme{Berlin}
\\setbeamertemplate{navigation symbols}{}
\\beamertemplatetextbibitems
\\setbeamertemplate{footline}[frame number]
\\setbeamertemplate{headline}{}


\\institute[]{Osaka University\\\\
Graduate School of Information Science and Technology \\\\
Information Sharing Platform Laboratory \\\\
Master course second year}
\\usetheme{default}
\\author{大杉 海斗}
\\date{\\today}
\\title{ICN Meeting}
\\hypersetup{
  pdfkeywords={},
  pdfsubject={},
  pdfcreator={Emacs 24.3.1 (Org mode 8.2.7a)}}
\\begin{document}

\\maketitle

\\section{2014 年 6 月 17 日}
\\label{sec-1}
\\begin{frame}[label=sec-1-1]{前回までのミーティングのまとめ}
\\begin{itemize}
\\item 
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-1-2]{進捗状況}
\\begin{itemize}
\\item 「 BFAST: Unified and Scalable Index for NDN Forwarding
Architecture 」を読み，自分のルーティングアルゴリズムに適用させる
方法を考えた
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-1-3]{BFAST: Unified and Scalable Index for NDN Forwarding Architecture の概要}
\\begin{itemize}
\\item FIB ・ PIT ・ CS のエントリを別々に探索するのは時間がかかるので，
これらのテーブルを同時に探索できるような unified index を提案して
いる
\\begin{itemize}
\\item unified index は， 3 つのテーブルと LPM (Longest Prefix Match)
・ EM (Exact Match) をサポートする
\\end{itemize}
\\item unified index のエントリは， CS ・ PIT ・ FIB のエントリへの
pointer と pointer が指すエントリの含まれるテーブルを表す type (CS ・
PIT ・ FIB のいずれか) を持つ
\\end{itemize}
\\centering
\\includegraphics[height=0.5\\textheight]{./figure/overview_unified_index.pdf}
\\end{frame}

\\begin{frame}[label=sec-1-4]{BFAST の提案}
\\begin{itemize}
\\item Unified Index を実現するために BFAST というデータ構造を提案する
\\begin{itemize}
\\item BFAST は， 2 つの Counting Bloom Filter とハッシュテーブルから
構成される
\\end{itemize}
\\end{itemize}
\\centering
\\includegraphics[width=0.7\\linewidth,height=0.7\\textheight]{./figure/bfast_comp.pdf}
\\end{frame}

\\begin{frame}[label=sec-1-5]{補足: (Counting) Bloom Filter}
\\begin{itemize}
\\item Counting Bloom Filter は Bloom Filter の実装の一種で，再生成せずに
要素を削除できるものである． Counting Bloom Filter では，配列の各
要素はビットから n ビットのカウンタに拡張されている．
\\item 要素の追加は各配列要素のインクリメントになり，参照は各配列要素がゼ
ロでないことを確認することになる．削除する場合，対応する配列要素の
カウンタをデクリメントすればよい．
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-6]{BFAST の提案までの流れ (1)}
\\begin{enumerate}
\\item 1 つのハッシュ関数にかけたハッシュ値の bucket にエントリを挿入するだ
けだとハッシュテーブルのバランスが悪くなる
\\item バランスを取るために， k 個 (図では k=3) のハッシュ関数にかけて
得られた k 個のハッシュ値のうちエントリ数が最小の bucket にエント
リを挿入することにする
\\item 各 bucket が持つエントリ数を別のテーブル Counter で管理することにする
\\begin{itemize}
\\item エントリ数が最小の bucket を見つけるために，すべての bucket の
エントリを辿らなくてよくなる
\\end{itemize}
\\end{enumerate}
\\centering
\\includegraphics[width=1.0\\linewidth,height=0.4\\textheight]{./figure/bfast_flow.pdf}
\\end{frame}

\\begin{frame}[label=sec-1-7]{BFAST の提案までの流れ (2): Counting Bloom Filter の導入}
\\begin{columns}
\\begin{column}{0.5\\textwidth}
\\begin{block}{概要図}%x
\\centering
\\includegraphics[height=0.4\\textheight]{./figure/hash_table_with_counting_bloom_filter.pdf}
\\begin{itemize}
\\item Counter を Counting Bloom Filter (CBF) にする
\\begin{itemize}
\\item CBF のエントリが 0 ならば，エントリが存在しない事が分かるため高
速で EM ・ LPM が可能
\\end{itemize}
\\end{itemize}
\\end{block}
\\end{column}

\\begin{column}{0.5\\textwidth}
\\begin{block}{挿入アルゴリズム}%x
\\includegraphics[height=0.48\\textheight]{./figure/Algorithm1.pdf}
\\begin{itemize}
\\item k: ハッシュ関数の個数
\\item $f_i$ (): ハッシュ関数
\\item $B_i$: i 番目の bucket
\\item $C_i$: $B_i$ のカウンタ
\\end{itemize}
\\end{block}
\\end{column}
\\end{columns}
\\end{frame}

\\begin{frame}[label=sec-1-8]{BFAST の提案までの流れ (3):}
\\begin{itemize}
\\item 前スライドの構造では，エントリの探索が上手く行かない
\\begin{itemize}
\\item k 個のハッシュ値のうち CBF が最小の bucket に該当するエントリが
あるとは限らないから
\\begin{itemize}
\\item 別のエントリを挿入するときに CBF がインクリメントさせる可能性が
あるから
\\end{itemize}
\\end{itemize}
\\item これを解決するため， auxiliary CBF (aCBF) を導入する
\\begin{itemize}
\\item エントリを挿入する時に，どのハッシュ関数が最小の C\\_i となる i
を導出したかを記録する
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-1-9]{完成版 BFAST}
\\begin{columns}
\\begin{column}{0.5\\textwidth}
\\begin{block}{概要図}%x
\\centering
\\includegraphics[width=.9\\linewidth]{./figure/bfast_comp.pdf}
\\end{block}
\\end{column}

\\begin{column}{0.5\\textwidth}
\\begin{block}{挿入アルゴリズム}%x
\\centering
\\includegraphics[width=0.99\\linewidth,height=0.55\\textheight]{./figure/bfast_insert.pdf}
\\end{block}
\\end{column}
\\end{columns}
\\end{frame}

\\begin{frame}[label=sec-1-10]{BFAST での探索と削除}
\\begin{columns}
\\begin{column}{0.5\\textwidth}
\\begin{block}{探索アルゴリズム}%x
\\centering
\\includegraphics[width=0.99\\linewidth,height=0.55\\textheight]{./figure/bfast_lookup.pdf}
\\begin{itemize}
\\item 探索要素を k 個のハッシュ関数にかけたハッシュ値をインデックスとし
た mCBF の要素に 0 があるならば，要素は存在しない (line 3-5)
\\end{itemize}
\\end{block}
\\end{column}

\\begin{column}{0.5\\textwidth}
\\begin{block}{削除アルゴリズム}%x
\\centering
\\includegraphics[width=0.99\\linewidth,height=0.55\\textheight]{./figure/bfast_delete.pdf}
\\begin{itemize}
\\item mCBF と aCBF の値をデクリメントする操作が抜けてるのでは?
\\end{itemize}
\\end{block}
\\end{column}
\\end{columns}
\\end{frame}

\\begin{frame}[label=sec-1-11]{BFAST における EM と LPM}
\\begin{itemize}
\\item EM は前ページの探索アルゴリズムで行える
\\item LPM は， prefix を fullname から 1 コンポネントずつ短くして EM と同
じ方法で行う
\\end{itemize}
\\centering
\\includegraphics[width=.9\\linewidth]{./figure/LPM.pdf}
\\end{frame}

\\begin{frame}[label=sec-1-12]{BFAST の Scalability と Extensibility}
\\begin{itemize}
\\item BFAST はテーブルを再構築せずに動的に拡張できる
\\begin{itemize}
\\item 格納する要素が増えると探索にかかる時間が増えてしまう
\\begin{itemize}
\\item mCBF の false positive の確率が上昇するため不要な lookup が増
える
\\item ハッシュテーブルのリンクを何度も辿ることになる
\\end{itemize}
\\item これを防ぐために，テーブルのテーブルの再構築を行うと，時間がかかる上
に，通常のパケットフォワーディングを阻害してしまう
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-13]{BFAST の拡張}
\\begin{itemize}
\\item BFAST の拡張前後では，異なる aCBF を用いる
\\begin{itemize}
\\item 要素の探索は， aCBF と aCBF'のどちらに要素があるかをチェックし
てから開始する
\\begin{itemize}
\\item ハッシュテーブル (および mCBF) へ要素の挿入位置が拡張前のハッ
シュテーブルの大きさ N と拡張後の N'で異なってくるため
\\end{itemize}
\\end{itemize}
\\end{itemize}

\\centering
\\includegraphics[width=0.8\\linewidth,height=0.6\\textheight]{./figure/extend_bfast.pdf}
\\end{frame}

\\begin{frame}[label=sec-1-14]{BFAST での NDN フォワーディングの全体像}
\\begin{itemize}
\\item prefix 自体は，テーブルエントリだけに格納して， unified index では
signature を用いる
\\begin{itemize}
\\item signature は， prefix をハッシュ関数にかけて生成する
\\begin{itemize}
\\item index のサイズを劇的位に小さく出来る
\\item エラーレートは無視できるほど小さい
\\end{itemize}
\\end{itemize}
\\item PIT と FIB を指す unified index のエントリは face 番号も格納する
\\begin{itemize}
\\item 探索速度向上のため
\\end{itemize}
\\end{itemize}

\\centering
\\includegraphics[width=0.9\\linewidth,height=0.55\\textheight]{./figure/NDN_with_bfast.pdf}
\\end{frame}

\\begin{frame}[label=sec-1-15]{いかにして BFAST を我々の NDN ルータモデルに導入するか}
\\begin{itemize}
\\item 我々の NDN ルータモデルの CCNx のテーブルを BFAST に置きかえるだけでよ
い
\\begin{itemize}
\\item root prefix のハッシュ値でテーブルに割り振る
\\begin{itemize}
\\item LPM を行う時に， 1 コンポネントずつ短い prefix を見ていくため，
LPM を同じ CPU で行えるようにしたい
\\end{itemize}
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-1-16]{}
\\end{frame}

\\section{2014 年 6 月 13 日}
\\label{sec-2}
\\begin{frame}[label=sec-2-1]{前回までのミーティングのまとめ}
\\begin{itemize}
\\item 現在は， ICN ルータの省電力化と ICN ネットワーク全体の省電力化を
どちらも考えているので，ルータの省電力化に焦点を当てる
\\item まずは，ルータの FIB ・ PIT ・ CS の構造を考えるため，関連研究の論
文を読む
\\begin{itemize}
\\item 電力効率のよいテーブル構造を議論したい
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-2-2]{進捗状況}
\\begin{itemize}
\\item 「 Scalable NDN Forwarding: Concepts, Issues and Principles 」を読み知
見を得た
\\begin{itemize}
\\item NDN のソフトウェアルータで 1Gbps を達成するためのルータの設計方
針が述べられている
\\end{itemize}
\\item 現在，「 BFAST: Unified and Scalable Index for NDN Forwarding Architecture 」
を読み進めている
\\begin{itemize}
\\item FIB ・ PIT ・ CS のエントリを別々に探索するのは時間がかかるので，
これらのテーブルを同時に探索できるような unified index を提案している
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-2-3]{現在の考えのまとめ}
\\begin{itemize}
\\item name prefix の長さに関わらず を固定長の prefix として扱う手法が必要である
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-2-4]{その他の探索アルゴリズム}
\\begin{itemize}
\\item FIB
\\begin{itemize}
\\item 2-stage LPM (Longest Prefix Match) algorithm
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-2-5]{2-stage LPM algorithm の概要}
\\begin{itemize}
\\item LPM を fullname ではなく，ある長さ $M$ の prefix から開始する
\\begin{itemize}
\\item マッチは fullname よりも大幅に短い prefix で発生しやすい
\\item マッチしなかった時，マッチにかかる時間は最悪となる
\\item LPM にかかる最悪の時間を一定時間以下に保証できる (マッチングする
回数が $M$ 以下のため)
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-2-6]{2-stage LPM algorithm の処理の流れ}
\\begin{enumerate}
\\item LPM を長さ $M$ の prefix から開始する
\\item マッチングなし: LPM 終了
\\item マッチングあり: 最大の長さ $MD$ からマッチするまで繰り返す
\\end{enumerate}
\\end{frame}
% Emacs 24.3.1 (Org mode 8.2.7a)
\\end{document}" "% Created 2014-06-23 Mon 17:18
\\documentclass[dvipdfmx,11pt]{beamer}
\\usepackage{url}
\\usepackage{pxjahyper}
\\usetheme{Berlin}
\\setbeamertemplate{navigation symbols}{}
\\beamertemplatetextbibitems
\\setbeamertemplate{footline}[frame number]
\\setbeamertemplate{headline}{}


\\institute[]{Osaka University\\\\
Graduate School of Information Science and Technology \\\\
Information Sharing Platform Laboratory \\\\
Master course second year}
\\usetheme{default}
\\author{大杉 海斗}
\\date{\\today}
\\title{ICN Meeting}
\\hypersetup{
  pdfkeywords={},
  pdfsubject={},
  pdfcreator={Emacs 24.3.1 (Org mode 8.2.7a)}}
\\begin{document}

\\maketitle

\\section{2014 年 6 月 17 日}
\\label{sec-1}
\\begin{frame}[label=sec-1-1]{前回までのミーティングのまとめ}
\\begin{itemize}
\\item 
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-1-2]{進捗状況}
\\begin{itemize}
\\item 「 BFAST: Unified and Scalable Index for NDN Forwarding
Architecture 」を読み，自分のルーティングアルゴリズムに適用させる
方法を考えた
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-1-3]{BFAST: Unified and Scalable Index for NDN Forwarding Architecture の概要}
\\begin{itemize}
\\item FIB ・ PIT ・ CS のエントリを別々に探索するのは時間がかかるので，
これらのテーブルを同時に探索できるような unified index を提案して
いる
\\begin{itemize}
\\item unified index は， 3 つのテーブルと LPM (Longest Prefix Match)
・ EM (Exact Match) をサポートする
\\end{itemize}
\\item unified index のエントリは， CS ・ PIT ・ FIB のエントリへの
pointer と pointer が指すエントリの含まれるテーブルを表す type (CS ・
PIT ・ FIB のいずれか) を持つ
\\end{itemize}
\\centering
\\includegraphics[height=0.5\\textheight]{./figure/overview_unified_index.pdf}
\\end{frame}

\\begin{frame}[label=sec-1-4]{BFAST の提案}
\\begin{itemize}
\\item Unified Index を実現するために BFAST というデータ構造を提案する
\\begin{itemize}
\\item BFAST は， 2 つの Counting Bloom Filter とハッシュテーブルから
構成される
\\end{itemize}
\\end{itemize}
\\centering
\\includegraphics[width=0.7\\linewidth,height=0.7\\textheight]{./figure/bfast_comp.pdf}
\\end{frame}

\\begin{frame}[label=sec-1-5]{補足: (Counting) Bloom Filter}
\\begin{itemize}
\\item Counting Bloom Filter は Bloom Filter の実装の一種で，再生成せずに
要素を削除できるものである． Counting Bloom Filter では，配列の各
要素はビットから n ビットのカウンタに拡張されている．
\\item 要素の追加は各配列要素のインクリメントになり，参照は各配列要素がゼ
ロでないことを確認することになる．削除する場合，対応する配列要素の
カウンタをデクリメントすればよい．
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-6]{BFAST の提案までの流れ (1)}
\\begin{enumerate}
\\item 1 つのハッシュ関数にかけたハッシュ値の bucket にエントリを挿入するだ
けだとハッシュテーブルのバランスが悪くなる
\\item バランスを取るために， k 個 (図では k=3) のハッシュ関数にかけて
得られた k 個のハッシュ値のうちエントリ数が最小の bucket にエント
リを挿入することにする
\\item 各 bucket が持つエントリ数を別のテーブル Counter で管理することにする
\\begin{itemize}
\\item エントリ数が最小の bucket を見つけるために，すべての bucket の
エントリを辿らなくてよくなる
\\end{itemize}
\\end{enumerate}
\\centering
\\includegraphics[width=1.0\\linewidth,height=0.4\\textheight]{./figure/bfast_flow.pdf}
\\end{frame}

\\begin{frame}[label=sec-1-7]{BFAST の提案までの流れ (2): Counting Bloom Filter の導入}
\\begin{columns}
\\begin{column}{0.5\\textwidth}
\\begin{block}{概要図}%x
\\centering
\\includegraphics[height=0.4\\textheight]{./figure/hash_table_with_counting_bloom_filter.pdf}
\\begin{itemize}
\\item Counter を Counting Bloom Filter (CBF) にする
\\begin{itemize}
\\item CBF のエントリが 0 ならば，エントリが存在しない事が分かるため高
速で EM ・ LPM が可能
\\end{itemize}
\\end{itemize}
\\end{block}
\\end{column}

\\begin{column}{0.5\\textwidth}
\\begin{block}{挿入アルゴリズム}%x
\\includegraphics[height=0.48\\textheight]{./figure/Algorithm1.pdf}
\\begin{itemize}
\\item k: ハッシュ関数の個数
\\item $f_i$ (): ハッシュ関数
\\item $B_i$: i 番目の bucket
\\item $C_i$: $B_i$ のカウンタ
\\end{itemize}
\\end{block}
\\end{column}
\\end{columns}
\\end{frame}

\\begin{frame}[label=sec-1-8]{BFAST の提案までの流れ (3):}
\\begin{itemize}
\\item 前スライドの構造では，エントリの探索が上手く行かない
\\begin{itemize}
\\item k 個のハッシュ値のうち CBF が最小の bucket に該当するエントリが
あるとは限らないから
\\begin{itemize}
\\item 別のエントリを挿入するときに CBF がインクリメントさせる可能性が
あるから
\\end{itemize}
\\end{itemize}
\\item これを解決するため， auxiliary CBF (aCBF) を導入する
\\begin{itemize}
\\item エントリを挿入する時に，どのハッシュ関数が最小の C\\_i となる i
を導出したかを記録する
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-1-9]{完成版 BFAST}
\\begin{columns}
\\begin{column}{0.5\\textwidth}
\\begin{block}{概要図}%x
\\centering
\\includegraphics[width=.9\\linewidth]{./figure/bfast_comp.pdf}
\\end{block}
\\end{column}

\\begin{column}{0.5\\textwidth}
\\begin{block}{挿入アルゴリズム}%x
\\centering
\\includegraphics[width=0.99\\linewidth,height=0.55\\textheight]{./figure/bfast_insert.pdf}
\\end{block}
\\end{column}
\\end{columns}
\\end{frame}

\\begin{frame}[label=sec-1-10]{BFAST での探索と削除}
\\begin{columns}
\\begin{column}{0.5\\textwidth}
\\begin{block}{探索アルゴリズム}%x
\\centering
\\includegraphics[width=0.99\\linewidth,height=0.55\\textheight]{./figure/bfast_lookup.pdf}
\\begin{itemize}
\\item 探索要素を k 個のハッシュ関数にかけたハッシュ値をインデックスとし
た mCBF の要素に 0 があるならば，要素は存在しない (line 3-5)
\\end{itemize}
\\end{block}
\\end{column}

\\begin{column}{0.5\\textwidth}
\\begin{block}{削除アルゴリズム}%x
\\centering
\\includegraphics[width=0.99\\linewidth,height=0.55\\textheight]{./figure/bfast_delete.pdf}
\\begin{itemize}
\\item mCBF と aCBF の値をデクリメントする操作が抜けてるのでは?
\\end{itemize}
\\end{block}
\\end{column}
\\end{columns}
\\end{frame}

\\begin{frame}[label=sec-1-11]{BFAST における EM と LPM}
\\begin{itemize}
\\item EM は前ページの探索アルゴリズムで行える
\\item LPM は， prefix を fullname から 1 コンポネントずつ短くして EM と同
じ方法で行う
\\end{itemize}
\\centering
\\includegraphics[width=.9\\linewidth]{./figure/LPM.pdf}
\\end{frame}

\\begin{frame}[label=sec-1-12]{BFAST の Scalability と Extensibility}
\\begin{itemize}
\\item BFAST はテーブルを再構築せずに動的に拡張できる
\\begin{itemize}
\\item 格納する要素が増えると探索にかかる時間が増えてしまう
\\begin{itemize}
\\item mCBF の false positive の確率が上昇するため不要な lookup が増
える
\\item ハッシュテーブルのリンクを何度も辿ることになる
\\end{itemize}
\\item これを防ぐために，テーブルのテーブルの再構築を行うと，時間がかかる上
に，通常のパケットフォワーディングを阻害してしまう
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-13]{BFAST の拡張}
\\begin{itemize}
\\item BFAST の拡張前後では，異なる aCBF を用いる
\\begin{itemize}
\\item 要素の探索は， aCBF と aCBF'のどちらに要素があるかをチェックし
てから開始する
\\begin{itemize}
\\item ハッシュテーブル (および mCBF) へ要素の挿入位置が拡張前のハッ
シュテーブルの大きさ N と拡張後の N'で異なってくるため
\\end{itemize}
\\end{itemize}
\\end{itemize}

\\centering
\\includegraphics[width=0.8\\linewidth,height=0.6\\textheight]{./figure/extend_bfast.pdf}
\\end{frame}

\\begin{frame}[label=sec-1-14]{BFAST での NDN フォワーディングの全体像}
\\begin{itemize}
\\item prefix 自体は，テーブルエントリだけに格納して， unified index では
signature を用いる
\\begin{itemize}
\\item signature は， prefix をハッシュ関数にかけて生成する
\\begin{itemize}
\\item index のサイズを劇的位に小さく出来る
\\item エラーレートは無視できるほど小さい
\\end{itemize}
\\end{itemize}
\\item PIT と FIB を指す unified index のエントリは face 番号も格納する
\\begin{itemize}
\\item 探索速度向上のため
\\end{itemize}
\\end{itemize}

\\centering
\\includegraphics[width=0.9\\linewidth,height=0.55\\textheight]{./figure/NDN_with_bfast.pdf}
\\end{frame}

\\begin{frame}[label=sec-1-15]{いかにして BFAST を我々の NDN ルータモデルに導入するか}
\\begin{itemize}
\\item 我々の NDN ルータモデルの CCNx のテーブルを BFAST に置きかえるだけでよ
い
\\begin{itemize}
\\item LPM を行う時に， 1 コンポネントずつ短い prefix を見ていくため
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-1-16]{}
\\end{frame}

\\section{2014 年 6 月 13 日}
\\label{sec-2}
\\begin{frame}[label=sec-2-1]{前回までのミーティングのまとめ}
\\begin{itemize}
\\item 現在は， ICN ルータの省電力化と ICN ネットワーク全体の省電力化を
どちらも考えているので，ルータの省電力化に焦点を当てる
\\item まずは，ルータの FIB ・ PIT ・ CS の構造を考えるため，関連研究の論
文を読む
\\begin{itemize}
\\item 電力効率のよいテーブル構造を議論したい
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-2-2]{進捗状況}
\\begin{itemize}
\\item 「 Scalable NDN Forwarding: Concepts, Issues and Principles 」を読み知
見を得た
\\begin{itemize}
\\item NDN のソフトウェアルータで 1Gbps を達成するためのルータの設計方
針が述べられている
\\end{itemize}
\\item 現在，「 BFAST: Unified and Scalable Index for NDN Forwarding Architecture 」
を読み進めている
\\begin{itemize}
\\item FIB ・ PIT ・ CS のエントリを別々に探索するのは時間がかかるので，
これらのテーブルを同時に探索できるような unified index を提案している
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-2-3]{現在の考えのまとめ}
\\begin{itemize}
\\item name prefix の長さに関わらず を固定長の prefix として扱う手法が必要である
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-2-4]{その他の探索アルゴリズム}
\\begin{itemize}
\\item FIB
\\begin{itemize}
\\item 2-stage LPM (Longest Prefix Match) algorithm
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-2-5]{2-stage LPM algorithm の概要}
\\begin{itemize}
\\item LPM を fullname ではなく，ある長さ $M$ の prefix から開始する
\\begin{itemize}
\\item マッチは fullname よりも大幅に短い prefix で発生しやすい
\\item マッチしなかった時，マッチにかかる時間は最悪となる
\\item LPM にかかる最悪の時間を一定時間以下に保証できる (マッチングする
回数が $M$ 以下のため)
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-2-6]{2-stage LPM algorithm の処理の流れ}
\\begin{enumerate}
\\item LPM を長さ $M$ の prefix から開始する
\\item マッチングなし: LPM 終了
\\item マッチングあり: 最大の長さ $MD$ からマッチするまで繰り返す
\\end{enumerate}
\\end{frame}
% Emacs 24.3.1 (Org mode 8.2.7a)
\\end{document}" "% Created 2014-06-23 Mon 15:44
\\documentclass[dvipdfmx,11pt]{beamer}
\\usepackage{url}
\\usepackage{pxjahyper}
\\usetheme{Berlin}
\\setbeamertemplate{navigation symbols}{}
\\beamertemplatetextbibitems
\\setbeamertemplate{footline}[frame number]
\\setbeamertemplate{headline}{}


\\institute[]{Osaka University\\\\
Graduate School of Information Science and Technology \\\\
Information Sharing Platform Laboratory \\\\
Master course second year}
\\usetheme{default}
\\author{大杉 海斗}
\\date{\\today}
\\title{ICN Meeting}
\\hypersetup{
  pdfkeywords={},
  pdfsubject={},
  pdfcreator={Emacs 24.3.1 (Org mode 8.2.7a)}}
\\begin{document}

\\maketitle

\\section{2014 年 6 月 17 日}
\\label{sec-1}
\\begin{frame}[label=sec-1-1]{前回までのミーティングのまとめ}
\\begin{itemize}
\\item 
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-1-2]{進捗状況}
\\begin{itemize}
\\item 「 BFAST: Unified and Scalable Index for NDN Forwarding
Architecture 」を読み，自分のルーティングアルゴリズムに適用させる
方法を考えた
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-1-3]{BFAST: Unified and Scalable Index for NDN Forwarding Architecture の概要}
\\begin{itemize}
\\item FIB ・ PIT ・ CS のエントリを別々に探索するのは時間がかかるので，
これらのテーブルを同時に探索できるような unified index を提案して
いる
\\begin{itemize}
\\item unified index は， 3 つのテーブルと LPM (Longest Prefix Match)
・ EM (Exact Match) をサポートする
\\end{itemize}
\\item unified index のエントリは， CS ・ PIT ・ FIB のエントリへの
pointer と pointer が指すエントリの含まれるテーブルを表す type (CS ・
PIT ・ FIB のいずれか) を持つ
\\end{itemize}
\\centering
\\includegraphics[height=0.5\\textheight]{./figure/overview_unified_index.pdf}
\\end{frame}

\\begin{frame}[label=sec-1-4]{BFAST の提案}
\\begin{itemize}
\\item Unified Index を実現するために BFAST というデータ構造を提案する
\\begin{itemize}
\\item BFAST は， 2 つの Counting Bloom Filter とハッシュテーブルから
構成される
\\end{itemize}
\\end{itemize}
\\centering
\\includegraphics[width=0.7\\linewidth,height=0.7\\textheight]{./figure/bfast_comp.pdf}
\\end{frame}

\\begin{frame}[label=sec-1-5]{補足: (Counting) Bloom Filter}
\\begin{itemize}
\\item Counting Bloom Filter は Bloom Filter の実装の一種で，再生成せずに
要素を削除できるものである． Counting Bloom Filter では，配列の各
要素はビットから n ビットのカウンタに拡張されている．
\\item 要素の追加は各配列要素のインクリメントになり，参照は各配列要素がゼ
ロでないことを確認することになる．削除する場合，対応する配列要素の
カウンタをデクリメントすればよい．
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-6]{BFAST の提案までの流れ (1)}
\\begin{enumerate}
\\item 1 つのハッシュ関数にかけたハッシュ値の bucket にエントリを挿入するだ
けだとハッシュテーブルのバランスが悪くなる
\\item バランスを取るために， k 個 (図では k=3) のハッシュ関数にかけて
得られた k 個のハッシュ値のうちエントリ数が最小の bucket にエント
リを挿入することにする
\\item 各 bucket が持つエントリ数を別のテーブル Counter で管理することにする
\\begin{itemize}
\\item エントリ数が最小の bucket を見つけるために，すべての bucket の
エントリを辿らなくてよくなる
\\end{itemize}
\\end{enumerate}
\\centering
\\includegraphics[width=1.0\\linewidth,height=0.4\\textheight]{./figure/bfast_flow.pdf}
\\end{frame}

\\begin{frame}[label=sec-1-7]{BFAST の提案までの流れ (2): Counting Bloom Filter の導入}
\\begin{columns}
\\begin{column}{0.5\\textwidth}
\\begin{block}{概要図}%x
\\centering
\\includegraphics[height=0.4\\textheight]{./figure/hash_table_with_counting_bloom_filter.pdf}
\\begin{itemize}
\\item Counter を Counting Bloom Filter (CBF) にする
\\begin{itemize}
\\item CBF のエントリが 0 ならば，エントリが存在しない事が分かるため高
速で EM ・ LPM が可能
\\end{itemize}
\\end{itemize}
\\end{block}
\\end{column}

\\begin{column}{0.5\\textwidth}
\\begin{block}{挿入アルゴリズム}%x
\\includegraphics[height=0.48\\textheight]{./figure/Algorithm1.pdf}
\\begin{itemize}
\\item k: ハッシュ関数の個数
\\item $f_i$ (): ハッシュ関数
\\item $B_i$: i 番目の bucket
\\item $C_i$: $B_i$ のカウンタ
\\end{itemize}
\\end{block}
\\end{column}
\\end{columns}
\\end{frame}

\\begin{frame}[label=sec-1-8]{BFAST の提案までの流れ (3):}
\\begin{itemize}
\\item 前スライドの構造では，エントリの探索が上手く行かない
\\begin{itemize}
\\item k 個のハッシュ値のうち CBF が最小の bucket に該当するエントリが
あるとは限らないから
\\begin{itemize}
\\item 別のエントリを挿入するときに CBF がインクリメントさせる可能性が
あるから
\\end{itemize}
\\end{itemize}
\\item これを解決するため， auxiliary CBF (aCBF) を導入する
\\begin{itemize}
\\item エントリを挿入する時に，どのハッシュ関数が最小の C\\_i となる i
を導出したかを記録する
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-1-9]{完成版 BFAST}
\\begin{columns}
\\begin{column}{0.5\\textwidth}
\\begin{block}{概要図}%x
\\centering
\\includegraphics[width=.9\\linewidth]{./figure/bfast_comp.pdf}
\\end{block}
\\end{column}

\\begin{column}{0.5\\textwidth}
\\begin{block}{挿入アルゴリズム}%x
\\centering
\\includegraphics[width=0.99\\linewidth,height=0.55\\textheight]{./figure/bfast_insert.pdf}
\\end{block}
\\end{column}
\\end{columns}
\\end{frame}

\\begin{frame}[label=sec-1-10]{BFAST での探索と削除}
\\begin{columns}
\\begin{column}{0.5\\textwidth}
\\begin{block}{探索アルゴリズム}%x
\\centering
\\includegraphics[width=0.99\\linewidth,height=0.55\\textheight]{./figure/bfast_lookup.pdf}
\\begin{itemize}
\\item 探索要素を k 個のハッシュ関数にかけたハッシュ値をインデックスとし
た mCBF の要素に 0 があるならば，要素は存在しない (line 3-5)
\\end{itemize}
\\end{block}
\\end{column}

\\begin{column}{0.5\\textwidth}
\\begin{block}{削除アルゴリズム}%x
\\centering
\\includegraphics[width=0.99\\linewidth,height=0.55\\textheight]{./figure/bfast_delete.pdf}
\\begin{itemize}
\\item mCBF と aCBF の値をデクリメントする操作が抜けてるのでは?
\\end{itemize}
\\end{block}
\\end{column}
\\end{columns}
\\end{frame}

\\begin{frame}[label=sec-1-11]{BFAST における EM と LPM}
\\begin{itemize}
\\item EM は前ページの探索アルゴリズムで行える
\\item LPM は， prefix を fullname から 1 コンポネントずつ短くして EM と同
じ方法で行う
\\end{itemize}
\\centering
\\includegraphics[width=.9\\linewidth]{./figure/LPM.pdf}
\\end{frame}

\\begin{frame}[label=sec-1-12]{BFAST の Scalability と Extensibility}
\\begin{itemize}
\\item BFAST はテーブルを再構築せずに動的に拡張できる
\\begin{itemize}
\\item 格納する要素が増えると探索にかかる時間が増えてしまう
\\begin{itemize}
\\item mCBF の false positive の確率が上昇するため不要な lookup が増
える
\\item ハッシュテーブルのリンクを何度も辿ることになる
\\end{itemize}
\\item これを防ぐために，テーブルのテーブルの再構築を行うと，時間がかかる上
に，通常のパケットフォワーディングを阻害してしまう
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-13]{BFAST の拡張}
\\begin{itemize}
\\item BFAST の拡張前後では，異なる aCBF を用いる
\\begin{itemize}
\\item 要素の探索は， aCBF と aCBF'のどちらに要素があるかをチェックし
てから開始する
\\begin{itemize}
\\item ハッシュテーブル (および mCBF) へ要素の挿入位置が拡張前のハッ
シュテーブルの大きさ N と拡張後の N'で異なってくるため
\\end{itemize}
\\end{itemize}
\\end{itemize}

\\centering
\\includegraphics[width=0.8\\linewidth,height=0.6\\textheight]{./figure/extend_bfast.pdf}
\\end{frame}

\\begin{frame}[label=sec-1-14]{BFAST での NDN フォワーディングの全体像}
\\begin{itemize}
\\item prefix 自体は，テーブルエントリだけに格納して， unified index では
signature を用いる
\\begin{itemize}
\\item signature は， prefix をハッシュ関数にかけて生成する
\\begin{itemize}
\\item index のサイズを劇的位に小さく出来る
\\item エラーレートは無視できるほど小さい
\\end{itemize}
\\end{itemize}
\\item PIT と FIB を指す unified index のエントリは face 番号も格納する
\\begin{itemize}
\\item 探索速度向上のため
\\end{itemize}
\\end{itemize}

\\centering
\\includegraphics[width=0.9\\linewidth,height=0.55\\textheight]{./figure/NDN_with_bfast.pdf}
\\end{frame}

\\begin{frame}[label=sec-1-15]{いかにして BFAST を我々の NDN ルータモデルに導入するか}
\\begin{itemize}
\\item 我々の NDN ルータモデルの CCNx のテーブルを BFAST に置きかえるだけでよ
い
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-1-16]{}
\\end{frame}

\\section{2014 年 6 月 13 日}
\\label{sec-2}
\\begin{frame}[label=sec-2-1]{前回までのミーティングのまとめ}
\\begin{itemize}
\\item 現在は， ICN ルータの省電力化と ICN ネットワーク全体の省電力化を
どちらも考えているので，ルータの省電力化に焦点を当てる
\\item まずは，ルータの FIB ・ PIT ・ CS の構造を考えるため，関連研究の論
文を読む
\\begin{itemize}
\\item 電力効率のよいテーブル構造を議論したい
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-2-2]{進捗状況}
\\begin{itemize}
\\item 「 Scalable NDN Forwarding: Concepts, Issues and Principles 」を読み知
見を得た
\\begin{itemize}
\\item NDN のソフトウェアルータで 1Gbps を達成するためのルータの設計方
針が述べられている
\\end{itemize}
\\item 現在，「 BFAST: Unified and Scalable Index for NDN Forwarding Architecture 」
を読み進めている
\\begin{itemize}
\\item FIB ・ PIT ・ CS のエントリを別々に探索するのは時間がかかるので，
これらのテーブルを同時に探索できるような unified index を提案している
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-2-3]{現在の考えのまとめ}
\\begin{itemize}
\\item name prefix の長さに関わらず を固定長の prefix として扱う手法が必要である
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-2-4]{その他の探索アルゴリズム}
\\begin{itemize}
\\item FIB
\\begin{itemize}
\\item 2-stage LPM (Longest Prefix Match) algorithm
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-2-5]{2-stage LPM algorithm の概要}
\\begin{itemize}
\\item LPM を fullname ではなく，ある長さ $M$ の prefix から開始する
\\begin{itemize}
\\item マッチは fullname よりも大幅に短い prefix で発生しやすい
\\item マッチしなかった時，マッチにかかる時間は最悪となる
\\item LPM にかかる最悪の時間を一定時間以下に保証できる (マッチングする
回数が $M$ 以下のため)
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-2-6]{2-stage LPM algorithm の処理の流れ}
\\begin{enumerate}
\\item LPM を長さ $M$ の prefix から開始する
\\item マッチングなし: LPM 終了
\\item マッチングあり: 最大の長さ $MD$ からマッチするまで繰り返す
\\end{enumerate}
\\end{frame}
% Emacs 24.3.1 (Org mode 8.2.7a)
\\end{document}" "% Created 2014-06-23 Mon 15:43
\\documentclass[dvipdfmx,11pt]{beamer}
\\usepackage{url}
\\usepackage{pxjahyper}
\\usetheme{Berlin}
\\setbeamertemplate{navigation symbols}{}
\\beamertemplatetextbibitems
\\setbeamertemplate{footline}[frame number]
\\setbeamertemplate{headline}{}


\\institute[]{Osaka University\\\\
Graduate School of Information Science and Technology \\\\
Information Sharing Platform Laboratory \\\\
Master course second year}
\\usetheme{default}
\\author{大杉 海斗}
\\date{\\today}
\\title{ICN Meeting}
\\hypersetup{
  pdfkeywords={},
  pdfsubject={},
  pdfcreator={Emacs 24.3.1 (Org mode 8.2.7a)}}
\\begin{document}

\\maketitle

\\section{2014 年 6 月 17 日}
\\label{sec-1}
\\begin{frame}[label=sec-1-1]{前回までのミーティングのまとめ}
\\begin{itemize}
\\item 
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-1-2]{進捗状況}
\\begin{itemize}
\\item 「 BFAST: Unified and Scalable Index for NDN Forwarding
Architecture 」を読み，自分のルーティングアルゴリズムに適用させる
方法を考えた
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-1-3]{BFAST: Unified and Scalable Index for NDN Forwarding Architecture の概要}
\\begin{itemize}
\\item FIB ・ PIT ・ CS のエントリを別々に探索するのは時間がかかるので，
これらのテーブルを同時に探索できるような unified index を提案して
いる
\\begin{itemize}
\\item unified index は， 3 つのテーブルと LPM (Longest Prefix Match)
・ EM (Exact Match) をサポートする
\\end{itemize}
\\item unified index のエントリは， CS ・ PIT ・ FIB のエントリへの
pointer と pointer が指すエントリの含まれるテーブルを表す type (CS ・
PIT ・ FIB のいずれか) を持つ
\\end{itemize}
\\centering
\\includegraphics[height=0.5\\textheight]{./figure/overview_unified_index.pdf}
\\end{frame}

\\begin{frame}[label=sec-1-4]{BFAST の提案}
\\begin{itemize}
\\item Unified Index を実現するために BFAST というデータ構造を提案する
\\begin{itemize}
\\item BFAST は， 2 つの Counting Bloom Filter とハッシュテーブルから
構成される
\\end{itemize}
\\end{itemize}
\\centering
\\includegraphics[width=0.7\\linewidth,height=0.7\\textheight]{./figure/bfast_comp.pdf}
\\end{frame}

\\begin{frame}[label=sec-1-5]{補足: (Counting) Bloom Filter}
\\begin{itemize}
\\item Counting Bloom Filter は Bloom Filter の実装の一種で，再生成せずに
要素を削除できるものである． Counting Bloom Filter では，配列の各
要素はビットから n ビットのカウンタに拡張されている．
\\item 要素の追加は各配列要素のインクリメントになり，参照は各配列要素がゼ
ロでないことを確認することになる．削除する場合，対応する配列要素の
カウンタをデクリメントすればよい．
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-6]{BFAST の提案までの流れ (1)}
\\begin{enumerate}
\\item 1 つのハッシュ関数にかけたハッシュ値の bucket にエントリを挿入するだ
けだとハッシュテーブルのバランスが悪くなる
\\item バランスを取るために， k 個 (図では k=3) のハッシュ関数にかけて
得られた k 個のハッシュ値のうちエントリ数が最小の bucket にエント
リを挿入することにする
\\item 各 bucket が持つエントリ数を別のテーブル Counter で管理することにする
\\begin{itemize}
\\item エントリ数が最小の bucket を見つけるために，すべての bucket の
エントリを辿らなくてよくなる
\\end{itemize}
\\end{enumerate}
\\centering
\\includegraphics[width=1.0\\linewidth,height=0.4\\textheight]{./figure/bfast_flow.pdf}
\\end{frame}

\\begin{frame}[label=sec-1-7]{BFAST の提案までの流れ (2): Counting Bloom Filter の導入}
\\begin{columns}
\\begin{column}{0.5\\textwidth}
\\begin{block}{概要図}%x
\\centering
\\includegraphics[height=0.4\\textheight]{./figure/hash_table_with_counting_bloom_filter.pdf}
\\begin{itemize}
\\item Counter を Counting Bloom Filter (CBF) にする
\\begin{itemize}
\\item CBF のエントリが 0 ならば，エントリが存在しない事が分かるため高
速で EM ・ LPM が可能
\\end{itemize}
\\end{itemize}
\\end{block}
\\end{column}

\\begin{column}{0.5\\textwidth}
\\begin{block}{挿入アルゴリズム}%x
\\includegraphics[height=0.48\\textheight]{./figure/Algorithm1.pdf}
\\begin{itemize}
\\item k: ハッシュ関数の個数
\\item $f_i$ (): ハッシュ関数
\\item $B_i$: i 番目の bucket
\\item $C_i$: $B_i$ のカウンタ
\\end{itemize}
\\end{block}
\\end{column}
\\end{columns}
\\end{frame}

\\begin{frame}[label=sec-1-8]{BFAST の提案までの流れ (3):}
\\begin{itemize}
\\item 前スライドの構造では，エントリの探索が上手く行かない
\\begin{itemize}
\\item k 個のハッシュ値のうち CBF が最小の bucket に該当するエントリが
あるとは限らないから
\\begin{itemize}
\\item 別のエントリを挿入するときに CBF がインクリメントさせる可能性が
あるから
\\end{itemize}
\\end{itemize}
\\item これを解決するため， auxiliary CBF (aCBF) を導入する
\\begin{itemize}
\\item エントリを挿入する時に，どのハッシュ関数が最小の C\\_i となる i
を導出したかを記録する
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-1-9]{完成版 BFAST}
\\begin{columns}
\\begin{column}{0.5\\textwidth}
\\begin{block}{概要図}%x
\\centering
\\includegraphics[width=.9\\linewidth]{./figure/bfast_comp.pdf}
\\end{block}
\\end{column}

\\begin{column}{0.5\\textwidth}
\\begin{block}{挿入アルゴリズム}%x
\\centering
\\includegraphics[width=0.99\\linewidth,height=0.55\\textheight]{./figure/bfast_insert.pdf}
\\end{block}
\\end{column}
\\end{columns}
\\end{frame}

\\begin{frame}[label=sec-1-10]{BFAST での探索と削除}
\\begin{columns}
\\begin{column}{0.5\\textwidth}
\\begin{block}{探索アルゴリズム}%x
\\centering
\\includegraphics[width=0.99\\linewidth,height=0.55\\textheight]{./figure/bfast_lookup.pdf}
\\begin{itemize}
\\item 探索要素を k 個のハッシュ関数にかけたハッシュ値をインデックスとし
た mCBF の要素に 0 があるならば，要素は存在しない (line 3-5)
\\end{itemize}
\\end{block}
\\end{column}

\\begin{column}{0.5\\textwidth}
\\begin{block}{削除アルゴリズム}%x
\\centering
\\includegraphics[width=0.99\\linewidth,height=0.55\\textheight]{./figure/bfast_delete.pdf}
\\begin{itemize}
\\item mCBF と aCBF の値をデクリメントする操作が抜けてるのでは?
\\end{itemize}
\\end{block}
\\end{column}
\\end{columns}
\\end{frame}

\\begin{frame}[label=sec-1-11]{BFAST における EM と LPM}
\\begin{itemize}
\\item EM は前ページの探索アルゴリズムで行える
\\item LPM は， prefix を fullname から 1 コンポネントずつ短くして EM と同
じ方法で行う
\\end{itemize}
\\centering
\\includegraphics[width=.9\\linewidth]{./figure/LPM.pdf}
\\end{frame}

\\begin{frame}[label=sec-1-12]{BFAST の Scalability と Extensibility}
\\begin{itemize}
\\item BFAST はテーブルを再構築せずに動的に拡張できる
\\begin{itemize}
\\item 格納する要素が増えると探索にかかる時間が増えてしまう
\\begin{itemize}
\\item mCBF の false positive の確率が上昇するため不要な lookup が増
える
\\item ハッシュテーブルのリンクを何度も辿ることになる
\\end{itemize}
\\item これを防ぐために，テーブルのテーブルの再構築を行うと，時間がかかる上
に，通常のパケットフォワーディングを阻害してしまう
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-13]{BFAST の拡張}
\\begin{itemize}
\\item BFAST の拡張前後では，異なる aCBF を用いる
\\begin{itemize}
\\item 要素の探索は， aCBF と aCBF'のどちらに要素があるかをチェックし
てから開始する
\\begin{itemize}
\\item ハッシュテーブル (および mCBF) へ要素の挿入位置が拡張前のハッ
シュテーブルの大きさ N と拡張後の N'で異なってくるため
\\end{itemize}
\\end{itemize}
\\end{itemize}

\\centering
\\includegraphics[width=0.8\\linewidth,height=0.6\\textheight]{./figure/extend_bfast.pdf}
\\end{frame}

\\begin{frame}[label=sec-1-14]{BFAST での NDN フォワーディングの全体像}
\\begin{itemize}
\\item prefix 自体は，テーブルエントリだけに格納して， unified index では
signature を用いる
\\begin{itemize}
\\item signature は， prefix をハッシュ関数にかけて生成する
\\begin{itemize}
\\item index のサイズを劇的位に小さく出来る
\\item エラーレートは無視できるほど小さい
\\end{itemize}
\\end{itemize}
\\item PIT と FIB を指す unified index のエントリは face 番号も格納する
\\begin{itemize}
\\item 探索速度向上のため
\\end{itemize}
\\end{itemize}

\\centering
\\includegraphics[width=0.9\\linewidth,height=0.55\\textheight]{./figure/NDN_with_bfast.pdf}
\\end{frame}

\\begin{frame}[label=sec-1-15]{いかにして BFAST を我々の NDN ルータモデルに導入するか}
\\begin{itemize}
\\item 我々の NDN ルータモデルの CCNx のテーブルを BFAST に置きかえるだけでよ
い
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-1-16]{}
\\end{frame}

\\section{2014 年 6 月 13 日}
\\label{sec-2}
\\begin{frame}[label=sec-2-1]{前回までのミーティングのまとめ}
\\begin{itemize}
\\item 現在は， ICN ルータの省電力化と ICN ネットワーク全体の省電力化を
どちらも考えているので，ルータの省電力化に焦点を当てる
\\item まずは，ルータの FIB ・ PIT ・ CS の構造を考えるため，関連研究の論
文を読む
\\begin{itemize}
\\item 電力効率のよいテーブル構造を議論したい
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-2-2]{進捗状況}
\\begin{itemize}
\\item 「 Scalable NDN Forwarding: Concepts, Issues and Principles 」を読み知
見を得た
\\begin{itemize}
\\item NDN のソフトウェアルータで 1Gbps を達成するためのルータの設計方
針が述べられている
\\end{itemize}
\\item 現在，「 BFAST: Unified and Scalable Index for NDN Forwarding Architecture 」
を読み進めている
\\begin{itemize}
\\item FIB ・ PIT ・ CS のエントリを別々に探索するのは時間がかかるので，
これらのテーブルを同時に探索できるような unified index を提案している
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-2-3]{現在の考えのまとめ}
\\begin{itemize}
\\item name prefix の長さに関わらず を固定長の prefix として扱う手法が必要である
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-2-4]{その他の探索アルゴリズム}
\\begin{itemize}
\\item FIB
\\begin{itemize}
\\item 2-stage LPM (Longest Prefix Match) algorithm
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-2-5]{2-stage LPM algorithm の概要}
\\begin{itemize}
\\item LPM を fullname ではなく，ある長さ $M$ の prefix から開始する
\\begin{itemize}
\\item マッチは fullname よりも大幅に短い prefix で発生しやすい
\\item マッチしなかった時，マッチにかかる時間は最悪となる
\\item LPM にかかる最悪の時間を一定時間以下に保証できる (マッチングする
回数が $M$ 以下のため)
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-2-6]{2-stage LPM algorithm の処理の流れ}
\\begin{enumerate}
\\item LPM を長さ $M$ の prefix から開始する
\\item マッチングなし: LPM 終了
\\item マッチングあり: 最大の長さ $MD$ からマッチするまで繰り返す
\\end{enumerate}
\\end{frame}
% Emacs 24.3.1 (Org mode 8.2.7a)
\\end{document}" #(" のハッシュ値でそのパケットを処理する CPU を決定
     する
   - 各 CPU にはその CPU
" 0 1 (fontified t) 1 2 (fontified t) 2 18 (fontified t) 18 19 (fontified t) 19 20 (fontified t) 20 21 (fontified t) 21 22 (fontified t) 22 23 (fontified t) 23 24 (fontified t) 24 25 (fontified t) 25 27 (fontified t) 27 28 (fontified t) 28 35 (fontified t) 35 36 (fontified t) 36 39 (fontified t) 39 41 (fontified t) 41 42 (fontified t) 42 43 (fontified t) 43 44 (fontified t) 44 45 (fontified t) 45 46 (fontified t) 46 47 (fontified t) 47 50 (fontified t) 50 51 (fontified t) 51 52 (fontified t) 52 53 (fontified t) 53 55 (fontified t) 55 56 (fontified t)) #("パケットを" 0 5 (fontified t)) #("   " 0 3 (fontified t)) #(" " 0 1 (fontified t)) #("Cisco と同様" 0 4 (fontified t) 4 5 (fontified t) 5 6 (fontified t) 6 7 (fontified t) 7 9 (fontified t)) #("root prefix でテーブルを分割する" 0 10 (fontified t) 10 11 (fontified t) 11 12 (fontified t) 12 13 (fontified t) 13 22 (fontified t))))
(setq-default session-file-alist '(("/sudo:root@VAIO:/etc/clamav/freshclam.conf" 365 nil 1 nil nil 446 (overwrite-mode)) ("/sudo:root@VAIO:/etc/clamav/clamd.conf" 14068 nil 1 nil nil 346 (overwrite-mode)) ("/etc/clamav/clamd.conf" 1 nil 1 nil nil nil (overwrite-mode)) ("~/Dropbox/configure/.emacs.d/elpa/helm-20140627.1038/helm-autoloads.el" 42555 nil 1 nil nil 42555 (overwrite-mode)) ("~/Dropbox/configure/.emacs.d/elpa/lua-mode-20140626.218/lua-mode-autoloads.el" 509 nil 1 nil nil 509 (overwrite-mode)) ("~/Dropbox/research/work/society14/paper.tex" 3111 3111 1 nil nil 3111 (overwrite-mode)) ("~/Dropbox/configure/.emacs.d/var/recentf" 5553 nil 1 nil nil nil (overwrite-mode)) ("/mnt/Dropbox/research/work/society14/paper.tex" 1760 1760 1 nil nil 1760 (overwrite-mode)) ("/mnt/Dropbox/research/work/society14/ieicejsp.cls" 19042 19086 1 nil nil nil (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/var/recentf" 4954 nil 1 nil nil nil (overwrite-mode)) ("/mnt/Dropbox/research/work/society14/paper (VAIO の競合コピー 2014-06-26).tex" 1778 nil 1 nil nil nil (overwrite-mode)) ("/mnt/Dropbox/research/work/society14/paper.org" 656 nil 1 nil nil 322 (overwrite-mode)) ("/mnt/Dropbox/research/work/society14/abstract.org" 1 nil 1 nil nil 1 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/helm-20140625.252/helm-autoloads.el" 42605 nil 1 nil nil 42605 (overwrite-mode)) ("~/Dropbox/configure/.emacs.d/elpa/org-20140623/org-loaddefs.el" 86900 nil 1 nil nil 86900 (overwrite-mode)) ("~/Dropbox/configure/.emacs.d/elpa/helm-20140624.2318/helm-autoloads.el" 42605 nil 1 nil nil 42605 (overwrite-mode)) ("~/Dropbox/configure/.emacs.d/elpa/lua-mode-20140623.1237/lua-mode-autoloads.el" 510 nil 1 nil nil 510 (overwrite-mode)) ("~/Dropbox/configure/.emacs.d/elpa/org-20140623/org-autoloads.el" 27238 nil 1 nil nil 27238 (overwrite-mode)) ("/mnt/Dropbox/research/meeting/ICN-meeting.org" 189 4717 1 nil nil 189 (overwrite-mode)) ("/mnt/Dropbox/research/meeting/ICN-meeting.tex" 8299 nil 1 nil nil nil (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/helm-20140621.2211/helm-autoloads.el" 42606 nil 1 nil nil 42606 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/s-20140620.1657/s-autoloads.el" 165 nil 1 nil nil 165 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/yasnippet-20140617.1640/yasnippet-autoloads.el" 1494 nil 1 nil nil 1494 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/snippets/org-mode/figure" 50 nil 1 nil nil 91 (overwrite-mode)) ("/mnt/Dropbox/storage/scfes.org" 1 nil 1 nil nil 29 (overwrite-mode)) ("~/.config/awesome/rc.lua" 1 17440 1 nil nil 17598 (overwrite-mode)) ("/sudo:root@desktop:/etc/X11/xorg.conf.d/10-monitor.conf" 289 nil 1 nil nil 138 (overwrite-mode)) ("/mnt/Dropbox/storage/keys-TA/it-keys_ta.org" 1042 nil 1 nil nil nil (overwrite-mode)) ("~/Downloads/作業割り当て.txt" 1 nil 1 nil nil 260 (overwrite-mode)) ("~/Downloads/作業割り当て.txtm" 1 nil 1 nil nil 2 (overwrite-mode)) ("~/Dropbox/configure/.emacs.d/elpa/epc-20140609.2234/epc-autoloads.el" 179 nil 1 nil nil 179 (overwrite-mode)) ("/mnt/Dropbox/research/meeting/M2-meeting.org" 15 202 1 nil nil 15 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/inits/20_org-mode.el" 1965 555 1 nil nil nil (overwrite-mode)) ("/mnt/Dropbox/research/poster_introduction/paper.org" 224 4371 1 nil nil 4448 (overwrite-mode)) ("/mnt/Dropbox/research/meeting/M2-meeting.tex" 794 nil 1 nil nil nil (overwrite-mode)) ("/sudo:root@localhost:/etc/X11/xorg.conf.d/20-gpudriver.conf" 1 nil 1 nil nil nil (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/helm-20140608.753/helm-autoloads.el" 48154 nil 1 nil nil 48154 (overwrite-mode)) ("/mnt/Dropbox/research/poster_introduction/paper.tex" 7591 nil 1 nil nil nil (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/helm-20140607.2258/helm-autoloads.el" 48114 nil 1 nil nil 48114 (overwrite-mode)) ("~/.config/awesome/themes/theme.lua" 1765 318 1 nil nil 240 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/dash-20140607.33/dash-autoloads.el" 174 nil 1 nil nil 174 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/auto-complete-20140605.1908/auto-complete-autoloads.el" 1715 nil 1 nil nil 1715 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/helm-20140605.1156/helm-autoloads.el" 48156 nil 1 nil nil 48156 (overwrite-mode))))
(setq-default file-name-history '("/sudo:root@VAIO:/etc/clamav/freshclam.conf" "/sudo:root@VAIO:/etc/clamav/clamd.conf" "/etc/clamav/clamd.conf" "~/.emacs.d/elpa/helm-20140627.1038/helm-autoloads.el" "~/.emacs.d/elpa/lua-mode-20140626.218/lua-mode-autoloads.el" "~/Dropbox/research/work/society14/paper.tex" "/mnt/Dropbox/research/work/society14/paper.tex" "/mnt/Dropbox/research/work/society14/paper.org" "/mnt/Dropbox/research/work/society14/paper (VAIO の競合コピー 2014-06-26).tex" "/mnt/Dropbox/research/work/society14/abstract.org" "~/.emacs.d/elpa/helm-20140625.252/helm-autoloads.el" "~/.emacs.d/elpa/helm-20140624.2318/helm-autoloads.el" "~/.emacs.d/elpa/lua-mode-20140623.1237/lua-mode-autoloads.el" "~/.emacs.d/elpa/org-20140623/org-loaddefs.el" "~/.emacs.d/elpa/org-20140623/org-autoloads.el" "/tmp/packerbuild-1000/pdftk/pdftk/PKGBUILD" "~/Dropbox/research/meeting/ICN-meeting.org" "~/.emacs.d/elpa/helm-20140621.2211/helm-autoloads.el" "~/.emacs.d/elpa/s-20140620.1657/s-autoloads.el" "~/.emacs.d/elpa/yasnippet-20140617.1640/yasnippet-autoloads.el" "~/Dropbox/storage/scfes.org" "~/.emacs.d/snippets/org-mode/figure" "~/Dropbox/research/meeting/ICN-meeting.tex" "/tmp/packerbuild-1000/libgcj/libgcj/PKGBUILD" "~/.config/awesome/rc.lua" "/sudo:root@desktop:/etc/X11/xorg.conf.d/10-monitor.conf" "/etc/X11/xorg.conf.d/10-monitor.conf" "/etc/X11/xorg.conf.d/" "~/Dropbox/class/basic_network/report8/report8.org" "/tmp/packerbuild-1000/chromium-pepper-flash/chromium-pepper-flash/PKGBUILD" "~/Dropbox/storage/keys-TA/it-keys_ta.org" "~/Downloads/作業割り当て.txt" "~/Downloads/作業割り当て.txtm" "~/.emacs.d/elpa/epc-20140609.2234/epc-autoloads.el" "~/.emacs.d/inits/20_org-mode.el" "/sudo:root@localhost:/etc/X11/xorg.conf.d/20-gpudriver.conf" "~/Dropbox/research/meeting/old-meeting.org" "~/Dropbox/research/meeting/M2-meeting.org" "~/Dropbox/research/poster_introduction/paper.org" "~/Dropbox/research/energy_result/thesis/" "~/.emacs.d/elpa/helm-20140608.753/helm-autoloads.el" "~/.emacs.d/elpa/helm-20140607.2258/helm-autoloads.el" "~/.emacs.d/elpa/dash-20140607.33/dash-autoloads.el" "~/.config/awesome/themes/theme.lua" "/home/corgi/.config/awesome/rc.lua" "~/.emacs.d/elpa/auto-complete-20140605.1908/auto-complete-autoloads.el" "~/.emacs.d/elpa/helm-20140605.1156/helm-autoloads.el" "~/Dropbox/research/energy_result/icn_acm/cpu_cores_with_errorbar.dat" "~/Dropbox/research/energy_result/icn_acm/cpu_cores_with_errorbar.gp" "~/Dropbox/research/energy_result/icn_acm/cpu_cores.dat" "~/Dropbox/research/energy_result/icn_acm/cpu_cores.gp" "/home/corgi/.zshrc" "/home/corgi/Dropbox/research/energy_result/icn_acm/cpu_cores.gp" "/home/corgi/Dropbox/research/energy_result/icn_acm/memory_accsess.gp" "/home/corgi/Dropbox/research/energy_result/icn_acm/packet_rate.gp" "/home/corgi/Dropbox/research/energy_result/icn_acm/udp1500byte.gp" "/home/corgi/Dropbox/research/energy_result/icn_acm/udp256byte.gp" "/home/corgi/Downloads/graph_and_result-v2/README.txt" "~/Dropbox/research/poster_introduction" "~/Dropbox/research/" "~/Dropbox/research/energy_result/icn_acm/memory_accsess.gp" "~/Dropbox/research/energy_result/icn_acm/packet_rate.dat" "/ssh:router@192.168.10.80:/home/router/sleep.c" "~/Dropbox/research/energy_result/icn_acm/packet_rate.gp" "~/Dropbox/research/energy_result/icn_acm/udp256byte.gp" "~/Dropbox/research/energy_result/icn_acm/memory_accsess.dat" "/ssh:router@192.168.10.80:/home/router/read_memory.c" "/ssh:client1@192.168.10.85:/home/client1/send.c" "~/Dropbox/research/energy_result/icn_acm/udp1500byte.gp" "~/Dropbox/research/energy_result/icn_acm/udp256byte.dat" "~/Dropbox/research/energy_result/icn_acm/udp1500byte.dat" "~/Dropbox/research/energy_result/icn_acm/memory_accsess_0:0.gp" "/ssh:router@192.168.10.80:/home/router/cpu-clock.c" "/ssh:router@192.168.10.80:/home/router/test.c" "/home/k-ohsugi/Dropbox/research/energy_result/icn_acm/memory_accsess.gp" "~/.emacs.d/elpa/gnuplot-20130206.1701/gnuplot.el" "~/.emacs.d/elpa/gnuplot-20130206.1701/gnuplot-gui.el" "~/.emacs.d/elpa/gnuplot-20130206.1701/" "~/.emacs.d/elpa/gnuplot-readme.txt" "~/.emacs.d/elpa/gnuplot-mode-readme.txt" "~/.emacs.d/elpa/" "~/.emacs.d/inits/99_gnuplot.el" "/ssh:client1@192.168.10.85:/home/client1/get_ccnx_time.sh" "~/.emacs.d/elpa/helm-20140530.2214/helm-autoloads.el" "/ssh:router@192.168.10.80:/home/router/get_ccnx_time.sh" "/ssh:server1@192.168.10.90:/home/server1/receive.c" "~/.emacs.d/elpa/gnuplot-20130206.1701/gnuplot-autoloads.el" "~/.emacs.d/inits/99_popwin.el" "~/.emacs.d/inits/99_popwin.elc" "~/Dropbox/research/energy_result/" "~/Dropbox/research/energy_result/icn_acm/udp1500byte.gnuplot" "~/Dropbox/research/energy_result/icn_acm/udp1500byte.out" "/home/k-ohsugi/Dropbox/research/energy_result/icn_acm/udp1500byte.dat" "~/Dropbox/research/energy_result/icn_acm/udp1500byte.data" "/home/k-ohsugi/Dropbox/research/energy_result/icn_acm/udp1500byte.res"))
(setq-default TeX-command-history '("LatexMk" "Evince" "Clean All"))
(setq-default buffer-name-history '("ieicejsp.cls" "report8.org" "udp1500byte.gp" "memory_accsess.dat" "*scratch*" "*Async Shell Command*" "ssh:get_ccnx_time.sh" "*gnuplot*" "udp1500byte.out" "*Moccur*" "*Org PDF LaTeX Output*" "__init__.py" "functions.py" "PKGBUILD" "ssh:hoge.c" "forwarding.c" "dummy.c" "256result.data" "ssh:receive.c" "ssh:ssh:ssh:send.c<client1>" "router" "rdtsc.h" "*Packages*" "*Macroexpansion*" "2-13 Daring!!.mp3" "*Backtrace*" "20_org-mode.el" "hote.txt" "es.org" "*init log*"))
(setq-default coding-system-history '("shift_jis" "utf-8-unix" "unix"))
(setq-default command-history '((package-list-packages nil) (kill-buffer "ieicejsp.cls") (find-file "~/Dropbox/storage/scfes.org" t) (yas-load-snippet-buffer-and-close (quote org-mode) nil) (find-file "~/Dropbox/research/meeting/ICN-meeting.org" t) (query-replace "2" "screen.count ()" nil (if (and transient-mark-mode mark-active) (region-beginning)) (if (and transient-mark-mode mark-active) (region-end))) (find-file "/etc/X11/xorg.conf.d/10-monitor.conf" t) (find-file "/etc/X11/xorg.conf.d/" t) (find-file "~/.config/awesome/rc.lua" t) (kill-buffer "report8.org") (find-file "~/Dropbox/storage/keys-TA/it-keys_ta.org" t) (find-file "~/Downloads/作業割り当て.txt" t) (find-file "~/Downloads/作業割り当て.txtm" t) (find-file "~/.emacs.d/inits/20_org-mode.el" t) (find-file "~/Dropbox/research/meeting/old-meeting.org" t) (find-file "~/Dropbox/research/meeting/M2-meeting.org" t) (find-file "~/Dropbox/research/poster_introduction/paper.org" t) (find-file "~/Dropbox/research/energy_result/thesis/" t) (find-file "~/.config/awesome/themes/theme.lua" t) (find-file "~/Dropbox/research/energy_result/icn_acm/cpu_cores_with_errorbar.dat" t) (write-file "~/Dropbox/research/energy_result/icn_acm/cpu_cores_with_errorbar.gp" t) (find-file "~/Dropbox/research/energy_result/icn_acm/cpu_cores.dat" t) (ispell-buffer) (dired-create-directory "~/Dropbox/research/poster_introduction") (find-file "~/Dropbox/research/" t) (find-file "~/Dropbox/research/poster_introduction" t) (find-file "~/Dropbox/research/energy_result/icn_acm/packet_rate.dat" t) (find-file "~/Dropbox/research/energy_result/icn_acm/packet_rate.gp" t) (find-file "~/Dropbox/research/energy_result/icn_acm/udp256byte.gp" t) (kill-buffer "udp1500byte.gp") (find-file "~/Dropbox/research/energy_result/icn_acm/udp1500byte.gp" t) (write-file "~/Dropbox/research/energy_result/icn_acm/udp256byte.dat" t) (find-file "~/Dropbox/research/energy_result/icn_acm/udp1500byte.dat" t) (find-file "~/Dropbox/research/energy_result/icn_acm/memory_accsess.gp" t) (find-file "~/Dropbox/research/energy_result/icn_acm/memory_accsess_0:0.gp" t) (find-file "/ssh:router@192.168.10.80:/home/router/cpu-clock.c" t) (kill-buffer "memory_accsess.dat") (kill-buffer "*scratch*") (find-file "~/Dropbox/research/energy_result/icn_acm/cpu_cores.gp" t) (find-file "~/.emacs.d/elpa/gnuplot-20130206.1701/gnuplot.el" t) (find-file "~/.emacs.d/elpa/gnuplot-20130206.1701/" t) (find-file "~/.emacs.d/elpa/gnuplot-readme.txt" t) (find-file "~/.emacs.d/elpa/" t) (yas-load-snippet-buffer-and-close (quote gnuplot-mode) nil) (gnuplot-send-replot-to-gnuplot) (find-file "~/Dropbox/research/energy_result/icn_acm/memory_accsess.dat" t) (insert-file "~/Dropbox/research/energy_result/icn_acm/udp1500byte.gp") (query-replace "time" "time -p" nil (if (and transient-mark-mode mark-active) (region-beginning)) (if (and transient-mark-mode mark-active) (region-end))) (query-replace "10s" "3s" nil (if (and transient-mark-mode mark-active) (region-beginning)) (if (and transient-mark-mode mark-active) (region-end))) (query-replace "1GB" "${SIZE}" nil (if (and transient-mark-mode mark-active) (region-beginning)) (if (and transient-mark-mode mark-active) (region-end)))))
(setq-default extended-command-history '("package-list-packages" "ispell-buffer" "count-lines-region" "eval-buffer" "yas-expand-from-trigger-key" "moccur-grep" "describe-variable" "describe-function" "auto-complete-mode" "describe-mode" "Buffer-menu-mode" "describe-key" "eval-defun" "pascal-mode"))
(setq-default helm-c-grep-history '("valid-file" "filename"))
(setq-default helm-c-source-complex-command-history '((name . "Complex Command History") (candidates lambda nil (mapcar (quote prin1-to-string) command-history)) (type . sexp)))
(setq-default helm-c-source-file-name-history '((name . "File Name History") (candidates . file-name-history) (persistent-action . ignore) (filtered-candidate-transformer . helm-file-name-history-transformer) (action ("Find file" . helm-find-many-files) ("Find file as root" . helm-find-file-as-root) ("Find file other window" . find-file-other-window) ("Find file other frame" . find-file-other-frame) ("Open dired in file's directory" . helm-open-dired) ("Grep File(s) `C-u recurse'" . helm-find-files-grep) ("Zgrep File(s) `C-u Recurse'" . helm-ff-zgrep) ("Pdfgrep File(s)" . helm-ff-pdfgrep) ("Insert as org link" . helm-files-insert-as-org-link) ("Checksum File" . helm-ff-checksum) ("Ediff File" . helm-find-files-ediff-files) ("Ediff Merge File" . helm-find-files-ediff-merge-files) ("Etags `M-., C-u tap, C-u C-u reload tag file'" . helm-ff-etags-select) ("View file" . view-file) ("Insert file" . insert-file) ("Delete file(s)" . helm-delete-marked-files) ("Open file externally (C-u to choose)" . helm-open-file-externally) ("Open file with default tool" . helm-open-file-with-default-tool) ("Find file in hex dump" . hexl-find-file))))
(setq-default helm-c-source-global-mark-ring '((name . "global-mark-ring") (candidates . helm-global-mark-ring-get-candidates) (action ("Goto line" lambda (candidate) (let ((items (split-string candidate ":"))) (helm-switch-to-buffer (cl-second items)) (helm-goto-line (string-to-number (car items)))))) (persistent-action lambda (candidate) (let ((items (split-string candidate ":"))) (helm-switch-to-buffer (cl-second items)) (helm-goto-line (string-to-number (car items))) (helm-highlight-current-line))) (persistent-help . "Show this line")))
(setq-default helm-c-source-kill-ring '((name . "Kill Ring") (init lambda nil (helm-attrset (quote last-command) last-command)) (candidates . helm-kill-ring-candidates) (filtered-candidate-transformer helm-kill-ring-transformer) (action ("Yank" . helm-kill-ring-action) ("Delete" lambda (candidate) (cl-loop for cand in (helm-marked-candidates) do (setq kill-ring (delete cand kill-ring))))) (keymap keymap (27 keymap (117 . helm-previous-line) (121 . helm-next-line)) keymap (menu-bar keymap (help-menu keymap (describe keymap (describe-mode . helm-help)))) (help keymap (109 . helm-help)) (f1 keymap (109 . helm-help)) (8 . delete-backward-char) (20 . helm-toggle-resplit-and-swap-windows) (C-tab . undefined) (triple-mouse-3 . ignore) (double-mouse-3 . ignore) (mouse-3 . ignore) (drag-mouse-3 . ignore) (down-mouse-3 . ignore) (triple-mouse-2 . ignore) (double-mouse-2 . ignore) (mouse-2 . ignore) (drag-mouse-2 . ignore) (down-mouse-2 . ignore) (triple-mouse-1 . ignore) (double-mouse-1 . ignore) (mouse-1 . ignore) (drag-mouse-1 . ignore) (down-mouse-1 . ignore) (67108897 . helm-toggle-suspend-update) (3 keymap (1 . all-from-helm-occur) (21 . helm-force-update) (6 . helm-follow-mode) (11 . helm-kill-selection-and-quit) (25 . helm-yank-selection) (4 . helm-delete-current-selection) (45 . helm-swap-windows)) (67108987 . helm-enlarge-window) (67108989 . helm-narrow-window) (19 . undefined) (18 . undefined) (23 . helm-yank-text-at-point) (24 keymap (2 . helm-resume-list-buffers-after-quit) (98 . helm-resume-previous-session-after-quit) (6 . helm-quit-and-find-file)) (11 . helm-delete-minibuffer-contents) (67108896 . helm-toggle-visible-mark) (0 . helm-toggle-visible-mark) (C-M-up . helm-scroll-other-window-down) (C-M-down . helm-scroll-other-window) (M-prior . helm-scroll-other-window-down) (M-next . helm-scroll-other-window) (12 . helm-recenter-top-bottom-other-window) (15 . helm-next-source) (10 . helm-select-3rd-action) (5 . helm-select-2nd-action-or-end-of-line) (26 . helm-execute-persistent-action) (9 . helm-select-action) (13 . helm-exit-minibuffer) (left . helm-previous-source) (right . helm-next-source) (7 . helm-keyboard-quit) (22 . helm-next-page) (27 keymap (110 . next-history-element) (112 . previous-history-element) (115 . undefined) (5 . helm-display-all-sources) (1 . helm-show-all-in-this-source-only) (117 . helm-unmark-all) (97 . helm-mark-all) (109 . helm-toggle-all-marks) (41 . helm-next-visible-mark) (40 . helm-prev-visible-mark) (91) (32 . helm-toggle-visible-mark) (33554454 . helm-scroll-other-window-down) (25 . helm-scroll-other-window-down) (22 . helm-scroll-other-window) (12 . helm-reposition-window-other-window) (62 . helm-end-of-buffer) (60 . helm-beginning-of-buffer) (118 . helm-previous-page)) (next . helm-next-page) (prior . helm-previous-page) (16 . helm-previous-line) (14 . helm-next-line) (up . helm-previous-line) (down . helm-next-line) keymap (26 . undefined) (18 . helm-minibuffer-history) (S-tab . zlc-select-previous) (backtab . zlc-select-previous) (menu-bar keymap (minibuf #1="Minibuf" keymap (previous menu-item "Previous History Item" previous-history-element :help "Put previous minibuffer history element in the minibuffer") (next menu-item "Next History Item" next-history-element :help "Put next minibuffer history element in the minibuffer") (isearch-backward menu-item "Isearch History Backward" isearch-backward :help "Incrementally search minibuffer history backward") (isearch-forward menu-item "Isearch History Forward" isearch-forward :help "Incrementally search minibuffer history forward") (return menu-item "Enter" exit-minibuffer :key-sequence "" :help "Terminate input and exit minibuffer") (quit menu-item "Quit" abort-recursive-edit :help "Abort input and exit minibuffer") #1#)) (10 . exit-minibuffer) (13 . exit-minibuffer) (7 . minibuffer-keyboard-quit) (C-tab . file-cache-minibuffer-complete) (9 . self-insert-command) (XF86Back . previous-history-element) (up . previous-history-element) (prior . previous-history-element) (XF86Forward . next-history-element) (down . next-history-element) (next . next-history-element) (27 keymap (63 . session-minibuffer-history-help) (114 . previous-matching-history-element) (115 . next-matching-history-element) (112 . previous-history-element) (110 . next-history-element))) (last-command . helm-keyboard-quit) (migemo) (multiline)))
(setq-default helm-c-source-mark-ring '((name . "mark-ring") (candidates . helm-mark-ring-get-candidates) (action ("Goto line" lambda (candidate) (helm-goto-line (string-to-number candidate)))) (persistent-action lambda (candidate) (helm-goto-line (string-to-number candidate)) (helm-highlight-current-line)) (persistent-help . "Show this line")))
(setq-default helm-c-source-minibuffer-history '((name . "Minibuffer History") (header-name lambda (name) (format "%s (%s)" name minibuffer-history-variable)) (candidates lambda nil (let ((history (cl-loop for i in (symbol-value minibuffer-history-variable) unless (string= "" i) collect i))) (if (consp (car history)) (mapcar (quote prin1-to-string) history) history))) (migemo) (multiline) (action lambda (candidate) (delete-minibuffer-contents) (insert candidate))))
(setq-default helm-ff-history '("/sudo:root@VAIO:/etc/clamav/" "/etc/clamav/" "/home/k-ohsugi/" "/home/k-ohsugi/Dropbox/research/work/society14/" "/mnt/Dropbox/research/work/society14/" "/mnt/Dropbox/" "/home/k-ohsugi/Dropbox/research/energy_result/icn_acm/" "/home/k-ohsugi/Dropbox/meeting/withHasegawa/GreenICN/utils/"))
(setq-default helm-grep-history '("valid-file" "filename"))
(setq-default helm-source--ff-file-name-history '((name . "File name history") (init lambda nil (with-helm-alive-p (when helm-ff-file-name-history-use-recentf (require (quote recentf)) (or recentf-mode (recentf-mode 1))))) (candidates lambda nil (if helm-ff-file-name-history-use-recentf recentf-list file-name-history)) (persistent-action . ignore) (filtered-candidate-transformer . helm-file-name-history-transformer) (action ("Find file" lambda (candidate) (helm-set-pattern (expand-file-name candidate)) (with-helm-after-update-hook (helm-exit-minibuffer))) ("Find file in helm" lambda (candidate) (helm-set-pattern (expand-file-name candidate))))))
(setq-default helm-source-comint-input-ring '((name . "Comint history") (candidates lambda nil (with-helm-current-buffer (ring-elements comint-input-ring))) (action . helm-comint-input-ring-action)))
(setq-default helm-source-complex-command-history '((name . "Complex Command History") (candidates lambda nil (mapcar (quote prin1-to-string) command-history)) (type . sexp)))
(setq-default helm-source-file-name-history '((name . "File Name History") (candidates . file-name-history) (persistent-action . ignore) (filtered-candidate-transformer . helm-file-name-history-transformer) (action ("Find file" . helm-find-many-files) ("Find file as root" . helm-find-file-as-root) ("Find file other window" . find-file-other-window) ("Find file other frame" . find-file-other-frame) ("Open dired in file's directory" . helm-open-dired) ("Grep File(s) `C-u recurse'" . helm-find-files-grep) ("Zgrep File(s) `C-u Recurse'" . helm-ff-zgrep) ("Pdfgrep File(s)" . helm-ff-pdfgrep) ("Insert as org link" . helm-files-insert-as-org-link) ("Checksum File" . helm-ff-checksum) ("Ediff File" . helm-find-files-ediff-files) ("Ediff Merge File" . helm-find-files-ediff-merge-files) ("Etags `M-., C-u tap, C-u C-u reload tag file'" . helm-ff-etags-select) ("View file" . view-file) ("Insert file" . insert-file) ("Delete file(s)" . helm-delete-marked-files) ("Open file externally (C-u to choose)" . helm-open-file-externally) ("Open file with default tool" . helm-open-file-with-default-tool) ("Find file in hex dump" . hexl-find-file))))
(setq-default helm-source-global-mark-ring '((name . "global-mark-ring") (candidates . helm-global-mark-ring-get-candidates) (action ("Goto line" lambda (candidate) (let ((items (split-string candidate ":"))) (helm-switch-to-buffer (cl-second items)) (helm-goto-line (string-to-number (car items)))))) (persistent-action lambda (candidate) (let ((items (split-string candidate ":"))) (helm-switch-to-buffer (cl-second items)) (helm-goto-line (string-to-number (car items))) (helm-highlight-current-line))) (persistent-help . "Show this line")))
(setq-default helm-source-kill-ring '((name . "Kill Ring") (init lambda nil (helm-attrset (quote last-command) last-command)) (candidates . helm-kill-ring-candidates) (filtered-candidate-transformer helm-kill-ring-transformer) (action ("Yank" . helm-kill-ring-action) ("Delete" lambda (candidate) (cl-loop for cand in (helm-marked-candidates) do (setq kill-ring (delete cand kill-ring))))) (keymap keymap (27 keymap (117 . helm-previous-line) (121 . helm-next-line)) keymap (menu-bar keymap (help-menu keymap (describe keymap (describe-mode . helm-help)))) (help keymap (109 . helm-help)) (f1 keymap (109 . helm-help)) (8 . delete-backward-char) (20 . helm-toggle-resplit-and-swap-windows) (C-tab . undefined) (triple-mouse-3 . ignore) (double-mouse-3 . ignore) (mouse-3 . ignore) (drag-mouse-3 . ignore) (down-mouse-3 . ignore) (triple-mouse-2 . ignore) (double-mouse-2 . ignore) (mouse-2 . ignore) (drag-mouse-2 . ignore) (down-mouse-2 . ignore) (triple-mouse-1 . ignore) (double-mouse-1 . ignore) (mouse-1 . ignore) (drag-mouse-1 . ignore) (down-mouse-1 . ignore) (67108897 . helm-toggle-suspend-update) (3 keymap (1 . all-from-helm-occur) (21 . helm-force-update) (6 . helm-follow-mode) (11 . helm-kill-selection-and-quit) (25 . helm-yank-selection) (4 . helm-delete-current-selection) (45 . helm-swap-windows)) (67108987 . helm-enlarge-window) (67108989 . helm-narrow-window) (19 . undefined) (18 . undefined) (23 . helm-yank-text-at-point) (24 keymap (2 . helm-resume-list-buffers-after-quit) (98 . helm-resume-previous-session-after-quit) (6 . helm-quit-and-find-file)) (11 . helm-delete-minibuffer-contents) (67108896 . helm-toggle-visible-mark) (0 . helm-toggle-visible-mark) (C-M-up . helm-scroll-other-window-down) (C-M-down . helm-scroll-other-window) (M-prior . helm-scroll-other-window-down) (M-next . helm-scroll-other-window) (12 . helm-recenter-top-bottom-other-window) (15 . helm-next-source) (10 . helm-select-3rd-action) (5 . helm-select-2nd-action-or-end-of-line) (26 . helm-execute-persistent-action) (9 . helm-select-action) (13 . helm-exit-minibuffer) (left . helm-previous-source) (right . helm-next-source) (7 . helm-keyboard-quit) (22 . helm-next-page) (27 keymap (110 . next-history-element) (112 . previous-history-element) (115 . undefined) (5 . helm-display-all-sources) (1 . helm-show-all-in-this-source-only) (117 . helm-unmark-all) (97 . helm-mark-all) (109 . helm-toggle-all-marks) (41 . helm-next-visible-mark) (40 . helm-prev-visible-mark) (91) (32 . helm-toggle-visible-mark) (33554454 . helm-scroll-other-window-down) (25 . helm-scroll-other-window-down) (22 . helm-scroll-other-window) (12 . helm-reposition-window-other-window) (62 . helm-end-of-buffer) (60 . helm-beginning-of-buffer) (118 . helm-previous-page)) (next . helm-next-page) (prior . helm-previous-page) (16 . helm-previous-line) (14 . helm-next-line) (up . helm-previous-line) (down . helm-next-line) keymap (26 . undefined) (18 . helm-minibuffer-history) (S-tab . zlc-select-previous) (backtab . zlc-select-previous) (menu-bar keymap (minibuf #1="Minibuf" keymap (previous menu-item "Previous History Item" previous-history-element :help "Put previous minibuffer history element in the minibuffer") (next menu-item "Next History Item" next-history-element :help "Put next minibuffer history element in the minibuffer") (isearch-backward menu-item "Isearch History Backward" isearch-backward :help "Incrementally search minibuffer history backward") (isearch-forward menu-item "Isearch History Forward" isearch-forward :help "Incrementally search minibuffer history forward") (return menu-item "Enter" exit-minibuffer :key-sequence "" :help "Terminate input and exit minibuffer") (quit menu-item "Quit" abort-recursive-edit :help "Abort input and exit minibuffer") #1#)) (10 . exit-minibuffer) (13 . exit-minibuffer) (7 . minibuffer-keyboard-quit) (C-tab . file-cache-minibuffer-complete) (9 . self-insert-command) (XF86Back . previous-history-element) (up . previous-history-element) (prior . previous-history-element) (XF86Forward . next-history-element) (down . next-history-element) (next . next-history-element) (27 keymap (63 . session-minibuffer-history-help) (114 . previous-matching-history-element) (115 . next-matching-history-element) (112 . previous-history-element) (110 . next-history-element))) (last-command . helm-keyboard-quit) (migemo) (multiline)))
(setq-default helm-source-mark-ring '((name . "mark-ring") (candidates . helm-mark-ring-get-candidates) (action ("Goto line" lambda (candidate) (helm-goto-line (string-to-number candidate)))) (persistent-action lambda (candidate) (helm-goto-line (string-to-number candidate)) (helm-highlight-current-line)) (persistent-help . "Show this line")))
(setq-default helm-source-minibuffer-history '((name . "Minibuffer History") (header-name lambda (name) (format "%s (%s)" name minibuffer-history-variable)) (candidates lambda nil (let ((history (cl-loop for i in (symbol-value minibuffer-history-variable) unless (string= "" i) collect i))) (if (consp (car history)) (mapcar (quote prin1-to-string) history) history))) (migemo) (multiline) (action lambda (candidate) (delete-minibuffer-contents) (insert candidate))))
(setq-default minibuffer-history '("/sudo:root@VAIO:/etc/clamav/" "/etc/clamav/" "pack" "evince paper.pdf" "/home/k-ohsugi/Dropbox/research/work/society14/paper.tex" "/mnt/Dropbox/research/work/" "tex" #("mincho" 0 6 (fontified t)) "org" "/mnt/Dropbox/research/work/society14/pap" "/mnt/Dropbox/research/work/society14/" "/mnt/Dropbox/" "org-mode" "figure" "rc.lua" "-------"))
(setq-default occur-collect-regexp-history '("\\1"))
(setq-default query-replace-history '("screen.count ()" "2" "time -p" "time" "3s" "10s" "${SIZE}" "1GB" "\"" "'" "NAME" "NAME1" "10MB" "1MB" "1024" "4096" "68" "204" "819" "COUNT" "NPARA" "50000" "10000" "45" "50" "research_2014_group_001-ccn.pdf" "research_group_001-icn.pdf" "M1" "B4" "M" "M2" "Master" "Doctor" "D3" "./figure/" "./"))
(setq-default regexp-history '("block" "blocksize"))
(setq-default search-ring '("fig" "insert" "bfast" "counting" "s = " "k個" "k" "       時" "beamer" "so" "so that" "energy" "hu" "hungry" "consume" "network"))
(setq-default serial-name-history '("/dev/ttyS0"))
(setq-default serial-speed-history '("9600" "1200" "2400" "4800" "14400" "19200" "28800" "38400" "57600" "115200"))
(setq-default shell-command-history '("'" "4096"))
(setq-default table-capture-columns-history '(""))
(setq-default table-capture-justify-history '("left"))
(setq-default table-capture-min-cell-width-history '("5"))
(setq-default table-cell-height-history '("1"))
(setq-default table-cell-span-direction-history '("right"))
(setq-default table-cell-split-contents-to-history '("split"))
(setq-default table-cell-split-orientation-history '("horizontally"))
(setq-default table-cell-width-history '("5"))
(setq-default table-col-delim-regexp-history '(""))
(setq-default table-columns-history '("3"))
(setq-default table-insert-row-column-history '("row"))
(setq-default table-justify-history '("center"))
(setq-default table-row-delim-regexp-history '(""))
(setq-default table-rows-history '("3"))
(setq-default table-sequence-count-history '("0"))
(setq-default table-sequence-increment-history '("1"))
(setq-default table-sequence-interval-history '("1"))
(setq-default table-sequence-justify-history '("left"))
(setq-default table-sequence-string-history '("0"))
(setq-default table-source-caption-history '("Table"))
(setq-default table-source-language-history '("html"))
(setq-default table-target-history '("cell"))
