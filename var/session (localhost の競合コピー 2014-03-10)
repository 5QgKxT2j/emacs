;;; Automatically generated on Fri Mar  7 18:02:26 2014
;;; Invoked by k-ohsugi@localhost using 24.3.1
(setq-default kill-ring '("% Created 2014-03-05 Wed 14:12
\\documentclass[dvipdfmx,12pt]{beamer}
\\usepackage{url}
\\usepackage{pxjahyper}
\\usetheme{Berlin}
\\setbeamertemplate{navigation symbols}{}
\\beamertemplatetextbibitems
\\setbeamertemplate{footline}[frame number]
\\setbeamertemplate{headline}{}


\\institute[]{大阪大学大学院情報科学研究科\\\\
            情報ネットワーク学専攻\\\\
            情報流通プラットフォーム講座 長谷川研究室 M1}
\\usetheme{default}
\\author{大杉 海斗}
\\date{\\today}
\\title{M1 Meeting}
\\hypersetup{
  pdfkeywords={},
  pdfsubject={},
  pdfcreator={Emacs 24.3.1 (Org mode 8.2.5h)}}
\\begin{document}

\\maketitle

\\section{2014 年 3 月 12 日}
\\label{sec-1}
\\begin{frame}[label=sec-1-1]{前回ミーティングのまとめ}
\\begin{itemize}
\\item 「 Scalable NDN Forwarding:Concepts, Issues and Principles 」を読
み， CCNx のデータ構造についてまとめたが，説明不足な部分があったた
め，更新した
\\end{itemize}
\\begin{block}{短期的な目標}%x
\\begin{itemize}
\\item CCNx の ver8.1 で機能ごとのブロックを作り，ブロックの処理に必要な
クロック数を測定する
\\end{itemize}
\\end{block}

\\begin{block}{中期的な目標}%x
\\begin{itemize}
\\item 現在はルータの CPU がシングルコアの時のみモデル化できているため，
マルチコアに対応させる
\\end{itemize}
\\end{block}
\\end{frame}

\\begin{frame}[label=sec-1-2]{Scalable NDN Forwarding:Concepts, Issues and Principles}
\\begin{itemize}
\\item 本論文は， CCNx のデータ構造とオペレーショナルフローについてまとめている
\\item ただし， CCNx の ver4.0 を対象としているため，現在の最新である
ver8.1 とは一部異なる可能性がある
\\begin{itemize}
\\item 次スライドから述べる CCNx のデータ構造は ver4.0 のものであること
に留意する
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-3]{CCNx のデータ構造}
\\begin{itemize}
\\item CCNx のデータ構造は NDN と異なっている
\\begin{itemize}
\\item NDN
\\begin{itemize}
\\item CS ・ FIB ・ PIT の 3 つのテーブルを持つ
\\end{itemize}
\\item CCNx
\\begin{itemize}
\\item CS に相当する Content Hash Table (CHT) と Content Skip List
(CSL) を持つ
\\item FIB と PIT に相当する Name Prefix Hash Table (NPHT) を持つ
\\item PIT に存在するすべての Interest (PEs の形) の nonce を保持す
る Propagating Hash Table (PHT) を持つ
\\end{itemize}
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-1-4]{CCNx のデータ構造図}
\\includegraphics[width=.9\\linewidth]{./ccnx_data_structure.pdf}
\\end{frame}
\\begin{frame}[label=sec-1-5]{CCNx における CS の概要}
\\begin{itemize}
\\item Data の格納場所と， Data を指すポインタをエントリに持つテーブルに分けられる
\\begin{itemize}
\\item Data の格納場所
\\begin{itemize}
\\item Content Array (CA)
\\item Straggler Hash Table (SHT)
\\end{itemize}
\\item テーブル
\\begin{itemize}
\\item Content Hash Table (CHT)
\\item Content Skip List (CSL)
\\end{itemize}
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-6]{CS における Data の格納}
\\begin{itemize}
\\item Data に番号をつけて， CA か SHT に保存する
\\begin{itemize}
\\item daemon に到着した Data には，ユニークな accession number が割り
当てられる
\\begin{itemize}
\\item accession number は， 1 ずつ増加する
\\end{itemize}
\\item キャッシュされた Data は， Content Array (CA) に保存さ
れ， accession number によってインデックスされる
\\item Data がキャッシュされるごとに CA がサポートする accession
number の範囲が移動する
\\begin{itemize}
\\item サポートするスロット数は固定であるため，スライディングウィン
ドウのようにサポートする場所が移動していく
\\end{itemize}
\\item 古くなり CA のサポートから外れたが，人気のある Data は， SHT に
保存される
\\begin{itemize}
\\item どうやって Data が人気か判断するのか， CA と同じように accession
number でアクセスするのか分からないため，ソースを読む必要があ
る
\\end{itemize}
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-1-7]{Content Store のテーブル}
\\begin{itemize}
\\item Content Hash Table (CHT)
\\begin{itemize}
\\item key は Data のフルネーム
\\end{itemize}
\\item Content Skip List (CSL)
\\begin{itemize}
\\item 標準的な skip list
\\item コンテンツ名順の lookup をサポートするために必要
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-1-8]{CCNx における FIB と PIT の概要}
\\begin{itemize}
\\item FIB と PIT はともに， Name Prefix Hash Table (NPHT) によって管理
される
\\begin{itemize}
\\item NPHT は Propagating Entries (PEs) と Forwarding Info Entries
(FIEs) にインデックスしている
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-9]{CCNx のオペレーショナルフロー}
\\begin{itemize}
\\item CCNx では， Interest と Data は，異なる関数で処理される
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-1-10]{Interest 処理のオペレーショナルフロー図}
\\includegraphics[width=.9\\linewidth]{./ccnx_interest_flow.pdf}
\\end{frame}
\\begin{frame}[label=sec-1-11]{Interest 処理のオペレーショナルフロー (1)}
\\begin{itemize}
\\item Interest が CCNx daemon に到着した時の処理を順に述べる
\\begin{enumerate}
\\item CCNx daemon は，バイナリをデコードし， name 部とオプション部に
parse
\\item Interest の nonce を key として， PHT で正確な一致検索を行う
\\begin{itemize}
\\item loop している Interest の破棄
\\end{itemize}
\\item Prefix Seek を行う
\\begin{enumerate}
\\item Interest の prefix が\\alert{すべて}存在するかを NPHT でチェックする
\\item 存在しなければ， NPHT に新たなエントリを作成
\\item 2 の時， fast lookup のため prefix は親へのポインタを張る
\\end{enumerate}
\\end{enumerate}
\\end{itemize}

\\includegraphics[width=0.8\\linewidth,height=0.15\\paperheight]{./npht.pdf}
\\end{frame}
\\begin{frame}[label=sec-1-12]{Interest 処理のオペレーショナルフロー (2)}
\\begin{enumerate}
\\item Interest に対応する Data がキャッシュされているか CS をチェック
\\begin{enumerate}
\\item CSL で潜在的にマッチし得るコンテンツを探索
\\item マッチした場合，そのコンテンツを CS から取ってきて，本当に
Interest を満たすものかどうかチェック
\\begin{itemize}
\\item Interest には，特定コンテンツを排除する除外フィルタなどがあ
るため name だけでは不十分であるため
\\end{itemize}
\\end{enumerate}
\\end{enumerate}
\\end{frame}

\\begin{frame}[label=sec-1-13]{Interest 処理のオペレーショナルフロー (3)}
\\begin{enumerate}
\\item コンテンツ有: Interest を消費した (Interest Comsuming の処理) 後， Data パケットを返送し， NPHT
と PHT から Interest の name を除去
\\begin{itemize}
\\item Data が/a/b/0/1 なら，\\alert{/a/b/0 ・/a/b ・/a をすべて}探索
する
\\begin{itemize}
\\item できるだけ多くの Interest を消費するため
\\item 例えば， Interest /a/b/0 が，最初の 3 コンポネントでのみのマッチを
必要としている場合，コンテンツ/a/b/0/1 が Interest/a/b/0 を満たす
\\end{itemize}
\\end{itemize}

\\item コンテンツ無: NPHT で最長一致検索を行う (FIB の処理)
\\begin{enumerate}
\\item Interest の fullname で探索→ 1 つコンポネント長を短くしたもの
で探索．．．．．．をマッチするか， root prefix に到達するまで繰り返す
\\item Interest を転送した後， NPHT に Interest message を含んだエントリ
を追加， PHT に Interest の nonce を追加
\\end{enumerate}
\\end{enumerate}
\\end{frame}
\\begin{frame}[label=sec-1-14]{Data 処理のオペレーショナルフロー図}
\\includegraphics[width=.9\\linewidth]{./ccnx_data_flow.pdf}
\\end{frame}
\\begin{frame}[label=sec-1-15]{Data 処理のオペレーショナルフロー}
\\begin{itemize}
\\item Interest が CCNx daemon に到着した時の処理を順に述べる
\\begin{enumerate}
\\item CCNx daemon は，バイナリをデコードし， parse
\\item CS seek, saving
\\begin{itemize}
\\item CHT での正確なマッチングを行い，キャシュされているかを確認
(key は Data の full name)
\\item Data は， CHT と CSL に挿入され， CS に格納される
\\end{itemize}
\\item Interest の処理と同様の Interest Consuming の処理
\\end{enumerate}
\\end{itemize}
\\end{frame}

\\section{2014 年 3 月 5 日}
\\label{sec-2}
\\begin{frame}[label=sec-2-1]{前回ミーティングのまとめ}
\\begin{itemize}
\\item 「 Scalable NDN Forwarding:Concepts, Issues and Principles 」を読
み， CCNx のデータ構造についてまとめ， CCNx のデータ構造について
の理解を深める
\\end{itemize}
\\begin{block}{短期的な目標}%x
\\begin{itemize}
\\item CCNx の ver8.1 で機能ごとのブロックを作り，ブロックの処理に必要な
クロック数を測定する
\\end{itemize}
\\end{block}

\\begin{block}{長期的な目標}%x
\\begin{itemize}
\\item 現在はルータの CPU がシングルコアの時のみモデル化できているため，
マルチコアに対応させる
\\end{itemize}
\\end{block}
\\end{frame}

\\begin{frame}[label=sec-2-2]{Scalable NDN Forwarding:Concepts, Issues and Principles}
\\begin{itemize}
\\item 本論文は， CCNx のデータ構造とオペレーショナルフローについてまとめている
\\item ただし， CCNx の ver4.0 を対象としているため，現在の最新である
ver8.1 とは一部異なる可能性がある
\\begin{itemize}
\\item 次スライドから述べる CCNx のデータ構造は ver4.0 のものであること
に留意する
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-2-3]{CCNx のデータ構造}
\\begin{itemize}
\\item CCNx のデータ構造は NDN と異なっている
\\begin{itemize}
\\item NDN
\\begin{itemize}
\\item CS ・ FIB ・ PIT の 3 つのテーブルを持つ
\\end{itemize}
\\item CCNx
\\begin{itemize}
\\item CS に相当する Content Hash Table (CHT) と Content Skip List
(CSL) を持つ
\\item FIB と PIT に相当する Name Prefix Hash Table (NPHT) を持つ
\\item PIT に存在するすべての Interest (PEs の形) の nonce を保持す
る Propagating Hash Table (PHT) を持つ
\\end{itemize}
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-2-4]{CCNx のデータ構造図}
\\includegraphics[width=.9\\linewidth]{./ccnx_data_structure.pdf}
\\end{frame}
\\begin{frame}[label=sec-2-5]{CCNx における CS の概要}
\\begin{itemize}
\\item Data の格納場所と， Data を指すポインタをエントリに持つテーブルに分けられる
\\begin{itemize}
\\item Data の格納場所
\\begin{itemize}
\\item Content Array (CA)
\\item Straggler Hash Table (SHT)
\\end{itemize}
\\item テーブル
\\begin{itemize}
\\item Content Hash Table (CHT)
\\item Content Skip List (CSL)
\\end{itemize}
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-2-6]{CS における Data の格納}
\\begin{itemize}
\\item Data に番号をつけて， CA か SHT に保存する
\\begin{itemize}
\\item daemon に到着した Data には，ユニークな accession number が割り
当てられる
\\begin{itemize}
\\item accession number は， 1 ずつ増加する
\\end{itemize}
\\item キャッシュされた Data は， Content Array (CA) に保存さ
れ， accession number によってインデックスされる
\\item Data がキャッシュされるごとに CA がサポートする accession
number の範囲が移動する
\\begin{itemize}
\\item サポートするスロット数は固定であるため，スライディングウィン
ドウのようにサポートする場所が移動していく
\\end{itemize}
\\item 古くなり CA のサポートから外れたが，人気のある Data は， SHT に
保存される
\\begin{itemize}
\\item どうやって Data が人気か判断するのか， CA と同じように accession
number でアクセスするのか分からないため，ソースを読む必要があ
る
\\end{itemize}
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-2-7]{Content Store のテーブル}
\\begin{itemize}
\\item Content Hash Table (CHT)
\\begin{itemize}
\\item key は Data のフルネーム
\\end{itemize}
\\item Content Skip List (CSL)
\\begin{itemize}
\\item 標準的な skip list
\\item コンテンツ名順の lookup をサポートするために必要
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-2-8]{CCNx における FIB と PIT の概要}
\\begin{itemize}
\\item FIB と PIT はともに， Name Prefix Hash Table (NPHT) によって管理
される
\\begin{itemize}
\\item NPHT は Propagating Entries (PEs) と Forwarding Info Entries
(FIEs) にインデックスしている
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-2-9]{CCNx のオペレーショナルフロー}
\\begin{itemize}
\\item CCNx では， Interest と Data は，異なる関数で処理される
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-2-10]{Interest 処理のオペレーショナルフロー図}
\\includegraphics[width=.9\\linewidth]{./ccnx_interest_flow.pdf}
\\end{frame}
\\begin{frame}[label=sec-2-11]{Interest 処理のオペレーショナルフロー (1)}
\\begin{itemize}
\\item Interest が CCNx daemon に到着した時の処理を順に述べる
\\begin{enumerate}
\\item CCNx daemon は，バイナリをデコードし， name 部とオプション部に
parse
\\item Interest の nonce を key として， PHT で正確な一致検索を行う
\\begin{itemize}
\\item loop している Interest の破棄
\\end{itemize}
\\item Prefix Seek を行う
\\begin{enumerate}
\\item Interest の prefix が\\alert{すべて}存在するかを NPHT でチェックする
\\item 存在しなければ， NPHT に新たなエントリを作成
\\item 2 の時， fast lookup のため prefix は親へのポインタを張る
\\end{enumerate}
\\end{enumerate}
\\end{itemize}

\\includegraphics[width=0.8\\linewidth,height=0.15\\paperheight]{./npht.pdf}
\\end{frame}
\\begin{frame}[label=sec-2-12]{Interest 処理のオペレーショナルフロー (2)}
\\begin{enumerate}
\\item Interest に対応する Data がキャッシュされているか CS をチェック
\\begin{enumerate}
\\item CSL で潜在的にマッチし得るコンテンツを探索
\\item マッチした場合，そのコンテンツを CS から取ってきて，本当に
Interest を満たすものかどうかチェック
\\begin{itemize}
\\item Interest には，特定コンテンツを排除する除外フィルタなどがあ
るため name だけでは不十分であるため
\\end{itemize}
\\end{enumerate}
\\end{enumerate}
\\end{frame}

\\begin{frame}[label=sec-2-13]{Interest 処理のオペレーショナルフロー (3)}
\\begin{enumerate}
\\item コンテンツ有: Interest を消費した (Interest Comsuming の処理) 後， Data パケットを返送し， NPHT
と PHT から Interest の name を除去
\\begin{itemize}
\\item Data が/a/b/0/1 なら，\\alert{/a/b/0 ・/a/b ・/a をすべて}探索
する
\\begin{itemize}
\\item できるだけ多くの Interest を消費するため
\\item 例えば， Interest /a/b/0 が，最初の 3 コンポネントでのみのマッチを
必要としている場合，コンテンツ/a/b/0/1 が Interest/a/b/0 を満たす
\\end{itemize}
\\end{itemize}

\\item コンテンツ無: NPHT で最長一致検索を行う (FIB の処理)
\\begin{enumerate}
\\item Interest の fullname で探索→ 1 つコンポネント長を短くしたもの
で探索．．．．．．をマッチするか， root prefix に到達するまで繰り返す
\\item Interest を転送した後， NPHT に Interest message を含んだエントリ
を追加， PHT に Interest の nonce を追加
\\end{enumerate}
\\end{enumerate}
\\end{frame}
\\begin{frame}[label=sec-2-14]{Data 処理のオペレーショナルフロー図}
\\includegraphics[width=.9\\linewidth]{./ccnx_data_flow.pdf}
\\end{frame}
\\begin{frame}[label=sec-2-15]{Data 処理のオペレーショナルフロー}
\\begin{itemize}
\\item Interest が CCNx daemon に到着した時の処理を順に述べる
\\begin{enumerate}
\\item CCNx daemon は，バイナリをデコードし， parse
\\item CS seek, saving
\\begin{itemize}
\\item CHT での正確なマッチングを行い，キャシュされているかを確認
(key は Data の full name)
\\item Data は， CHT と CSL に挿入され， CS に格納される
\\end{itemize}
\\item Interest の処理と同様の Interest Consuming の処理
\\end{enumerate}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-2-16]{所感}
\\begin{itemize}
\\item CCNx のデータ構造について大まかな理解はできたと思われる
\\item 一方で，各テーブルのエントリの構造などの細かい所については触れられ
ていなかったため，ソースコードを読んでいく必要があると感じた
\\end{itemize}
\\end{frame}
% Emacs 24.3.1 (Org mode 8.2.5h)
\\end{document}" #("をを行った" 0 5 (fontified t)) #("り，不
     十分であったため，修正をを行った" 0 1 (fontified t) 1 2 (fontified t) 2 3 (fontified t) 3 4 (fontified t) 4 9 (fontified t) 9 17 (fontified t) 17 25 (fontified t)) "% Created 2014-03-05 Wed 14:10
\\documentclass[dvipdfmx,12pt]{beamer}
\\usepackage{url}
\\usepackage{pxjahyper}
\\usetheme{Berlin}
\\setbeamertemplate{navigation symbols}{}
\\beamertemplatetextbibitems
\\setbeamertemplate{footline}[frame number]
\\setbeamertemplate{headline}{}


\\institute[]{大阪大学大学院情報科学研究科\\\\
            情報ネットワーク学専攻\\\\
            情報流通プラットフォーム講座 長谷川研究室 M1}
\\usetheme{default}
\\author{大杉 海斗}
\\date{\\today}
\\title{M1 Meeting}
\\hypersetup{
  pdfkeywords={},
  pdfsubject={},
  pdfcreator={Emacs 24.3.1 (Org mode 8.2.5h)}}
\\begin{document}

\\maketitle

\\section{2014 年 3 月 12 日}
\\label{sec-1}
\\begin{frame}[label=sec-1-1]{前回ミーティングのまとめ}
\\begin{itemize}
\\item 「 Scalable NDN Forwarding:Concepts, Issues and Principles 」を読
み， CCNx のデータ構造についてまとめたが，一部説明な部分があり，
不十分であったため，修正をを行った
\\end{itemize}
\\begin{block}{短期的な目標}%x
\\begin{itemize}
\\item CCNx の ver8.1 で機能ごとのブロックを作り，ブロックの処理に必要な
クロック数を測定する
\\end{itemize}
\\end{block}

\\begin{block}{中期的な目標}%x
\\begin{itemize}
\\item 現在はルータの CPU がシングルコアの時のみモデル化できているため，
マルチコアに対応させる
\\end{itemize}
\\end{block}
\\end{frame}

\\begin{frame}[label=sec-1-2]{Scalable NDN Forwarding:Concepts, Issues and Principles}
\\begin{itemize}
\\item 本論文は， CCNx のデータ構造とオペレーショナルフローについてまとめている
\\item ただし， CCNx の ver4.0 を対象としているため，現在の最新である
ver8.1 とは一部異なる可能性がある
\\begin{itemize}
\\item 次スライドから述べる CCNx のデータ構造は ver4.0 のものであること
に留意する
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-3]{CCNx のデータ構造}
\\begin{itemize}
\\item CCNx のデータ構造は NDN と異なっている
\\begin{itemize}
\\item NDN
\\begin{itemize}
\\item CS ・ FIB ・ PIT の 3 つのテーブルを持つ
\\end{itemize}
\\item CCNx
\\begin{itemize}
\\item CS に相当する Content Hash Table (CHT) と Content Skip List
(CSL) を持つ
\\item FIB と PIT に相当する Name Prefix Hash Table (NPHT) を持つ
\\item PIT に存在するすべての Interest (PEs の形) の nonce を保持す
る Propagating Hash Table (PHT) を持つ
\\end{itemize}
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-1-4]{CCNx のデータ構造図}
\\includegraphics[width=.9\\linewidth]{./ccnx_data_structure.pdf}
\\end{frame}
\\begin{frame}[label=sec-1-5]{CCNx における CS の概要}
\\begin{itemize}
\\item Data の格納場所と， Data を指すポインタをエントリに持つテーブルに分けられる
\\begin{itemize}
\\item Data の格納場所
\\begin{itemize}
\\item Content Array (CA)
\\item Straggler Hash Table (SHT)
\\end{itemize}
\\item テーブル
\\begin{itemize}
\\item Content Hash Table (CHT)
\\item Content Skip List (CSL)
\\end{itemize}
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-6]{CS における Data の格納}
\\begin{itemize}
\\item Data に番号をつけて， CA か SHT に保存する
\\begin{itemize}
\\item daemon に到着した Data には，ユニークな accession number が割り
当てられる
\\begin{itemize}
\\item accession number は， 1 ずつ増加する
\\end{itemize}
\\item キャッシュされた Data は， Content Array (CA) に保存さ
れ， accession number によってインデックスされる
\\item Data がキャッシュされるごとに CA がサポートする accession
number の範囲が移動する
\\begin{itemize}
\\item サポートするスロット数は固定であるため，スライディングウィン
ドウのようにサポートする場所が移動していく
\\end{itemize}
\\item 古くなり CA のサポートから外れたが，人気のある Data は， SHT に
保存される
\\begin{itemize}
\\item どうやって Data が人気か判断するのか， CA と同じように accession
number でアクセスするのか分からないため，ソースを読む必要があ
る
\\end{itemize}
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-1-7]{Content Store のテーブル}
\\begin{itemize}
\\item Content Hash Table (CHT)
\\begin{itemize}
\\item key は Data のフルネーム
\\end{itemize}
\\item Content Skip List (CSL)
\\begin{itemize}
\\item 標準的な skip list
\\item コンテンツ名順の lookup をサポートするために必要
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-1-8]{CCNx における FIB と PIT の概要}
\\begin{itemize}
\\item FIB と PIT はともに， Name Prefix Hash Table (NPHT) によって管理
される
\\begin{itemize}
\\item NPHT は Propagating Entries (PEs) と Forwarding Info Entries
(FIEs) にインデックスしている
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-9]{CCNx のオペレーショナルフロー}
\\begin{itemize}
\\item CCNx では， Interest と Data は，異なる関数で処理される
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-1-10]{Interest 処理のオペレーショナルフロー図}
\\includegraphics[width=.9\\linewidth]{./ccnx_interest_flow.pdf}
\\end{frame}
\\begin{frame}[label=sec-1-11]{Interest 処理のオペレーショナルフロー (1)}
\\begin{itemize}
\\item Interest が CCNx daemon に到着した時の処理を順に述べる
\\begin{enumerate}
\\item CCNx daemon は，バイナリをデコードし， name 部とオプション部に
parse
\\item Interest の nonce を key として， PHT で正確な一致検索を行う
\\begin{itemize}
\\item loop している Interest の破棄
\\end{itemize}
\\item Prefix Seek を行う
\\begin{enumerate}
\\item Interest の prefix が\\alert{すべて}存在するかを NPHT でチェックする
\\item 存在しなければ， NPHT に新たなエントリを作成
\\item 2 の時， fast lookup のため prefix は親へのポインタを張る
\\end{enumerate}
\\end{enumerate}
\\end{itemize}

\\includegraphics[width=0.8\\linewidth,height=0.15\\paperheight]{./npht.pdf}
\\end{frame}
\\begin{frame}[label=sec-1-12]{Interest 処理のオペレーショナルフロー (2)}
\\begin{enumerate}
\\item Interest に対応する Data がキャッシュされているか CS をチェック
\\begin{enumerate}
\\item CSL で潜在的にマッチし得るコンテンツを探索
\\item マッチした場合，そのコンテンツを CS から取ってきて，本当に
Interest を満たすものかどうかチェック
\\begin{itemize}
\\item Interest には，特定コンテンツを排除する除外フィルタなどがあ
るため name だけでは不十分であるため
\\end{itemize}
\\end{enumerate}
\\end{enumerate}
\\end{frame}

\\begin{frame}[label=sec-1-13]{Interest 処理のオペレーショナルフロー (3)}
\\begin{enumerate}
\\item コンテンツ有: Interest を消費した (Interest Comsuming の処理) 後， Data パケットを返送し， NPHT
と PHT から Interest の name を除去
\\begin{itemize}
\\item Data が/a/b/0/1 なら，\\alert{/a/b/0 ・/a/b ・/a をすべて}探索
する
\\begin{itemize}
\\item できるだけ多くの Interest を消費するため
\\item 例えば， Interest /a/b/0 が，最初の 3 コンポネントでのみのマッチを
必要としている場合，コンテンツ/a/b/0/1 が Interest/a/b/0 を満たす
\\end{itemize}
\\end{itemize}

\\item コンテンツ無: NPHT で最長一致検索を行う (FIB の処理)
\\begin{enumerate}
\\item Interest の fullname で探索→ 1 つコンポネント長を短くしたもの
で探索．．．．．．をマッチするか， root prefix に到達するまで繰り返す
\\item Interest を転送した後， NPHT に Interest message を含んだエントリ
を追加， PHT に Interest の nonce を追加
\\end{enumerate}
\\end{enumerate}
\\end{frame}
\\begin{frame}[label=sec-1-14]{Data 処理のオペレーショナルフロー図}
\\includegraphics[width=.9\\linewidth]{./ccnx_data_flow.pdf}
\\end{frame}
\\begin{frame}[label=sec-1-15]{Data 処理のオペレーショナルフロー}
\\begin{itemize}
\\item Interest が CCNx daemon に到着した時の処理を順に述べる
\\begin{enumerate}
\\item CCNx daemon は，バイナリをデコードし， parse
\\item CS seek, saving
\\begin{itemize}
\\item CHT での正確なマッチングを行い，キャシュされているかを確認
(key は Data の full name)
\\item Data は， CHT と CSL に挿入され， CS に格納される
\\end{itemize}
\\item Interest の処理と同様の Interest Consuming の処理
\\end{enumerate}
\\end{itemize}
\\end{frame}

\\section{2014 年 3 月 5 日}
\\label{sec-2}
\\begin{frame}[label=sec-2-1]{前回ミーティングのまとめ}
\\begin{itemize}
\\item 「 Scalable NDN Forwarding:Concepts, Issues and Principles 」を読
み， CCNx のデータ構造についてまとめ， CCNx のデータ構造について
の理解を深める
\\end{itemize}
\\begin{block}{短期的な目標}%x
\\begin{itemize}
\\item CCNx の ver8.1 で機能ごとのブロックを作り，ブロックの処理に必要な
クロック数を測定する
\\end{itemize}
\\end{block}

\\begin{block}{長期的な目標}%x
\\begin{itemize}
\\item 現在はルータの CPU がシングルコアの時のみモデル化できているため，
マルチコアに対応させる
\\end{itemize}
\\end{block}
\\end{frame}

\\begin{frame}[label=sec-2-2]{Scalable NDN Forwarding:Concepts, Issues and Principles}
\\begin{itemize}
\\item 本論文は， CCNx のデータ構造とオペレーショナルフローについてまとめている
\\item ただし， CCNx の ver4.0 を対象としているため，現在の最新である
ver8.1 とは一部異なる可能性がある
\\begin{itemize}
\\item 次スライドから述べる CCNx のデータ構造は ver4.0 のものであること
に留意する
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-2-3]{CCNx のデータ構造}
\\begin{itemize}
\\item CCNx のデータ構造は NDN と異なっている
\\begin{itemize}
\\item NDN
\\begin{itemize}
\\item CS ・ FIB ・ PIT の 3 つのテーブルを持つ
\\end{itemize}
\\item CCNx
\\begin{itemize}
\\item CS に相当する Content Hash Table (CHT) と Content Skip List
(CSL) を持つ
\\item FIB と PIT に相当する Name Prefix Hash Table (NPHT) を持つ
\\item PIT に存在するすべての Interest (PEs の形) の nonce を保持す
る Propagating Hash Table (PHT) を持つ
\\end{itemize}
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-2-4]{CCNx のデータ構造図}
\\includegraphics[width=.9\\linewidth]{./ccnx_data_structure.pdf}
\\end{frame}
\\begin{frame}[label=sec-2-5]{CCNx における CS の概要}
\\begin{itemize}
\\item Data の格納場所と， Data を指すポインタをエントリに持つテーブルに分けられる
\\begin{itemize}
\\item Data の格納場所
\\begin{itemize}
\\item Content Array (CA)
\\item Straggler Hash Table (SHT)
\\end{itemize}
\\item テーブル
\\begin{itemize}
\\item Content Hash Table (CHT)
\\item Content Skip List (CSL)
\\end{itemize}
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-2-6]{CS における Data の格納}
\\begin{itemize}
\\item Data に番号をつけて， CA か SHT に保存する
\\begin{itemize}
\\item daemon に到着した Data には，ユニークな accession number が割り
当てられる
\\begin{itemize}
\\item accession number は， 1 ずつ増加する
\\end{itemize}
\\item キャッシュされた Data は， Content Array (CA) に保存さ
れ， accession number によってインデックスされる
\\item Data がキャッシュされるごとに CA がサポートする accession
number の範囲が移動する
\\begin{itemize}
\\item サポートするスロット数は固定であるため，スライディングウィン
ドウのようにサポートする場所が移動していく
\\end{itemize}
\\item 古くなり CA のサポートから外れたが，人気のある Data は， SHT に
保存される
\\begin{itemize}
\\item どうやって Data が人気か判断するのか， CA と同じように accession
number でアクセスするのか分からないため，ソースを読む必要があ
る
\\end{itemize}
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-2-7]{Content Store のテーブル}
\\begin{itemize}
\\item Content Hash Table (CHT)
\\begin{itemize}
\\item key は Data のフルネーム
\\end{itemize}
\\item Content Skip List (CSL)
\\begin{itemize}
\\item 標準的な skip list
\\item コンテンツ名順の lookup をサポートするために必要
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-2-8]{CCNx における FIB と PIT の概要}
\\begin{itemize}
\\item FIB と PIT はともに， Name Prefix Hash Table (NPHT) によって管理
される
\\begin{itemize}
\\item NPHT は Propagating Entries (PEs) と Forwarding Info Entries
(FIEs) にインデックスしている
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-2-9]{CCNx のオペレーショナルフロー}
\\begin{itemize}
\\item CCNx では， Interest と Data は，異なる関数で処理される
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-2-10]{Interest 処理のオペレーショナルフロー図}
\\includegraphics[width=.9\\linewidth]{./ccnx_interest_flow.pdf}
\\end{frame}
\\begin{frame}[label=sec-2-11]{Interest 処理のオペレーショナルフロー (1)}
\\begin{itemize}
\\item Interest が CCNx daemon に到着した時の処理を順に述べる
\\begin{enumerate}
\\item CCNx daemon は，バイナリをデコードし， name 部とオプション部に
parse
\\item Interest の nonce を key として， PHT で正確な一致検索を行う
\\begin{itemize}
\\item loop している Interest の破棄
\\end{itemize}
\\item Prefix Seek を行う
\\begin{enumerate}
\\item Interest の prefix が\\alert{すべて}存在するかを NPHT でチェックする
\\item 存在しなければ， NPHT に新たなエントリを作成
\\item 2 の時， fast lookup のため prefix は親へのポインタを張る
\\end{enumerate}
\\end{enumerate}
\\end{itemize}

\\includegraphics[width=0.8\\linewidth,height=0.15\\paperheight]{./npht.pdf}
\\end{frame}
\\begin{frame}[label=sec-2-12]{Interest 処理のオペレーショナルフロー (2)}
\\begin{enumerate}
\\item Interest に対応する Data がキャッシュされているか CS をチェック
\\begin{enumerate}
\\item CSL で潜在的にマッチし得るコンテンツを探索
\\item マッチした場合，そのコンテンツを CS から取ってきて，本当に
Interest を満たすものかどうかチェック
\\begin{itemize}
\\item Interest には，特定コンテンツを排除する除外フィルタなどがあ
るため name だけでは不十分であるため
\\end{itemize}
\\end{enumerate}
\\end{enumerate}
\\end{frame}

\\begin{frame}[label=sec-2-13]{Interest 処理のオペレーショナルフロー (3)}
\\begin{enumerate}
\\item コンテンツ有: Interest を消費した (Interest Comsuming の処理) 後， Data パケットを返送し， NPHT
と PHT から Interest の name を除去
\\begin{itemize}
\\item Data が/a/b/0/1 なら，\\alert{/a/b/0 ・/a/b ・/a をすべて}探索
する
\\begin{itemize}
\\item できるだけ多くの Interest を消費するため
\\item 例えば， Interest /a/b/0 が，最初の 3 コンポネントでのみのマッチを
必要としている場合，コンテンツ/a/b/0/1 が Interest/a/b/0 を満たす
\\end{itemize}
\\end{itemize}

\\item コンテンツ無: NPHT で最長一致検索を行う (FIB の処理)
\\begin{enumerate}
\\item Interest の fullname で探索→ 1 つコンポネント長を短くしたもの
で探索．．．．．．をマッチするか， root prefix に到達するまで繰り返す
\\item Interest を転送した後， NPHT に Interest message を含んだエントリ
を追加， PHT に Interest の nonce を追加
\\end{enumerate}
\\end{enumerate}
\\end{frame}
\\begin{frame}[label=sec-2-14]{Data 処理のオペレーショナルフロー図}
\\includegraphics[width=.9\\linewidth]{./ccnx_data_flow.pdf}
\\end{frame}
\\begin{frame}[label=sec-2-15]{Data 処理のオペレーショナルフロー}
\\begin{itemize}
\\item Interest が CCNx daemon に到着した時の処理を順に述べる
\\begin{enumerate}
\\item CCNx daemon は，バイナリをデコードし， parse
\\item CS seek, saving
\\begin{itemize}
\\item CHT での正確なマッチングを行い，キャシュされているかを確認
(key は Data の full name)
\\item Data は， CHT と CSL に挿入され， CS に格納される
\\end{itemize}
\\item Interest の処理と同様の Interest Consuming の処理
\\end{enumerate}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-2-16]{所感}
\\begin{itemize}
\\item CCNx のデータ構造について大まかな理解はできたと思われる
\\item 一方で，各テーブルのエントリの構造などの細かい所については触れられ
ていなかったため，ソースコードを読んでいく必要があると感じた
\\end{itemize}
\\end{frame}
% Emacs 24.3.1 (Org mode 8.2.5h)
\\end{document}" #("， CCNx のデータ構造について
     の理解を深める" 0 17 (fontified t) 17 18 (fontified t) 18 30 (fontified t)) #("** 前回ミーティングのまとめ
   - 「 Scalable NDN Forwarding:Concepts, Issues and Principles 」を読
     み， CCNx のデータ構造についてまとめ， CCNx のデータ構造について
     の理解を深める
*** 短期的な目標
    - CCNx の ver8.1 で機能ごとのブロックを作り，ブロックの処理に必要な
      クロック数を測定する
*** 長期的な目標
    - 現在はルータの CPU がシングルコアの時のみモデル化できているため，
      マルチコアに対応させる
** Scalable NDN Forwarding:Concepts, Issues and Principles
   - 本論文は， CCNx のデータ構造とオペレーショナルフローについてまとめている
   - ただし， CCNx の ver4.0 を対象としているため，現在の最新である
     ver8.1 とは一部異なる可能性がある
     - 次スライドから述べる CCNx のデータ構造は ver4.0 のものであること
       に留意する
** CCNx のデータ構造
   - CCNx のデータ構造は NDN と異なっている
     - NDN
       - CS ・ FIB ・ PIT の 3 つのテーブルを持つ
     - CCNx
       - CS に相当する Content Hash Table (CHT) と Content Skip List
         (CSL) を持つ
       - FIB と PIT に相当する Name Prefix Hash Table (NPHT) を持つ
       - PIT に存在するすべての Interest (PEs の形) の nonce を保持す
         る Propagating Hash Table (PHT) を持つ

** CCNx のデータ構造図
   [[./ccnx_data_structure.pdf]]

** CCNx における CS の概要
   - Data の格納場所と， Data を指すポインタをエントリに持つテーブルに分けられる
     - Data の格納場所
       - Content Array (CA)
       - Straggler Hash Table (SHT)
     - テーブル
       - Content Hash Table (CHT)
       - Content Skip List (CSL)
** CS における Data の格納
   - Data に番号をつけて， CA か SHT に保存する
     - daemon に到着した Data には，ユニークな accession number が割り
       当てられる
       - accession number は， 1 ずつ増加する
     - キャッシュされた Data は， Content Array (CA) に保存さ
       れ， accession number によってインデックスされる
     - Data がキャッシュされるごとに CA がサポートする accession
       number の範囲が移動する
       - サポートするスロット数は固定であるため，スライディングウィン
         ドウのようにサポートする場所が移動していく
     - 古くなり CA のサポートから外れたが，人気のある Data は， SHT に
       保存される
       - どうやって Data が人気か判断するのか， CA と同じように accession
         number でアクセスするのか分からないため，ソースを読む必要があ
         る

** Content Store のテーブル
   - Content Hash Table (CHT)
     - key は Data のフルネーム
   - Content Skip List (CSL)
     - 標準的な skip list
     - コンテンツ名順の lookup をサポートするために必要

** CCNx における FIB と PIT の概要
   - FIB と PIT はともに， Name Prefix Hash Table (NPHT) によって管理
     される
     - NPHT は Propagating Entries (PEs) と Forwarding Info Entries
       (FIEs) にインデックスしている


** CCNx のオペレーショナルフロー
   - CCNx では， Interest と Data は，異なる関数で処理される

** Interest 処理のオペレーショナルフロー図
[[./ccnx_interest_flow.pdf]]

** Interest 処理のオペレーショナルフロー (1)
   - Interest が CCNx daemon に到着した時の処理を順に述べる
     1. CCNx daemon は，バイナリをデコードし， name 部とオプション部に
        parse
     2. Interest の nonce を key として， PHT で正確な一致検索を行う
        - loop している Interest の破棄
     3. Prefix Seek を行う
        1. Interest の prefix が\\alert{すべて}存在するかを NPHT でチェックする
        2. 存在しなければ， NPHT に新たなエントリを作成
        3. 2 の時， fast lookup のため prefix は親へのポインタを張る

#+ATTR_LaTeX: :width 0.8\\linewidth :height 0.15\\paperheight
[[./npht.pdf]]

** Interest 処理のオペレーショナルフロー (2)
   1. Interest に対応する Data がキャッシュされているか CS をチェック
      1. CSL で潜在的にマッチし得るコンテンツを探索
      2. マッチした場合，そのコンテンツを CS から取ってきて，本当に
         Interest を満たすものかどうかチェック
         - Interest には，特定コンテンツを排除する除外フィルタなどがあ
           るため name だけでは不十分であるため
** Interest 処理のオペレーショナルフロー (3)
   1. コンテンツ有: Interest を消費した (Interest Comsuming の処理) 後， Data パケットを返送し， NPHT
      と PHT から Interest の name を除去
      - Data が/a/b/0/1 なら，\\alert{/a/b/0 ・/a/b ・/a をすべて}探索
        する
        - できるだけ多くの Interest を消費するため
        - 例えば， Interest /a/b/0 が，最初の 3 コンポネントでのみのマッチを
            必要としている場合，コンテンツ/a/b/0/1 が Interest/a/b/0 を満たす

   2. コンテンツ無: NPHT で最長一致検索を行う (FIB の処理)
      1. Interest の fullname で探索→ 1 つコンポネント長を短くしたもの
        で探索．．．．．．をマッチするか， root prefix に到達するまで繰り返す
      2. Interest を転送した後， NPHT に Interest message を含んだエントリ
         を追加， PHT に Interest の nonce を追加

** Data 処理のオペレーショナルフロー図
[[./ccnx_data_flow.pdf]]

** Data 処理のオペレーショナルフロー
   - Interest が CCNx daemon に到着した時の処理を順に述べる
     1. CCNx daemon は，バイナリをデコードし， parse
     2. CS seek, saving
        - CHT での正確なマッチングを行い，キャシュされているかを確認
          (key は Data の full name)
        - Data は， CHT と CSL に挿入され， CS に格納される
     3. Interest の処理と同様の Interest Consuming の処理
" 0 1 (fontified t face org-level-2) 1 3 (fontified t face org-level-2) 3 15 (fontified t face org-level-2) 15 140 (fontified t) 140 142 (fontified t face org-level-3) 142 144 (fontified t face org-level-3) 144 150 (fontified t face org-level-3) 150 214 (fontified t) 214 216 (fontified t face org-level-3) 216 218 (fontified t face org-level-3) 218 224 (fontified t face org-level-3) 224 285 (fontified t) 285 286 (fontified t face org-level-2) 286 288 (fontified t face org-level-2) 288 343 (fontified t face org-level-2) 343 344 (fontified t) 344 519 (fontified t) 519 520 (fontified t face org-level-2) 520 522 (fontified t face org-level-2) 522 533 (fontified t face org-level-2) 533 864 (fontified t) 864 865 (fontified t) 865 866 (fontified t face org-level-2) 866 868 (fontified t face org-level-2) 868 880 (fontified t face org-level-2) 880 884 (fontified t) 884 885 (fontified t org-no-flyspell t invisible org-link keymap #3=(keymap (follow-link . mouse-face) (mouse-3 . org-find-file-at-mouse) (mouse-2 . org-open-at-mouse)) mouse-face highlight font-lock-multiline t help-echo #2="LINK: ./ccnx_data_structure.pdf" htmlize-link #4=(:uri #1="./ccnx_data_structure.pdf") face org-link) 885 886 (fontified t org-no-flyspell t invisible org-link keymap #3# mouse-face highlight font-lock-multiline t help-echo #2# htmlize-link #4# rear-nonsticky #5=(mouse-face highlight keymap invisible intangible help-echo org-linked-text htmlize-link) face org-link) 886 910 (fontified t org-no-flyspell t keymap #3# mouse-face highlight font-lock-multiline t help-echo #2# htmlize-link #6=(:uri #1#) face org-link) 910 911 (fontified t org-no-flyspell t keymap #3# mouse-face highlight font-lock-multiline t help-echo #2# htmlize-link #6# rear-nonsticky #5# face org-link) 911 912 (fontified t org-no-flyspell t invisible org-link keymap #3# mouse-face highlight font-lock-multiline t help-echo #2# htmlize-link #4# face org-link) 912 913 (fontified t org-no-flyspell t invisible org-link keymap #3# mouse-face highlight font-lock-multiline t help-echo #2# htmlize-link #4# rear-nonsticky #5# face org-link) 913 915 (fontified t) 915 916 (fontified t face org-level-2) 916 918 (fontified t face org-level-2) 918 934 (fontified t face org-level-2) 934 1145 (fontified t) 1145 1146 (fontified t face org-level-2) 1146 1148 (fontified t face org-level-2) 1148 1164 (fontified t face org-level-2) 1164 1394 (fontified t) 1394 1701 (fontified nil) 1701 1702 (fontified t) 1702 1703 (fontified t face org-level-2) 1703 1705 (fontified t face org-level-2) 1705 1724 (fontified t face org-level-2) 1724 1868 (fontified t) 1868 1869 (fontified t face org-level-2) 1869 1871 (fontified t face org-level-2) 1871 1894 (fontified t face org-level-2) 1894 2056 (fontified t) 2056 2057 (fontified t face org-level-2) 2057 2059 (fontified t face org-level-2) 2059 2076 (fontified t face org-level-2) 2076 2122 (fontified t) 2122 2123 (fontified t face org-level-2) 2123 2125 (fontified t face org-level-2) 2125 2149 (fontified t face org-level-2) 2149 2150 (fontified t) 2150 2151 (fontified t org-no-flyspell t invisible org-link keymap #3# mouse-face highlight font-lock-multiline t help-echo #8="LINK: ./ccnx_interest_flow.pdf" htmlize-link #9=(:uri #7="./ccnx_interest_flow.pdf") face org-link) 2151 2152 (fontified t org-no-flyspell t invisible org-link keymap #3# mouse-face highlight font-lock-multiline t help-echo #8# htmlize-link #9# rear-nonsticky #5# face org-link) 2152 2175 (fontified t org-no-flyspell t keymap #3# mouse-face highlight font-lock-multiline t help-echo #8# htmlize-link #10=(:uri #7#) face org-link) 2175 2176 (fontified t org-no-flyspell t keymap #3# mouse-face highlight font-lock-multiline t help-echo #8# htmlize-link #10# rear-nonsticky #5# face org-link) 2176 2177 (fontified t org-no-flyspell t invisible org-link keymap #3# mouse-face highlight font-lock-multiline t help-echo #8# htmlize-link #9# face org-link) 2177 2178 (fontified t org-no-flyspell t invisible org-link keymap #3# mouse-face highlight font-lock-multiline t help-echo #8# htmlize-link #9# rear-nonsticky #5# face org-link) 2178 2180 (fontified t) 2180 2181 (fontified t face org-level-2) 2181 2183 (fontified t face org-level-2) 2183 2210 (fontified t face org-level-2) 2210 2211 (fontified t) 2211 2653 (fontified nil) 2653 2654 (fontified t) 2654 2655 (fontified t face org-level-2) 2655 2657 (fontified t face org-level-2) 2657 2684 (fontified t face org-level-2) 2684 2919 (fontified t) 2919 2920 (fontified t face org-level-2) 2920 2922 (fontified t face org-level-2) 2922 2949 (fontified t face org-level-2) 2949 3167 (fontified t) 3167 3522 (fontified nil) 3522 3523 (fontified t) 3523 3524 (fontified t face org-level-2) 3524 3526 (fontified t face org-level-2) 3526 3546 (fontified t face org-level-2) 3546 3547 (fontified t) 3547 3548 (fontified t org-no-flyspell t invisible org-link keymap #3# mouse-face highlight font-lock-multiline t help-echo #12="LINK: ./ccnx_data_flow.pdf" htmlize-link #13=(:uri #11="./ccnx_data_flow.pdf") face org-link) 3548 3549 (fontified t org-no-flyspell t invisible org-link keymap #3# mouse-face highlight font-lock-multiline t help-echo #12# htmlize-link #13# rear-nonsticky #5# face org-link) 3549 3568 (fontified t org-no-flyspell t keymap #3# mouse-face highlight font-lock-multiline t help-echo #12# htmlize-link #14=(:uri #11#) face org-link) 3568 3569 (fontified t org-no-flyspell t keymap #3# mouse-face highlight font-lock-multiline t help-echo #12# htmlize-link #14# rear-nonsticky #5# face org-link) 3569 3570 (fontified t org-no-flyspell t invisible org-link keymap #3# mouse-face highlight font-lock-multiline t help-echo #12# htmlize-link #13# face org-link) 3570 3571 (fontified t org-no-flyspell t invisible org-link keymap #3# mouse-face highlight font-lock-multiline t help-echo #12# htmlize-link #13# rear-nonsticky #5# face org-link) 3571 3573 (fontified t) 3573 3574 (fontified t face org-level-2) 3574 3576 (fontified t face org-level-2) 3576 3595 (fontified t face org-level-2) 3595 3874 (fontified t)) #("* 2014 年 3 月 5 日" 0 2 (fontified t face org-level-1) 2 16 (fontified t face org-level-1)) "% Created 2014-03-05 Wed 09:30
\\documentclass[dvipdfmx,12pt]{beamer}
\\usepackage{url}
\\usepackage{pxjahyper}
\\usetheme{Berlin}
\\setbeamertemplate{navigation symbols}{}
\\beamertemplatetextbibitems
\\setbeamertemplate{footline}[frame number]
\\setbeamertemplate{headline}{}


\\institute[]{大阪大学大学院情報科学研究科\\\\
            情報ネットワーク学専攻\\\\
            情報流通プラットフォーム講座 長谷川研究室 M1}
\\usetheme{default}
\\author{大杉 海斗}
\\date{\\today}
\\title{M1 Meeting}
\\hypersetup{
  pdfkeywords={},
  pdfsubject={},
  pdfcreator={Emacs 24.3.1 (Org mode 8.2.5h)}}
\\begin{document}

\\maketitle

\\section{2014 年 3 月 5 日}
\\label{sec-1}
\\begin{frame}[label=sec-1-1]{前回ミーティングのまとめ}
\\begin{itemize}
\\item 「 Scalable NDN Forwarding:Concepts, Issues and Principles 」を読
み， CCNx のデータ構造についてまとめ， CCNx のデータ構造について
の理解を深める
\\end{itemize}
\\begin{block}{短期的な目標}%x
\\begin{itemize}
\\item CCNx の ver8.1 で機能ごとのブロックを作り，ブロックの処理に必要な
クロック数を測定する
\\end{itemize}
\\end{block}

\\begin{block}{長期的な目標}%x
\\begin{itemize}
\\item 現在はルータの CPU がシングルコアの時のみモデル化できているため，
マルチコアに対応させる
\\end{itemize}
\\end{block}
\\end{frame}

\\begin{frame}[label=sec-1-2]{Scalable NDN Forwarding:Concepts, Issues and Principles}
\\begin{itemize}
\\item 本論文は， CCNx のデータ構造とオペレーショナルフローについてまとめている
\\item ただし， CCNx の ver4.0 を対象としているため，現在の最新である
ver8.1 とは一部異なる可能性がある
\\begin{itemize}
\\item 次スライドから述べる CCNx のデータ構造は ver4.0 のものであること
に留意する
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-3]{CCNx のデータ構造}
\\begin{itemize}
\\item CCNx のデータ構造は NDN と異なっている
\\begin{itemize}
\\item NDN
\\begin{itemize}
\\item CS ・ FIB ・ PIT の 3 つのテーブルを持つ
\\end{itemize}
\\item CCNx
\\begin{itemize}
\\item CS に相当する Content Hash Table (CHT) と Content Skip List
(CSL) を持つ
\\item FIB と PIT に相当する Name Prefix Hash Table (NPHT) を持つ
\\item PIT に存在するすべての Interest (PEs の形) の nonce を保持す
る Propagating Hash Table (PHT) を持つ
\\end{itemize}
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-1-4]{CCNx のデータ構造図}
\\includegraphics[width=.9\\linewidth]{./ccnx_data_structure.pdf}
\\end{frame}
\\begin{frame}[label=sec-1-5]{CCNx における CS の概要}
\\begin{itemize}
\\item Data の格納場所と， Data を指すポインタをエントリに持つテーブルに分けられる
\\begin{itemize}
\\item Data の格納場所
\\begin{itemize}
\\item Content Array (CA)
\\item Straggler Hash Table (SHT)
\\end{itemize}
\\item テーブル
\\begin{itemize}
\\item Content Hash Table (CHT)
\\item Content Skip List (CSL)
\\end{itemize}
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-6]{CS における Data の格納}
\\begin{itemize}
\\item Data に番号をつけて， CA か SHT に保存する
\\begin{itemize}
\\item daemon に到着した Data には，ユニークな accession number が割り
当てられる
\\begin{itemize}
\\item accession number は， 1 ずつ増加する
\\end{itemize}
\\item キャッシュされた Data は， Content Array (CA) に保存さ
れ， accession number によってインデックスされる
\\item Data がキャッシュされるごとに CA がサポートする accession
number の範囲が移動する
\\begin{itemize}
\\item サポートするスロット数は固定であるため，スライディングウィン
ドウのようにサポートする場所が移動していく
\\end{itemize}
\\item 古くなり CA のサポートから外れたが，人気のある Data は， SHT に
保存される
\\begin{itemize}
\\item どうやって Data が人気か判断するのか， CA と同じように accession
number でアクセスするのか分からないため，ソースを読む必要があ
る
\\end{itemize}
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-1-7]{Content Store のテーブル}
\\begin{itemize}
\\item Content Hash Table (CHT)
\\begin{itemize}
\\item key は Data のフルネーム
\\end{itemize}
\\item Content Skip List (CSL)
\\begin{itemize}
\\item 標準的な skip list
\\item コンテンツ名順の lookup をサポートするために必要
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-1-8]{CCNx における FIB と PIT の概要}
\\begin{itemize}
\\item FIB と PIT はともに， Name Prefix Hash Table (NPHT) によって管理
される
\\begin{itemize}
\\item NPHT は Propagating Entries (PEs) と Forwarding Info Entries
(FIEs) にインデックスしている
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-9]{CCNx のオペレーショナルフロー}
\\begin{itemize}
\\item CCNx では， Interest と Data は，異なる関数で処理される
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-1-10]{Interest 処理のオペレーショナルフロー図}
\\includegraphics[width=.9\\linewidth]{./ccnx_interest_flow.pdf}
\\end{frame}
\\begin{frame}[label=sec-1-11]{Interest 処理のオペレーショナルフロー (1)}
\\begin{itemize}
\\item Interest が CCNx daemon に到着した時の処理を順に述べる
\\begin{enumerate}
\\item CCNx daemon は，バイナリをデコードし， name 部とオプション部に
parse
\\item Interest の nonce を key として， PHT で正確な一致検索を行う
\\begin{itemize}
\\item loop している Interest の破棄
\\end{itemize}
\\item Prefix Seek を行う
\\begin{enumerate}
\\item Interest の prefix が\\alert{すべて}存在するかを NPHT でチェックする
\\item 存在しなければ， NPHT に新たなエントリを作成
\\item 2 の時， fast lookup のため prefix は親へのポインタを張る
\\end{enumerate}
\\end{enumerate}
\\end{itemize}

\\includegraphics[width=0.8\\linewidth,height=0.15\\paperheight]{./npht.pdf}
\\end{frame}
\\begin{frame}[label=sec-1-12]{Interest 処理のオペレーショナルフロー (2)}
\\begin{enumerate}
\\item Interest に対応する Data がキャッシュされているか CS をチェック
\\begin{enumerate}
\\item CSL で潜在的にマッチし得るコンテンツを探索
\\item マッチした場合，そのコンテンツを CS から取ってきて，本当に
Interest を満たすものかどうかチェック
\\begin{itemize}
\\item Interest には，特定コンテンツを排除する除外フィルタなどがあ
るため name だけでは不十分であるため
\\end{itemize}
\\end{enumerate}
\\end{enumerate}
\\end{frame}

\\begin{frame}[label=sec-1-13]{Interest 処理のオペレーショナルフロー (3)}
\\begin{enumerate}
\\item コンテンツ有: Interest を消費した (Interest Comsuming の処理) 後， Data パケットを返送し， NPHT
と PHT から Interest の name を除去
\\begin{itemize}
\\item Data が/a/b/0/1 なら，\\alert{/a/b/0 ・/a/b ・/a をすべて}探索
する
\\begin{itemize}
\\item できるだけ多くの Interest を消費するため
\\item 例えば， Interest /a/b/0 が，最初の 3 コンポネントでのみのマッチを
必要としている場合，コンテンツ/a/b/0/1 が Interest/a/b/0 を満たす
\\end{itemize}
\\end{itemize}

\\item コンテンツ無: NPHT で最長一致検索を行う (FIB の処理)
\\begin{enumerate}
\\item Interest の fullname で探索→ 1 つコンポネント長を短くしたもの
で探索．．．．．．をマッチするか， root prefix に到達するまで繰り返す
\\item Interest を転送した後， NPHT に Interest message を含んだエントリ
を追加， PHT に Interest の nonce を追加
\\end{enumerate}
\\end{enumerate}
\\end{frame}
\\begin{frame}[label=sec-1-14]{Data 処理のオペレーショナルフロー図}
\\includegraphics[width=.9\\linewidth]{./ccnx_data_flow.pdf}
\\end{frame}
\\begin{frame}[label=sec-1-15]{Data 処理のオペレーショナルフロー}
\\begin{itemize}
\\item Interest が CCNx daemon に到着した時の処理を順に述べる
\\begin{enumerate}
\\item CCNx daemon は，バイナリをデコードし， parse
\\item CS seek, saving
\\begin{itemize}
\\item CHT での正確なマッチングを行い，キャシュされているかを確認
(key は Data の full name)
\\item Data は， CHT と CSL に挿入され， CS に格納される
\\end{itemize}
\\item Interest の処理と同様の Interest Consuming の処理
\\end{enumerate}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-16]{所感}
\\begin{itemize}
\\item CCNx のデータ構造について大まかな理解はできたと思われる
\\item 一方で，各テーブルのエントリの構造などの細かい所については触れられ
ていなかったため，ソースコードを読んでいく必要があると感じた
\\end{itemize}
\\end{frame}
% Emacs 24.3.1 (Org mode 8.2.5h)
\\end{document}" #("Interest Comsuming の処理" 0 17 (fontified t) 17 18 (fontified t) 18 19 (fontified t) 19 20 (fontified t) 20 21 (fontified t) 21 22 (fontified t)) "% Created 2014-03-05 Wed 09:28
\\documentclass[dvipdfmx,12pt]{beamer}
\\usepackage{url}
\\usepackage{pxjahyper}
\\usetheme{Berlin}
\\setbeamertemplate{navigation symbols}{}
\\beamertemplatetextbibitems
\\setbeamertemplate{footline}[frame number]
\\setbeamertemplate{headline}{}


\\institute[]{大阪大学大学院情報科学研究科\\\\
            情報ネットワーク学専攻\\\\
            情報流通プラットフォーム講座 長谷川研究室 M1}
\\usetheme{default}
\\author{大杉 海斗}
\\date{\\today}
\\title{M1 Meeting}
\\hypersetup{
  pdfkeywords={},
  pdfsubject={},
  pdfcreator={Emacs 24.3.1 (Org mode 8.2.5h)}}
\\begin{document}

\\maketitle

\\section{2014 年 3 月 5 日}
\\label{sec-1}
\\begin{frame}[label=sec-1-1]{前回ミーティングのまとめ}
\\begin{itemize}
\\item 「 Scalable NDN Forwarding:Concepts, Issues and Principles 」を読
み， CCNx のデータ構造についてまとめ， CCNx のデータ構造について
の理解を深める
\\end{itemize}
\\begin{block}{短期的な目標}%x
\\begin{itemize}
\\item CCNx の ver8.1 で機能ごとのブロックを作り，ブロックの処理に必要な
クロック数を測定する
\\end{itemize}
\\end{block}

\\begin{block}{長期的な目標}%x
\\begin{itemize}
\\item 現在はルータの CPU がシングルコアの時のみモデル化できているため，
マルチコアに対応させる
\\end{itemize}
\\end{block}
\\end{frame}

\\begin{frame}[label=sec-1-2]{Scalable NDN Forwarding:Concepts, Issues and Principles}
\\begin{itemize}
\\item 本論文は， CCNx のデータ構造とオペレーショナルフローについてまとめている
\\item ただし， CCNx の ver4.0 を対象としているため，現在の最新である
ver8.1 とは一部異なる可能性がある
\\begin{itemize}
\\item 次スライドから述べる CCNx のデータ構造は ver4.0 のものであること
に留意する
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-3]{CCNx のデータ構造}
\\begin{itemize}
\\item CCNx のデータ構造は NDN と異なっている
\\begin{itemize}
\\item NDN
\\begin{itemize}
\\item CS ・ FIB ・ PIT の 3 つのテーブルを持つ
\\end{itemize}
\\item CCNx
\\begin{itemize}
\\item CS に相当する Content Hash Table (CHT) と Content Skip List
(CSL) を持つ
\\item FIB と PIT に相当する Name Prefix Hash Table (NPHT) を持つ
\\item PIT に存在するすべての Interest (PEs の形) の nonce を保持す
る Propagating Hash Table (PHT) を持つ
\\end{itemize}
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-1-4]{CCNx のデータ構造図}
\\includegraphics[width=.9\\linewidth]{./ccnx_data_structure.pdf}
\\end{frame}
\\begin{frame}[label=sec-1-5]{CCNx における CS の概要}
\\begin{itemize}
\\item Data の格納場所と， Data を指すポインタをエントリに持つテーブルに分けられる
\\begin{itemize}
\\item Data の格納場所
\\begin{itemize}
\\item Content Array (CA)
\\item Straggler Hash Table (SHT)
\\end{itemize}
\\item テーブル
\\begin{itemize}
\\item Content Hash Table (CHT)
\\item Content Skip List (CSL)
\\end{itemize}
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-6]{CS における Data の格納}
\\begin{itemize}
\\item Data に番号をつけて， CA か SHT に保存する
\\begin{itemize}
\\item daemon に到着した Data には，ユニークな accession number が割り
当てられる
\\begin{itemize}
\\item accession number は， 1 ずつ増加する
\\end{itemize}
\\item キャッシュされた Data は， Content Array (CA) に保存さ
れ， accession number によってインデックスされる
\\item Data がキャッシュされるごとに CA がサポートする accession
number の範囲が移動する
\\begin{itemize}
\\item サポートするスロット数は固定であるため，スライディングウィン
ドウのようにサポートする場所が移動していく
\\end{itemize}
\\item 古くなり CA のサポートから外れたが，人気のある Data は， SHT に
保存される
\\begin{itemize}
\\item どうやって Data が人気か判断するのか， CA と同じように accession
number でアクセスするのか分からないため，ソースを読む必要があ
る
\\end{itemize}
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-1-7]{Content Store のテーブル}
\\begin{itemize}
\\item Content Hash Table (CHT)
\\begin{itemize}
\\item key は Data のフルネーム
\\end{itemize}
\\item Content Skip List (CSL)
\\begin{itemize}
\\item 標準的な skip list
\\item コンテンツ名順の lookup をサポートするために必要
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-1-8]{CCNx における FIB と PIT の概要}
\\begin{itemize}
\\item FIB と PIT はともに， Name Prefix Hash Table (NPHT) によって管理
される
\\begin{itemize}
\\item NPHT は Propagating Entries (PEs) と Forwarding Info Entries
(FIEs) にインデックスしている
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-9]{CCNx のオペレーショナルフロー}
\\begin{itemize}
\\item CCNx では， Interest と Data は，異なる関数で処理される
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-1-10]{Interest 処理のオペレーショナルフロー図}
\\includegraphics[width=.9\\linewidth]{./ccnx_interest_flow.pdf}
\\end{frame}
\\begin{frame}[label=sec-1-11]{Interest 処理のオペレーショナルフロー (1)}
\\begin{itemize}
\\item Interest が CCNx daemon に到着した時の処理を順に述べる
\\begin{enumerate}
\\item CCNx daemon は，バイナリをデコードし， name 部とオプション部に
parse
\\item Interest の nonce を key として， PHT で正確な一致検索を行う
\\begin{itemize}
\\item loop している Interest の破棄
\\end{itemize}
\\item Prefix Seek を行う
\\begin{enumerate}
\\item Interest の prefix が\\alert{すべて}存在するかを NPHT でチェックする
\\item 存在しなければ， NPHT に新たなエントリを作成
\\item 2 の時， fast lookup のため prefix は親へのポインタを張る
\\end{enumerate}
\\end{enumerate}
\\end{itemize}

\\includegraphics[width=0.8\\linewidth,height=0.15\\paperheight]{./npht.pdf}
\\end{frame}
\\begin{frame}[label=sec-1-12]{Interest 処理のオペレーショナルフロー (2)}
\\begin{enumerate}
\\item Interest に対応する Data がキャッシュされているか CS をチェック
\\begin{enumerate}
\\item CSL で潜在的にマッチし得るコンテンツを探索
\\item マッチした場合，そのコンテンツを CS から取ってきて，本当に
Interest を満たすものかどうかチェック
\\begin{itemize}
\\item Interest には，特定コンテンツを排除する除外フィルタなどがあ
るため name だけでは不十分であるため
\\end{itemize}
\\end{enumerate}
\\end{enumerate}
\\end{frame}

\\begin{frame}[label=sec-1-13]{Interest 処理のオペレーショナルフロー (3)}
\\begin{enumerate}
\\item コンテンツ有: Interest Comsuming の処理 (Interest を消費した後， Data パケットを返送し， NPHT
と PHT から Interest の name を除去)
\\begin{itemize}
\\item Data が/a/b/0/1 なら，\\alert{/a/b/0 ・/a/b ・/a をすべて}探索
する
\\begin{itemize}
\\item できるだけ多くの Interest を消費するため
\\item 例えば， Interest /a/b/0 が，最初の 3 コンポネントでのみのマッチを
必要としている場合，コンテンツ/a/b/0/1 が Interest/a/b/0 を満たす
\\end{itemize}
\\end{itemize}

\\item コンテンツ無: NPHT で最長一致検索を行う (FIB の処理)
\\begin{enumerate}
\\item Interest の fullname で探索→ 1 つコンポネント長を短くしたもの
で探索．．．．．．をマッチするか， root prefix に到達するまで繰り返す
\\item Interest を転送した後， NPHT に Interest message を含んだエントリ
を追加， PHT に Interest の nonce を追加
\\end{enumerate}
\\end{enumerate}
\\end{frame}
\\begin{frame}[label=sec-1-14]{Data 処理のオペレーショナルフロー図}
\\includegraphics[width=.9\\linewidth]{./ccnx_data_flow.pdf}
\\end{frame}
\\begin{frame}[label=sec-1-15]{Data 処理のオペレーショナルフロー}
\\begin{itemize}
\\item Interest が CCNx daemon に到着した時の処理を順に述べる
\\begin{enumerate}
\\item CCNx daemon は，バイナリをデコードし， parse
\\item CS seek, saving
\\begin{itemize}
\\item CHT での正確なマッチングを行い，キャシュされているかを確認
(key は Data の full name)
\\item Data は， CHT と CSL に挿入され， CS に格納される
\\end{itemize}
\\item Interest の処理と同様の Interest Consuming の処理
\\end{enumerate}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-16]{所感}
\\begin{itemize}
\\item CCNx のデータ構造について大まかな理解はできたと思われる
\\item 一方で，各テーブルのエントリの構造などの細かい所については触れられ
ていなかったため，ソースコードを読んでいく必要があると感じた
\\end{itemize}
\\end{frame}
% Emacs 24.3.1 (Org mode 8.2.5h)
\\end{document}" "% Created 2014-03-05 Wed 09:26
\\documentclass[dvipdfmx,12pt]{beamer}
\\usepackage{url}
\\usepackage{pxjahyper}
\\usetheme{Berlin}
\\setbeamertemplate{navigation symbols}{}
\\beamertemplatetextbibitems
\\setbeamertemplate{footline}[frame number]
\\setbeamertemplate{headline}{}


\\institute[]{大阪大学大学院情報科学研究科\\\\
            情報ネットワーク学専攻\\\\
            情報流通プラットフォーム講座 長谷川研究室 M1}
\\usetheme{default}
\\author{大杉 海斗}
\\date{\\today}
\\title{M1 Meeting}
\\hypersetup{
  pdfkeywords={},
  pdfsubject={},
  pdfcreator={Emacs 24.3.1 (Org mode 8.2.5h)}}
\\begin{document}

\\maketitle

\\section{2014 年 3 月 5 日}
\\label{sec-1}
\\begin{frame}[label=sec-1-1]{前回ミーティングのまとめ}
\\begin{itemize}
\\item 「 Scalable NDN Forwarding:Concepts, Issues and Principles 」を読
み， CCNx のデータ構造についてまとめ， CCNx のデータ構造について
の理解を深める
\\end{itemize}
\\begin{block}{短期的な目標}%x
\\begin{itemize}
\\item CCNx の ver8.1 で機能ごとのブロックを作り，ブロックの処理に必要な
クロック数を測定する
\\end{itemize}
\\end{block}

\\begin{block}{長期的な目標}%x
\\begin{itemize}
\\item 現在はルータの CPU がシングルコアの時のみモデル化できているため，
マルチコアに対応させる
\\end{itemize}
\\end{block}
\\end{frame}

\\begin{frame}[label=sec-1-2]{Scalable NDN Forwarding:Concepts, Issues and Principles}
\\begin{itemize}
\\item 本論文は， CCNx のデータ構造とオペレーショナルフローについてまとめている
\\item ただし， CCNx の ver4.0 を対象としているため，現在の最新である
ver8.1 とは一部異なる可能性がある
\\begin{itemize}
\\item 次スライドから述べる CCNx のデータ構造は ver4.0 のものであること
に留意する
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-3]{CCNx のデータ構造}
\\begin{itemize}
\\item CCNx のデータ構造は NDN と異なっている
\\begin{itemize}
\\item NDN
\\begin{itemize}
\\item CS ・ FIB ・ PIT の 3 つのテーブルを持つ
\\end{itemize}
\\item CCNx
\\begin{itemize}
\\item CS に相当する Content Hash Table (CHT) と Content Skip List
(CSL) を持つ
\\item FIB と PIT に相当する Name Prefix Hash Table (NPHT) を持つ
\\item PIT に存在するすべての Interest (PEs の形) の nonce を保持す
る Propagating Hash Table (PHT) を持つ
\\end{itemize}
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-1-4]{CCNx のデータ構造図}
\\includegraphics[width=.9\\linewidth]{./ccnx_data_structure.pdf}
\\end{frame}
\\begin{frame}[label=sec-1-5]{CCNx における CS の概要}
\\begin{itemize}
\\item Data の格納場所と， Data を指すポインタをエントリに持つテーブルに分けられる
\\begin{itemize}
\\item Data の格納場所
\\begin{itemize}
\\item Content Array (CA)
\\item Straggler Hash Table (SHT)
\\end{itemize}
\\item テーブル
\\begin{itemize}
\\item Content Hash Table (CHT)
\\item Content Skip List (CSL)
\\end{itemize}
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-6]{CS における Data の格納}
\\begin{itemize}
\\item Data に番号をつけて， CA か SHT に保存する
\\begin{itemize}
\\item daemon に到着した Data には，ユニークな accession number が割り
当てられる
\\begin{itemize}
\\item accession number は， 1 ずつ増加する
\\end{itemize}
\\item キャッシュされた Data は， Content Array (CA) に保存さ
れ， accession number によってインデックスされる
\\item Data がキャッシュされるごとに CA がサポートする accession
number の範囲が移動する
\\begin{itemize}
\\item サポートするスロット数は固定であるため，スライディングウィン
ドウのようにサポートする場所が移動していく
\\end{itemize}
\\item 古くなり CA のサポートから外れたが，人気のある Data は， SHT に
保存される
\\begin{itemize}
\\item どうやって Data が人気か判断するのか， CA と同じように accession
number でアクセスするのか分からないため，ソースを読む必要があ
る
\\end{itemize}
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-1-7]{Content Store のテーブル}
\\begin{itemize}
\\item Content Hash Table (CHT)
\\begin{itemize}
\\item key は Data のフルネーム
\\end{itemize}
\\item Content Skip List (CSL)
\\begin{itemize}
\\item 標準的な skip list
\\item コンテンツ名順の lookup をサポートするために必要
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-1-8]{CCNx における FIB と PIT の概要}
\\begin{itemize}
\\item FIB と PIT はともに， Name Prefix Hash Table (NPHT) によって管理
される
\\begin{itemize}
\\item NPHT は Propagating Entries (PEs) と Forwarding Info Entries
(FIEs) にインデックスしている
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-9]{CCNx のオペレーショナルフロー}
\\begin{itemize}
\\item CCNx では， Interest と Data は，異なる関数で処理される
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-1-10]{Interest 処理のオペレーショナルフロー図}
\\includegraphics[width=.9\\linewidth]{./ccnx_interest_flow.pdf}
\\end{frame}
\\begin{frame}[label=sec-1-11]{Interest 処理のオペレーショナルフロー (1)}
\\begin{itemize}
\\item Interest が CCNx daemon に到着した時の処理を順に述べる
\\begin{enumerate}
\\item CCNx daemon は，バイナリをデコードし， name 部とオプション部に
parse
\\item Interest の nonce を key として， PHT で正確な一致検索を行う
\\begin{itemize}
\\item loop している Interest の破棄
\\end{itemize}
\\item Prefix Seek を行う
\\begin{enumerate}
\\item Interest の prefix が\\alert{すべて}存在するかを NPHT でチェックする
\\item 存在しなければ， NPHT に新たなエントリを作成
\\item 2 の時， fast lookup のため prefix は親へのポインタを張る
\\end{enumerate}
\\end{enumerate}
\\end{itemize}

\\includegraphics[width=0.8\\linewidth,height=0.15\\paperheight]{./npht.pdf}
\\end{frame}
\\begin{frame}[label=sec-1-12]{Interest 処理のオペレーショナルフロー (2)}
\\begin{enumerate}
\\item Interest に対応する Data がキャッシュされているか CS をチェック
\\begin{enumerate}
\\item CSL で潜在的にマッチし得るコンテンツを探索
\\item マッチした場合，そのコンテンツを CS から取ってきて，本当に
Interest を満たすものかどうかチェック
\\begin{itemize}
\\item Interest には，特定コンテンツを排除する除外フィルタなどがあ
るため name だけでは不十分であるため
\\end{itemize}
\\end{enumerate}
\\end{enumerate}
\\end{frame}

\\begin{frame}[label=sec-1-13]{Interest 処理のオペレーショナルフロー (3)}
\\begin{enumerate}
\\item コンテンツ有:Interest を消費した後， Data パケットを返送し， NPHT
と PHT から Interest の name を除去
\\begin{itemize}
\\item Data が/a/b/0/1 なら，\\alert{/a/b/0 ・/a/b ・/a をすべて}探索
する
\\begin{itemize}
\\item できるだけ多くの Interest を消費するため
\\item 例えば， Interest /a/b/0 が，最初の 3 コンポネントでのみのマッチを
必要としている場合，コンテンツ/a/b/0/1 が Interest/a/b/0 を満たす
\\end{itemize}
\\end{itemize}

\\item コンテンツ無: NPHT で最長一致検索を行う (FIB の処理)
\\begin{enumerate}
\\item Interest の fullname で探索→ 1 つコンポネント長を短くしたもの
で探索．．．．．．をマッチするか， root prefix に到達するまで繰り返す
\\item Interest を転送した後， NPHT に Interest message を含んだエントリ
を追加， PHT に Interest の nonce を追加
\\end{enumerate}
\\end{enumerate}
\\end{frame}
\\begin{frame}[label=sec-1-14]{Data 処理のオペレーショナルフロー図}
\\includegraphics[width=.9\\linewidth]{./ccnx_data_flow.pdf}
\\end{frame}
\\begin{frame}[label=sec-1-15]{Data 処理のオペレーショナルフロー}
\\begin{itemize}
\\item Interest が CCNx daemon に到着した時の処理を順に述べる
\\begin{enumerate}
\\item CCNx daemon は，バイナリをデコードし， parse
\\item CS seek, saving
\\begin{itemize}
\\item CHT での正確なマッチングを行い，キャシュされているかを確認
(key は Data の full name)
\\item Data は， CHT と CSL に挿入され， CS に格納される
\\end{itemize}
\\item Interest の処理と同様の Interest Consuming の処理
\\end{enumerate}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-16]{所感}
\\begin{itemize}
\\item CCNx のデータ構造について大まかな理解はできたと思われる
\\item 一方で，各テーブルのエントリの構造などの細かい所については触れられ
ていなかったため，ソースコードを読んでいく必要があると感じた
\\end{itemize}
\\end{frame}
% Emacs 24.3.1 (Org mode 8.2.5h)
\\end{document}" "% Created 2014-03-05 Wed 09:23
\\documentclass[dvipdfmx,12pt]{beamer}
\\usepackage{url}
\\usepackage{pxjahyper}
\\usetheme{Berlin}
\\setbeamertemplate{navigation symbols}{}
\\beamertemplatetextbibitems
\\setbeamertemplate{footline}[frame number]
\\setbeamertemplate{headline}{}


\\institute[]{大阪大学大学院情報科学研究科\\\\
            情報ネットワーク学専攻\\\\
            情報流通プラットフォーム講座 長谷川研究室 M1}
\\usetheme{default}
\\author{大杉 海斗}
\\date{\\today}
\\title{M1 Meeting}
\\hypersetup{
  pdfkeywords={},
  pdfsubject={},
  pdfcreator={Emacs 24.3.1 (Org mode 8.2.5h)}}
\\begin{document}

\\maketitle

\\section{2014 年 3 月 5 日}
\\label{sec-1}
\\begin{frame}[label=sec-1-1]{前回ミーティングのまとめ}
\\begin{itemize}
\\item 「 Scalable NDN Forwarding:Concepts, Issues and Principles 」を読
み， CCNx のデータ構造についてまとめ， CCNx のデータ構造について
の理解を深める
\\end{itemize}
\\begin{block}{短期的な目標}%x
\\begin{itemize}
\\item CCNx の ver8.1 で機能ごとのブロックを作り，ブロックの処理に必要な
クロック数を測定する
\\end{itemize}
\\end{block}

\\begin{block}{長期的な目標}%x
\\begin{itemize}
\\item 現在はルータの CPU がシングルコアの時のみモデル化できているため，
マルチコアに対応させる
\\end{itemize}
\\end{block}
\\end{frame}

\\begin{frame}[label=sec-1-2]{Scalable NDN Forwarding:Concepts, Issues and Principles}
\\begin{itemize}
\\item 本論文は， CCNx のデータ構造とオペレーショナルフローについてまとめている
\\item ただし， CCNx の ver4.0 を対象としているため，現在の最新である
ver8.1 とは一部異なる可能性がある
\\begin{itemize}
\\item 次スライドから述べる CCNx のデータ構造は ver4.0 のものであること
に留意する
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-3]{CCNx のデータ構造}
\\begin{itemize}
\\item CCNx のデータ構造は NDN と異なっている
\\begin{itemize}
\\item NDN
\\begin{itemize}
\\item CS ・ FIB ・ PIT の 3 つのテーブルを持つ
\\end{itemize}
\\item CCNx
\\begin{itemize}
\\item CS に相当する Content Hash Table (CHT) と Content Skip List
(CSL) を持つ
\\item FIB と PIT に相当する Name Prefix Hash Table (NPHT) を持つ
\\item PIT に存在するすべての Interest (PEs の形) の nonce を保持す
る Propagating Hash Table (PHT) を持つ
\\end{itemize}
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-1-4]{CCNx のデータ構造図}
\\includegraphics[width=.9\\linewidth]{./ccnx_data_structure.pdf}
\\end{frame}
\\begin{frame}[label=sec-1-5]{CCNx における CS の概要}
\\begin{itemize}
\\item Data の格納場所と， Data を指すポインタをエントリに持つテーブルに分けられる
\\begin{itemize}
\\item Data の格納場所
\\begin{itemize}
\\item Content Array (CA)
\\item Straggler Hash Table (SHT)
\\end{itemize}
\\item テーブル
\\begin{itemize}
\\item Content Hash Table (CHT)
\\item Content Skip List (CSL)
\\end{itemize}
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-6]{CS における Data の格納}
\\begin{itemize}
\\item Data に番号をつけて， CA か SHT に保存する
\\begin{itemize}
\\item daemon に到着した Data には，ユニークな accession number が割り
当てられる
\\begin{itemize}
\\item accession number は， 1 ずつ増加する
\\end{itemize}
\\item キャッシュされた Data は， Content Array (CA) に保存さ
れ， accession number によってインデックスされる
\\item Data がキャッシュされるごとに CA がサポートする accession
number の範囲が移動する
\\begin{itemize}
\\item サポートするスロット数は固定であるため，スライディングウィン
ドウのようにサポートする場所が移動していく
\\end{itemize}
\\item 古くなり CA のサポートから外れたが，人気のある Data は， SHT に
保存される
\\begin{itemize}
\\item どうやって Data が人気か判断するのか， CA と同じように accession
number でアクセスするのか分からないため，ソースを読む必要があ
る
\\end{itemize}
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-1-7]{Content Store のテーブル}
\\begin{itemize}
\\item Content Hash Table (CHT)
\\begin{itemize}
\\item key は Data のフルネーム
\\end{itemize}
\\item Content Skip List (CSL)
\\begin{itemize}
\\item 標準的な skip list
\\item コンテンツ名順の lookup をサポートするために必要
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-1-8]{CCNx における FIB と PIT の概要}
\\begin{itemize}
\\item FIB と PIT はともに， Name Prefix Hash Table (NPHT) によって管理
される
\\begin{itemize}
\\item NPHT は Propagating Entries (PEs) と Forwarding Info Entries
(FIEs) にインデックスしている
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-9]{CCNx のオペレーショナルフロー}
\\begin{itemize}
\\item CCNx では， Interest と Data は，異なる関数で処理される
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-1-10]{Interest 処理のオペレーショナルフロー図}
\\includegraphics[width=.9\\linewidth]{./ccnx_interest_flow.pdf}
\\end{frame}
\\begin{frame}[label=sec-1-11]{Interest 処理のオペレーショナルフロー (1)}
\\begin{itemize}
\\item Interest が CCNx daemon に到着した時の処理を順に述べる
\\begin{enumerate}
\\item CCNx daemon は，バイナリをデコードし， name 部とオプション部に
parse
\\item Interest の nonce を key として， PHT で正確な一致検索を行う
\\begin{itemize}
\\item loop している Interest の破棄
\\end{itemize}
\\item Prefix Seek を行う
\\begin{enumerate}
\\item Interest の prefix が\\alert{すべて}存在するかを NPHT でチェックする
\\item 存在しなければ， NPHT に新たなエントリを作成
\\item 2 の時， fast lookup のため prefix は親へのポインタを張る
\\end{enumerate}
\\end{enumerate}
\\end{itemize}

\\includegraphics[width=0.8\\linewidth,height=0.15\\paperheight]{./npht.pdf}
\\end{frame}
\\begin{frame}[label=sec-1-12]{Interest 処理のオペレーショナルフロー (2)}
\\begin{enumerate}
\\item Interest に対応する Data がキャッシュされているか CS をチェック
\\begin{enumerate}
\\item CSL で潜在的にマッチし得るコンテンツを探索
\\item マッチした場合，そのコンテンツを CS から取ってきて，本当に
Interest を満たすものかどうかチェック
\\begin{itemize}
\\item Interest には，特定コンテンツを排除する除外フィルタなどがあ
るため name だけでは不十分であるため
\\end{itemize}
\\end{enumerate}
\\end{enumerate}
\\end{frame}

\\begin{frame}[label=sec-1-13]{Interest 処理のオペレーショナルフロー (3)}
\\begin{enumerate}
\\item コンテンツ有:Interest を消費した後， Data パケットを返送し， NPHT
と PHT から Interest の name を除去
\\begin{itemize}
\\item Data が/a/b/0/1 なら，\\alert{/a/b/0 ・/a/b ・/a をすべて}探索
する
\\begin{itemize}
\\item できるだけ多くの Interest を消費するため
\\item 例えば， Interest /a/b/0 が，最初の 3 コンポネントでのみのマッチを
必要としている場合，コンテンツ/a/b/0/1 が Interest/a/b/0 を満たす
\\end{itemize}
\\end{itemize}

\\item コンテンツ無: NPHT で最長一致検索を行う
\\begin{enumerate}
\\item Interest の fullname で探索→ 1 つコンポネント長を短くしたもの
で探索．．．．．．をマッチするか， root prefix に到達するまで繰り返す
\\item Interest を転送した後， NPHT に Interest message を含んだエントリ
を追加， PHT に Interest の nonce を追加
\\end{enumerate}
\\end{enumerate}
\\end{frame}
\\begin{frame}[label=sec-1-14]{Data 処理のオペレーショナルフロー図}
\\includegraphics[width=.9\\linewidth]{./ccnx_data_flow.pdf}
\\end{frame}
\\begin{frame}[label=sec-1-15]{Data 処理のオペレーショナルフロー}
\\begin{itemize}
\\item Interest が CCNx daemon に到着した時の処理を順に述べる
\\begin{enumerate}
\\item CCNx daemon は，バイナリをデコードし， parse
\\item CS seek, saving
\\begin{itemize}
\\item CHT での正確なマッチングを行い，キャシュされているかを確認
(key は Data の full name)
\\item Data は， CHT と CSL に挿入され， CS に格納される
\\end{itemize}
\\item Interest の処理と同様の Interest Consuming の処理
\\end{enumerate}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-16]{所感}
\\begin{itemize}
\\item CCNx のデータ構造について大まかな理解はできたと思われる
\\item 一方で，各テーブルのエントリの構造などの細かい所については触れられ
ていなかったため，ソースコードを読んでいく必要があると感じた
\\end{itemize}
\\end{frame}
% Emacs 24.3.1 (Org mode 8.2.5h)
\\end{document}" #("オペレーショナルフロー" 0 11 (fontified t)) "% Created 2014-03-05 Wed 09:22
\\documentclass[dvipdfmx,12pt]{beamer}
\\usepackage{url}
\\usepackage{pxjahyper}
\\usetheme{Berlin}
\\setbeamertemplate{navigation symbols}{}
\\beamertemplatetextbibitems
\\setbeamertemplate{footline}[frame number]
\\setbeamertemplate{headline}{}


\\institute[]{大阪大学大学院情報科学研究科\\\\
            情報ネットワーク学専攻\\\\
            情報流通プラットフォーム講座 長谷川研究室 M1}
\\usetheme{default}
\\author{大杉 海斗}
\\date{\\today}
\\title{M1 Meeting}
\\hypersetup{
  pdfkeywords={},
  pdfsubject={},
  pdfcreator={Emacs 24.3.1 (Org mode 8.2.5h)}}
\\begin{document}

\\maketitle

\\section{2014 年 3 月 5 日}
\\label{sec-1}
\\begin{frame}[label=sec-1-1]{前回ミーティングのまとめ}
\\begin{itemize}
\\item 「 Scalable NDN Forwarding:Concepts, Issues and Principles 」を読
み， CCNx のデータ構造についてまとめ， CCNx のデータ構造について
の理解を深める
\\end{itemize}
\\begin{block}{短期的な目標}%x
\\begin{itemize}
\\item CCNx の ver8.1 で機能ごとのブロックを作り，ブロックの処理に必要な
クロック数を測定する
\\end{itemize}
\\end{block}

\\begin{block}{長期的な目標}%x
\\begin{itemize}
\\item 現在はルータの CPU がシングルコアの時のみモデル化できているため，
マルチコアに対応させる
\\end{itemize}
\\end{block}
\\end{frame}

\\begin{frame}[label=sec-1-2]{Scalable NDN Forwarding:Concepts, Issues and Principles}
\\begin{itemize}
\\item 本論文は， CCNx のオペレーショナルフローとデータ構造についてまとめている
\\item ただし， CCNx の ver4.0 を対象としているため，現在の最新である
ver8.1 とは一部異なる可能性がある
\\begin{itemize}
\\item 次スライドから述べる CCNx のデータ構造は ver4.0 のものであること
に留意する
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-3]{CCNx のデータ構造}
\\begin{itemize}
\\item CCNx のデータ構造は NDN と異なっている
\\begin{itemize}
\\item NDN
\\begin{itemize}
\\item CS ・ FIB ・ PIT の 3 つのテーブルを持つ
\\end{itemize}
\\item CCNx
\\begin{itemize}
\\item CS に相当する Content Hash Table (CHT) と Content Skip List
(CSL) を持つ
\\item FIB と PIT に相当する Name Prefix Hash Table (NPHT) を持つ
\\item PIT に存在するすべての Interest (PEs の形) の nonce を保持す
る Propagating Hash Table (PHT) を持つ
\\end{itemize}
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-1-4]{CCNx のデータ構造図}
\\includegraphics[width=.9\\linewidth]{./ccnx_data_structure.pdf}
\\end{frame}
\\begin{frame}[label=sec-1-5]{CCNx における CS の概要}
\\begin{itemize}
\\item Data の格納場所と， Data を指すポインタをエントリに持つテーブルに分けられる
\\begin{itemize}
\\item Data の格納場所
\\begin{itemize}
\\item Content Array (CA)
\\item Straggler Hash Table (SHT)
\\end{itemize}
\\item テーブル
\\begin{itemize}
\\item Content Hash Table (CHT)
\\item Content Skip List (CSL)
\\end{itemize}
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-6]{CS における Data の格納}
\\begin{itemize}
\\item Data に番号をつけて， CA か SHT に保存する
\\begin{itemize}
\\item daemon に到着した Data には，ユニークな accession number が割り
当てられる
\\begin{itemize}
\\item accession number は， 1 ずつ増加する
\\end{itemize}
\\item キャッシュされた Data は， Content Array (CA) に保存さ
れ， accession number によってインデックスされる
\\item Data がキャッシュされるごとに CA がサポートする accession
number の範囲が移動する
\\begin{itemize}
\\item サポートするスロット数は固定であるため，スライディングウィン
ドウのようにサポートする場所が移動していく
\\end{itemize}
\\item 古くなり CA のサポートから外れたが，人気のある Data は， SHT に
保存される
\\begin{itemize}
\\item どうやって Data が人気か判断するのか， CA と同じように accession
number でアクセスするのか分からないため，ソースを読む必要があ
る
\\end{itemize}
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-1-7]{Content Store のテーブル}
\\begin{itemize}
\\item Content Hash Table (CHT)
\\begin{itemize}
\\item key は Data のフルネーム
\\end{itemize}
\\item Content Skip List (CSL)
\\begin{itemize}
\\item 標準的な skip list
\\item コンテンツ名順の lookup をサポートするために必要
\\end{itemize}
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-1-8]{CCNx における FIB と PIT の概要}
\\begin{itemize}
\\item FIB と PIT はともに， Name Prefix Hash Table (NPHT) によって管理
される
\\begin{itemize}
\\item NPHT は Propagating Entries (PEs) と Forwarding Info Entries
(FIEs) にインデックスしている
\\end{itemize}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-9]{CCNx のオペレーショナルフロー}
\\begin{itemize}
\\item CCNx では， Interest と Data は，異なる関数で処理される
\\end{itemize}
\\end{frame}
\\begin{frame}[label=sec-1-10]{Interest 処理のオペレーショナルフロー図}
\\includegraphics[width=.9\\linewidth]{./ccnx_interest_flow.pdf}
\\end{frame}
\\begin{frame}[label=sec-1-11]{Interest 処理のオペレーショナルフロー (1)}
\\begin{itemize}
\\item Interest が CCNx daemon に到着した時の処理を順に述べる
\\begin{enumerate}
\\item CCNx daemon は，バイナリをデコードし， name 部とオプション部に
parse
\\item Interest の nonce を key として， PHT で正確な一致検索を行う
\\begin{itemize}
\\item loop している Interest の破棄
\\end{itemize}
\\item Prefix Seek を行う
\\begin{enumerate}
\\item Interest の prefix が\\alert{すべて}存在するかを NPHT でチェックする
\\item 存在しなければ， NPHT に新たなエントリを作成
\\item 2 の時， fast lookup のため prefix は親へのポインタを張る
\\end{enumerate}
\\end{enumerate}
\\end{itemize}

\\includegraphics[width=0.8\\linewidth,height=0.15\\paperheight]{./npht.pdf}
\\end{frame}
\\begin{frame}[label=sec-1-12]{Interest 処理のオペレーショナルフロー (2)}
\\begin{enumerate}
\\item Interest に対応する Data がキャッシュされているか CS をチェック
\\begin{enumerate}
\\item CSL で潜在的にマッチし得るコンテンツを探索
\\item マッチした場合，そのコンテンツを CS から取ってきて，本当に
Interest を満たすものかどうかチェック
\\begin{itemize}
\\item Interest には，特定コンテンツを排除する除外フィルタなどがあ
るため name だけでは不十分であるため
\\end{itemize}
\\end{enumerate}
\\end{enumerate}
\\end{frame}

\\begin{frame}[label=sec-1-13]{Interest 処理のオペレーショナルフロー (3)}
\\begin{enumerate}
\\item コンテンツ有:Interest を消費した後， Data パケットを返送し， NPHT
と PHT から Interest の name を除去
\\begin{itemize}
\\item Data が/a/b/0/1 なら，\\alert{/a/b/0 ・/a/b ・/a をすべて}探索
する
\\begin{itemize}
\\item できるだけ多くの Interest を消費するため
\\item 例えば， Interest /a/b/0 が，最初の 3 コンポネントでのみのマッチを
必要としている場合，コンテンツ/a/b/0/1 が Interest/a/b/0 を満たす
\\end{itemize}
\\end{itemize}

\\item コンテンツ無: NPHT で最長一致検索を行う
\\begin{enumerate}
\\item Interest の fullname で探索→ 1 つコンポネント長を短くしたもの
で探索．．．．．．をマッチするか， root prefix に到達するまで繰り返す
\\item Interest を転送した後， NPHT に Interest message を含んだエントリ
を追加， PHT に Interest の nonce を追加
\\end{enumerate}
\\end{enumerate}
\\end{frame}
\\begin{frame}[label=sec-1-14]{Data 処理のオペレーショナルフロー図}
\\includegraphics[width=.9\\linewidth]{./ccnx_data_flow.pdf}
\\end{frame}
\\begin{frame}[label=sec-1-15]{Data 処理のオペレーショナルフロー}
\\begin{itemize}
\\item Interest が CCNx daemon に到着した時の処理を順に述べる
\\begin{enumerate}
\\item CCNx daemon は，バイナリをデコードし， parse
\\item CS seek, saving
\\begin{itemize}
\\item CHT での正確なマッチングを行い，キャシュされているかを確認
(key は Data の full name)
\\item Data は， CHT と CSL に挿入され， CS に格納される
\\end{itemize}
\\item Interest の処理と同様の Interest Consuming の処理
\\end{enumerate}
\\end{itemize}
\\end{frame}

\\begin{frame}[label=sec-1-16]{所感}
\\begin{itemize}
\\item CCNx のデータ構造について大まかな理解はできたと思われる
\\item 一方で，各テーブルのエントリの構造などの細かい所については触れられ
ていなかったため，ソースコードを読んでいく必要があると感じた
\\end{itemize}
\\end{frame}
% Emacs 24.3.1 (Org mode 8.2.5h)
\\end{document}"))
(setq-default session-file-alist '(("/mnt/Dropbox/meeting/withHasegawa/GreenICN/ohsugi-M1-meeting.org" 394 172 1 nil nil 308 (overwrite-mode)) ("/mnt/Dropbox/job_hunting/HITACHI/es.org" 1 nil 1 nil nil nil (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/url/cookies" 505 nil 1 nil nil nil (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/var/recentf" 8905 nil 1 nil nil nil (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/helm-20140306.2141/helm-autoloads.el" 45352 nil 1 nil nil 45352 (overwrite-mode)) ("~/hoge/achievement_20140307.html" 2376 nil 1 nil nil nil (overwrite-mode)) ("/mnt/Dropbox/meeting/withHasegawa/GreenICN/ohsugi-M1-meeting.tex" 11820 nil 1 nil nil nil (overwrite-mode)) ("/mnt/Dropbox/meeting/withHasegawa/140305/140305-M1meeting.org" 1 3151 1 nil nil 3232 (overwrite-mode)) ("/mnt/Dropbox/meeting/withHasegawa/140305/140305-M1meeting.tex" 6306 nil 1 nil nil nil (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/helm-20140303.2232/helm-autoloads.el" 45351 nil 1 nil nil 45351 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/snippets/org-mode/figure" 50 nil 1 nil nil 114 (overwrite-mode)) ("/mnt/Dropbox/old/old_presentation/graduation_thesis/abstract.tex" 1 nil 1 nil nil nil (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/concurrent-20140303.1635/concurrent-autoloads.el" 192 nil 1 nil nil 192 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/dash-20140303.1404/dash-autoloads.el" 174 nil 1 nil nil 174 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/deferred-20140303.1634/deferred-autoloads.el" 186 nil 1 nil nil 186 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/helm-20140303.755/helm-autoloads.el" 45353 nil 1 nil nil 45353 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/yasnippet-20140303.53/yasnippet-autoloads.el" 1493 nil 1 nil nil 1493 (overwrite-mode)) ("~/Dropbox/configure/.emacs.d/url/cookies" 511 nil 1 nil nil nil (overwrite-mode)) ("~/Dropbox/configure/.emacs.d/var/recentf" 13717 nil 1 nil nil nil (overwrite-mode)) ("~/Dropbox/configure/.emacs.d/elpa/ctable-20140301.1809/ctable-autoloads.el" 180 nil 1 nil nil 180 (overwrite-mode)) ("~/Dropbox/configure/.emacs.d/elpa/epc-20140301.1811/epc-autoloads.el" 181 nil 1 nil nil 181 (overwrite-mode)) ("~/Dropbox/configure/.emacs.d/elpa/helm-20140301.210/helm-autoloads.el" 45351 nil 1 nil nil 45351 (overwrite-mode)) ("~/Dropbox/etc/book_list/book_list.org" 724 1159 1 nil nil 724 (overwrite-mode)) ("~/Dropbox/configure/.emacs.d/snippets/org-mode/report" 50 nil 1 nil nil 68 (overwrite-mode)) ("~/Dropbox/configure/.emacs.d/elpa/auctex-11.87.3/auctex-autoloads.el" 10919 nil 1 nil nil 10919 (overwrite-mode)) ("~/Dropbox/configure/.emacs.d/elpa/yasnippet-20140227.703/yasnippet-autoloads.el" 1494 nil 1 nil nil 1494 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/cl-lib-0.5/cl-lib-autoloads.el" 407 nil 1 nil nil 407 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/helm-20140226.129/helm-autoloads.el" 45032 nil 1 nil nil 45032 (overwrite-mode)) ("/mnt/Dropbox/configure/.emacs.d/elpa/yasnippet-20140223.1202/yasnippet-autoloads.el" 1491 nil 1 nil nil 1491 (overwrite-mode)) ("~/Dropbox/job_hunting/NRI/es.org" 762 108 1 nil nil 648 (overwrite-mode)) ("~/Dropbox/job_hunting/HITACHI/es.org" 1866 1866 1 nil nil 1866 (overwrite-mode)) ("~/Dropbox/job_hunting/NTTDATA/es.org" 1390 1095 1 nil nil nil (overwrite-mode)) ("~/Dropbox/configure/.emacs.d/elpa/helm-20140225.1146/helm-autoloads.el" 45062 nil 1 nil nil 45062 (overwrite-mode)) ("~/Dropbox/configure/.emacs.d/elpa/org-20140224/org-loaddefs.el" 86900 nil 1 nil nil 86900 (overwrite-mode)) ("~/Dropbox/configure/.emacs.d/elpa/helm-20140223.1212/helm-autoloads.el" 45055 nil 1 nil nil 45055 (overwrite-mode)) ("~/Dropbox/configure/.emacs.d/elpa/org-20140224/org-autoloads.el" 27239 nil 1 nil nil 27239 (overwrite-mode))))
(setq-default TeX-command-history '("LatexMk" "Evince"))
(setq-default buffer-name-history '("*Packages*" "es.org" "PKGBUILD" "*init log*"))
(setq-default command-history '((kill-buffer "*Packages*") (kill-buffer "es.org") (kill-buffer "PKGBUILD") (yas-load-snippet-buffer-and-close (quote org-mode) nil) (find-file "~/Dropbox/meeting/withHasegawa/140305/" t) (find-file "~/Dropbox/meeting/withHasegawa/140305/140305-M1meeting.org" t) (dired-create-directory "~/Dropbox/meeting/withHasegawa/140305") (find-file "~/Dropbox/meeting/withHasegawa/" t) (kill-buffer "*init log*")))
(setq-default extended-command-history '("package-list-packages" "count-lines-region" "pascal-mode"))
(setq-default helm-c-source-complex-command-history '((name . "Complex Command History") (candidates lambda nil (mapcar (quote prin1-to-string) command-history)) (type . sexp)))
(setq-default helm-c-source-file-name-history '((name . "File Name History") (candidates . file-name-history) (persistent-action . ignore) (filtered-candidate-transformer . helm-file-name-history-transformer) (action ("Find file" . helm-find-many-files) ("Find file as root" . helm-find-file-as-root) ("Find file other window" . find-file-other-window) ("Find file other frame" . find-file-other-frame) ("Open dired in file's directory" . helm-open-dired) ("Grep File(s) `C-u recurse'" . helm-find-files-grep) ("Zgrep File(s) `C-u Recurse'" . helm-ff-zgrep) ("Pdfgrep File(s)" . helm-ff-pdfgrep) ("Insert as org link" . helm-files-insert-as-org-link) ("Checksum File" . helm-ff-checksum) ("Ediff File" . helm-find-files-ediff-files) ("Ediff Merge File" . helm-find-files-ediff-merge-files) ("Etags `M-., C-u tap, C-u C-u reload tag file'" . helm-ff-etags-select) ("View file" . view-file) ("Insert file" . insert-file) ("Delete file(s)" . helm-delete-marked-files) ("Open file externally (C-u to choose)" . helm-open-file-externally) ("Open file with default tool" . helm-open-file-with-default-tool) ("Find file in hex dump" . hexl-find-file))))
(setq-default helm-c-source-global-mark-ring '((name . "global-mark-ring") (candidates . helm-global-mark-ring-get-candidates) (action ("Goto line" lambda (candidate) (let ((items (split-string candidate ":"))) (helm-switch-to-buffer (cl-second items)) (helm-goto-line (string-to-number (car items)))))) (persistent-action lambda (candidate) (let ((items (split-string candidate ":"))) (helm-switch-to-buffer (cl-second items)) (helm-goto-line (string-to-number (car items))) (helm-highlight-current-line))) (persistent-help . "Show this line")))
(setq-default helm-c-source-kill-ring '((name . "Kill Ring") (init lambda nil (helm-attrset (quote last-command) last-command)) (candidates . helm-kill-ring-candidates) (filtered-candidate-transformer helm-kill-ring-transformer) (action ("Yank" . helm-kill-ring-action) ("Delete" lambda (candidate) (cl-loop for cand in (helm-marked-candidates) do (setq kill-ring (delete cand kill-ring))))) (keymap keymap (27 keymap (117 . helm-previous-line) (121 . helm-next-line)) keymap (menu-bar keymap (help-menu keymap (describe keymap (describe-mode . helm-help)))) (help keymap (109 . helm-help)) (f1 keymap (109 . helm-help)) (8 . delete-backward-char) (20 . helm-toggle-resplit-and-swap-windows) (C-tab . undefined) (triple-mouse-3 . ignore) (double-mouse-3 . ignore) (mouse-3 . ignore) (drag-mouse-3 . ignore) (down-mouse-3 . ignore) (triple-mouse-2 . ignore) (double-mouse-2 . ignore) (mouse-2 . ignore) (drag-mouse-2 . ignore) (down-mouse-2 . ignore) (triple-mouse-1 . ignore) (double-mouse-1 . ignore) (mouse-1 . ignore) (drag-mouse-1 . ignore) (down-mouse-1 . ignore) (67108897 . helm-toggle-suspend-update) (3 keymap (1 . all-from-helm-occur) (21 . helm-force-update) (6 . helm-follow-mode) (11 . helm-kill-selection-and-quit) (25 . helm-yank-selection) (4 . helm-delete-current-selection) (45 . helm-swap-windows)) (67108987 . helm-enlarge-window) (67108989 . helm-narrow-window) (19 . undefined) (18 . undefined) (23 . helm-yank-text-at-point) (24 keymap (2 . helm-resume-list-buffers-after-quit) (98 . helm-resume-previous-session-after-quit) (6 . helm-quit-and-find-file)) (11 . helm-delete-minibuffer-contents) (67108896 . helm-toggle-visible-mark) (0 . helm-toggle-visible-mark) (C-M-up . helm-scroll-other-window-down) (C-M-down . helm-scroll-other-window) (M-prior . helm-scroll-other-window-down) (M-next . helm-scroll-other-window) (12 . helm-recenter-top-bottom-other-window) (15 . helm-next-source) (10 . helm-select-3rd-action) (5 . helm-select-2nd-action-or-end-of-line) (26 . helm-execute-persistent-action) (9 . helm-select-action) (13 . helm-exit-minibuffer) (left . helm-previous-source) (right . helm-next-source) (7 . helm-keyboard-quit) (22 . helm-next-page) (27 keymap (110 . next-history-element) (112 . previous-history-element) (115 . undefined) (5 . helm-display-all-sources) (1 . helm-show-all-in-this-source-only) (117 . helm-unmark-all) (97 . helm-mark-all) (109 . helm-toggle-all-marks) (41 . helm-next-visible-mark) (40 . helm-prev-visible-mark) (91) (32 . helm-toggle-visible-mark) (33554454 . helm-scroll-other-window-down) (25 . helm-scroll-other-window-down) (22 . helm-scroll-other-window) (12 . helm-reposition-window-other-window) (62 . helm-end-of-buffer) (60 . helm-beginning-of-buffer) (118 . helm-previous-page)) (next . helm-next-page) (prior . helm-previous-page) (16 . helm-previous-line) (14 . helm-next-line) (up . helm-previous-line) (down . helm-next-line) keymap (26 . undefined) (18 . helm-minibuffer-history) (S-tab . zlc-select-previous) (backtab . zlc-select-previous) (menu-bar keymap (minibuf #1="Minibuf" keymap (previous menu-item "Previous History Item" previous-history-element :help "Put previous minibuffer history element in the minibuffer") (next menu-item "Next History Item" next-history-element :help "Put next minibuffer history element in the minibuffer") (isearch-backward menu-item "Isearch History Backward" isearch-backward :help "Incrementally search minibuffer history backward") (isearch-forward menu-item "Isearch History Forward" isearch-forward :help "Incrementally search minibuffer history forward") (return menu-item "Enter" exit-minibuffer :key-sequence "" :help "Terminate input and exit minibuffer") (quit menu-item "Quit" abort-recursive-edit :help "Abort input and exit minibuffer") #1#)) (10 . exit-minibuffer) (13 . exit-minibuffer) (7 . minibuffer-keyboard-quit) (C-tab . file-cache-minibuffer-complete) (9 . self-insert-command) (XF86Back . previous-history-element) (up . previous-history-element) (prior . previous-history-element) (XF86Forward . next-history-element) (down . next-history-element) (next . next-history-element) (27 keymap (63 . session-minibuffer-history-help) (114 . previous-matching-history-element) (115 . next-matching-history-element) (112 . previous-history-element) (110 . next-history-element))) (last-command . kill-region) (migemo) (multiline)))
(setq-default helm-c-source-mark-ring '((name . "mark-ring") (candidates . helm-mark-ring-get-candidates) (action ("Goto line" lambda (candidate) (helm-goto-line (string-to-number candidate)))) (persistent-action lambda (candidate) (helm-goto-line (string-to-number candidate)) (helm-highlight-current-line)) (persistent-help . "Show this line")))
(setq-default helm-source--ff-file-name-history '((name . "File name history") (init lambda nil (with-helm-alive-p (when helm-ff-file-name-history-use-recentf (require (quote recentf)) (or recentf-mode (recentf-mode 1))))) (candidates lambda nil (if helm-ff-file-name-history-use-recentf recentf-list file-name-history)) (persistent-action . ignore) (filtered-candidate-transformer . helm-file-name-history-transformer) (action ("Find file" lambda (candidate) (helm-set-pattern (expand-file-name candidate)) (with-helm-after-update-hook (helm-exit-minibuffer))) ("Find file in helm" lambda (candidate) (helm-set-pattern (expand-file-name candidate))))))
(setq-default helm-source-complex-command-history '((name . "Complex Command History") (candidates lambda nil (mapcar (quote prin1-to-string) command-history)) (type . sexp)))
(setq-default helm-source-file-name-history '((name . "File Name History") (candidates . file-name-history) (persistent-action . ignore) (filtered-candidate-transformer . helm-file-name-history-transformer) (action ("Find file" . helm-find-many-files) ("Find file as root" . helm-find-file-as-root) ("Find file other window" . find-file-other-window) ("Find file other frame" . find-file-other-frame) ("Open dired in file's directory" . helm-open-dired) ("Grep File(s) `C-u recurse'" . helm-find-files-grep) ("Zgrep File(s) `C-u Recurse'" . helm-ff-zgrep) ("Pdfgrep File(s)" . helm-ff-pdfgrep) ("Insert as org link" . helm-files-insert-as-org-link) ("Checksum File" . helm-ff-checksum) ("Ediff File" . helm-find-files-ediff-files) ("Ediff Merge File" . helm-find-files-ediff-merge-files) ("Etags `M-., C-u tap, C-u C-u reload tag file'" . helm-ff-etags-select) ("View file" . view-file) ("Insert file" . insert-file) ("Delete file(s)" . helm-delete-marked-files) ("Open file externally (C-u to choose)" . helm-open-file-externally) ("Open file with default tool" . helm-open-file-with-default-tool) ("Find file in hex dump" . hexl-find-file))))
(setq-default helm-source-global-mark-ring '((name . "global-mark-ring") (candidates . helm-global-mark-ring-get-candidates) (action ("Goto line" lambda (candidate) (let ((items (split-string candidate ":"))) (helm-switch-to-buffer (cl-second items)) (helm-goto-line (string-to-number (car items)))))) (persistent-action lambda (candidate) (let ((items (split-string candidate ":"))) (helm-switch-to-buffer (cl-second items)) (helm-goto-line (string-to-number (car items))) (helm-highlight-current-line))) (persistent-help . "Show this line")))
(setq-default helm-source-kill-ring '((name . "Kill Ring") (init lambda nil (helm-attrset (quote last-command) last-command)) (candidates . helm-kill-ring-candidates) (filtered-candidate-transformer helm-kill-ring-transformer) (action ("Yank" . helm-kill-ring-action) ("Delete" lambda (candidate) (cl-loop for cand in (helm-marked-candidates) do (setq kill-ring (delete cand kill-ring))))) (keymap keymap (27 keymap (117 . helm-previous-line) (121 . helm-next-line)) keymap (menu-bar keymap (help-menu keymap (describe keymap (describe-mode . helm-help)))) (help keymap (109 . helm-help)) (f1 keymap (109 . helm-help)) (8 . delete-backward-char) (20 . helm-toggle-resplit-and-swap-windows) (C-tab . undefined) (triple-mouse-3 . ignore) (double-mouse-3 . ignore) (mouse-3 . ignore) (drag-mouse-3 . ignore) (down-mouse-3 . ignore) (triple-mouse-2 . ignore) (double-mouse-2 . ignore) (mouse-2 . ignore) (drag-mouse-2 . ignore) (down-mouse-2 . ignore) (triple-mouse-1 . ignore) (double-mouse-1 . ignore) (mouse-1 . ignore) (drag-mouse-1 . ignore) (down-mouse-1 . ignore) (67108897 . helm-toggle-suspend-update) (3 keymap (1 . all-from-helm-occur) (21 . helm-force-update) (6 . helm-follow-mode) (11 . helm-kill-selection-and-quit) (25 . helm-yank-selection) (4 . helm-delete-current-selection) (45 . helm-swap-windows)) (67108987 . helm-enlarge-window) (67108989 . helm-narrow-window) (19 . undefined) (18 . undefined) (23 . helm-yank-text-at-point) (24 keymap (2 . helm-resume-list-buffers-after-quit) (98 . helm-resume-previous-session-after-quit) (6 . helm-quit-and-find-file)) (11 . helm-delete-minibuffer-contents) (67108896 . helm-toggle-visible-mark) (0 . helm-toggle-visible-mark) (C-M-up . helm-scroll-other-window-down) (C-M-down . helm-scroll-other-window) (M-prior . helm-scroll-other-window-down) (M-next . helm-scroll-other-window) (12 . helm-recenter-top-bottom-other-window) (15 . helm-next-source) (10 . helm-select-3rd-action) (5 . helm-select-2nd-action-or-end-of-line) (26 . helm-execute-persistent-action) (9 . helm-select-action) (13 . helm-exit-minibuffer) (left . helm-previous-source) (right . helm-next-source) (7 . helm-keyboard-quit) (22 . helm-next-page) (27 keymap (110 . next-history-element) (112 . previous-history-element) (115 . undefined) (5 . helm-display-all-sources) (1 . helm-show-all-in-this-source-only) (117 . helm-unmark-all) (97 . helm-mark-all) (109 . helm-toggle-all-marks) (41 . helm-next-visible-mark) (40 . helm-prev-visible-mark) (91) (32 . helm-toggle-visible-mark) (33554454 . helm-scroll-other-window-down) (25 . helm-scroll-other-window-down) (22 . helm-scroll-other-window) (12 . helm-reposition-window-other-window) (62 . helm-end-of-buffer) (60 . helm-beginning-of-buffer) (118 . helm-previous-page)) (next . helm-next-page) (prior . helm-previous-page) (16 . helm-previous-line) (14 . helm-next-line) (up . helm-previous-line) (down . helm-next-line) keymap (26 . undefined) (18 . helm-minibuffer-history) (S-tab . zlc-select-previous) (backtab . zlc-select-previous) (menu-bar keymap (minibuf #1="Minibuf" keymap (previous menu-item "Previous History Item" previous-history-element :help "Put previous minibuffer history element in the minibuffer") (next menu-item "Next History Item" next-history-element :help "Put next minibuffer history element in the minibuffer") (isearch-backward menu-item "Isearch History Backward" isearch-backward :help "Incrementally search minibuffer history backward") (isearch-forward menu-item "Isearch History Forward" isearch-forward :help "Incrementally search minibuffer history forward") (return menu-item "Enter" exit-minibuffer :key-sequence "" :help "Terminate input and exit minibuffer") (quit menu-item "Quit" abort-recursive-edit :help "Abort input and exit minibuffer") #1#)) (10 . exit-minibuffer) (13 . exit-minibuffer) (7 . minibuffer-keyboard-quit) (C-tab . file-cache-minibuffer-complete) (9 . self-insert-command) (XF86Back . previous-history-element) (up . previous-history-element) (prior . previous-history-element) (XF86Forward . next-history-element) (down . next-history-element) (next . next-history-element) (27 keymap (63 . session-minibuffer-history-help) (114 . previous-matching-history-element) (115 . next-matching-history-element) (112 . previous-history-element) (110 . next-history-element))) (last-command . kill-region) (migemo) (multiline)))
(setq-default helm-source-mark-ring '((name . "mark-ring") (candidates . helm-mark-ring-get-candidates) (action ("Goto line" lambda (candidate) (helm-goto-line (string-to-number candidate)))) (persistent-action lambda (candidate) (helm-goto-line (string-to-number candidate)) (helm-highlight-current-line)) (persistent-help . "Show this line")))
(setq-default minibuffer-history '("org " "org es" "pa" "pack" "org" "ki" "org-mode" "figure" "tex" "evince 140305-M1meeting.pdf" "pac" "report" #("と思い志望しています．" 0 1 (fontified t) 1 10 (fontified t) 10 11 (fontified t)) #("ました．" 0 3 (fontified t) 3 4 (fontified t)) #("私は，貴社のフィールドを利用してスマートシティを実現したいです．街全体" 0 2 (fontified t) 2 3 (fontified t) 3 16 (fontified t) 16 35 (fontified t)) #("しています．" 0 4 (fontified t) 4 5 (fontified t) 5 6 (fontified t)) "org hitachi" "count line" "data" "or" "es nri" "package-list"))
(setq-default occur-collect-regexp-history '("\\1"))
(setq-default search-ring '("In" "の"))
(setq-default table-capture-columns-history '(""))
(setq-default table-capture-justify-history '("left"))
(setq-default table-capture-min-cell-width-history '("5"))
(setq-default table-cell-height-history '("1"))
(setq-default table-cell-span-direction-history '("right"))
(setq-default table-cell-split-contents-to-history '("split"))
(setq-default table-cell-split-orientation-history '("horizontally"))
(setq-default table-cell-width-history '("5"))
(setq-default table-col-delim-regexp-history '(""))
(setq-default table-columns-history '("3"))
(setq-default table-insert-row-column-history '("row"))
(setq-default table-justify-history '("center"))
(setq-default table-row-delim-regexp-history '(""))
(setq-default table-rows-history '("3"))
(setq-default table-sequence-count-history '("0"))
(setq-default table-sequence-increment-history '("1"))
(setq-default table-sequence-interval-history '("1"))
(setq-default table-sequence-justify-history '("left"))
(setq-default table-sequence-string-history '("0"))
(setq-default table-source-caption-history '("Table"))
(setq-default table-source-language-history '("html"))
(setq-default table-target-history '("cell"))
